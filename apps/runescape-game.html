<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgentScape | SUITE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }

        /* === RS-STYLE GAME FRAME === */
        #game-frame {
            display: grid;
            grid-template-columns: 1fr 220px;
            grid-template-rows: 1fr 160px;
            width: 100vw; height: 100vh;
        }
        #game-viewport {
            position: relative; overflow: hidden; background: #000;
            grid-row: 1; grid-column: 1;
        }
        #game-viewport canvas { display: block; width: 100%; height: 100%; }
        #npc-labels, #chat-bubbles { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }

        /* Right Sidebar */
        #game-sidebar {
            grid-row: 1 / 3; grid-column: 2;
            background: linear-gradient(180deg, #2a2a2e 0%, #1a1a1f 100%);
            border-left: 2px solid #4a4a50;
            display: flex; flex-direction: column; overflow: hidden;
        }

        /* Minimap in sidebar */
        #minimap-wrap {
            padding: 8px; text-align: center;
            border-bottom: 2px solid #4a4a50;
            background: #1a1a1f;
        }
        #minimap { border: 2px solid #5a5a60; border-radius: 2px; display: block; margin: 0 auto; }

        /* HP / Energy Orbs */
        #orbs-row {
            display: flex; justify-content: center; gap: 16px; padding: 8px 0;
            border-bottom: 2px solid #4a4a50; background: #222226;
        }
        .orb {
            width: 40px; height: 40px; border-radius: 50%;
            border: 2px solid #5a5a60; position: relative;
            display: flex; align-items: center; justify-content: center;
            font-size: 10px; font-weight: bold; color: #fff;
            text-shadow: 0 0 3px #000;
        }
        .orb-hp { background: conic-gradient(#22c55e var(--hp-pct, 100%), #333 0); }
        .orb-energy { background: conic-gradient(#eab308 var(--energy-pct, 100%), #333 0); }
        .orb-combat { background: conic-gradient(#6366f1 100%, #333 0); }
        .orb-inner {
            width: 28px; height: 28px; border-radius: 50%;
            background: #1a1a1f; display: flex; align-items: center;
            justify-content: center; font-size: 11px;
        }

        /* Sidebar Tabs */
        #sidebar-tabs {
            display: flex; border-bottom: 2px solid #4a4a50;
        }
        .sidebar-tab {
            flex: 1; padding: 6px 2px; text-align: center;
            font-size: 10px; font-weight: bold; color: #9ca3af;
            background: #2a2a2e; border: none; cursor: pointer;
            border-right: 1px solid #4a4a50;
            border-top: 2px solid transparent;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .sidebar-tab:last-child { border-right: none; }
        .sidebar-tab.active { background: #1a1a1f; color: #fff; border-top-color: #6366f1; }
        .sidebar-tab:hover { color: #fff; }

        /* Sidebar Content */
        .sidebar-content { flex: 1; overflow-y: auto; display: none; }
        .sidebar-content.active { display: block; }
        .sidebar-content::-webkit-scrollbar { width: 4px; }
        .sidebar-content::-webkit-scrollbar-thumb { background: #4a4a50; }

        /* Inventory Grid */
        #inv-grid {
            display: grid; grid-template-columns: repeat(4, 1fr);
            gap: 2px; padding: 4px;
        }
        .inv-slot {
            aspect-ratio: 1; background: #1a1a1f;
            border: 1px solid #3a3a40; display: flex;
            align-items: center; justify-content: center;
            font-size: 20px; position: relative; cursor: pointer;
            border-radius: 2px;
        }
        .inv-slot:hover { border-color: #6366f1; background: #222230; }
        .inv-slot.equipped { border-color: #22c55e; box-shadow: inset 0 0 6px rgba(34,197,94,0.3); }
        .inv-slot-qty {
            position: absolute; bottom: 1px; right: 3px;
            font-size: 9px; color: #eab308; font-weight: bold;
            text-shadow: 0 0 2px #000;
        }

        /* Stats Panel */
        #stats-content { padding: 4px; }
        .stat-player-info {
            padding: 8px; text-align: center;
            border-bottom: 2px solid #4a4a50;
        }
        .stat-player-name { font-size: 13px; color: #fff; font-weight: bold; }
        .stat-combat-lvl { font-size: 11px; color: #eab308; }

        /* OSRS-style Skill Grid */
        .skill-grid {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 1px; background: #2a2a2e; border: 1px solid #2a2a2e;
        }
        .skill-cell {
            background: #1a1a1f; padding: 3px 4px;
            display: flex; align-items: center; gap: 3px;
            cursor: pointer; position: relative; overflow: hidden;
            transition: background 0.15s;
        }
        .skill-cell:hover { background: #252530; }
        .skill-cell.skill-selected { background: #2a2a3a; box-shadow: inset 0 0 0 1px #6366f1; }
        .skill-cell.skill-levelup { animation: skillFlash 1.5s ease-out; }
        @keyframes skillFlash {
            0%, 20% { background: #6366f144; }
            100% { background: #1a1a1f; }
        }
        .skill-icon { font-size: 11px; width: 16px; text-align: center; flex-shrink: 0; }
        .skill-lvl { font-size: 11px; color: #fff; font-weight: bold; margin-left: auto; }
        .skill-xp-bar {
            position: absolute; bottom: 0; left: 0; right: 0;
            height: 2px; background: #2a2a2e;
        }
        .skill-xp-fill { height: 100%; background: #6366f1; transition: width 0.3s; }
        .skill-total {
            text-align: center; padding: 6px; font-size: 11px;
            color: #eab308; font-weight: bold;
            border-top: 1px solid #3a3a40; background: #1a1a1f;
        }
        .skill-detail {
            padding: 8px; background: #1a1a1f;
            border-top: 1px solid #3a3a40;
        }
        .skill-detail-name {
            font-size: 12px; color: #fff; font-weight: bold;
            margin-bottom: 4px;
        }
        .skill-detail-row {
            font-size: 10px; color: #9ca3af; padding: 1px 0;
        }
        .skill-detail-row b { color: #fff; }

        /* Bottom Panel */
        #game-bottom {
            grid-row: 2; grid-column: 1;
            background: linear-gradient(0deg, #1a1a1f, #222226);
            border-top: 2px solid #4a4a50;
            display: flex;
        }

        /* Chat Area */
        #chat-area {
            flex: 1; display: flex; flex-direction: column;
            border-right: 2px solid #4a4a50;
        }
        #chat-tabs {
            display: flex; border-bottom: 1px solid #3a3a40;
            flex-shrink: 0;
        }
        .chat-tab {
            padding: 4px 10px; font-size: 10px; font-weight: bold;
            color: #6b7280; background: none; border: none;
            cursor: pointer; border-bottom: 2px solid transparent;
        }
        .chat-tab.active { color: #fff; border-bottom-color: #6366f1; }
        .chat-tab:hover { color: #ccc; }
        #chat-messages {
            flex: 1; overflow-y: auto; padding: 4px 8px;
            font-size: 11px; line-height: 1.5; color: #ccc;
        }
        #chat-messages::-webkit-scrollbar { width: 4px; }
        #chat-messages::-webkit-scrollbar-thumb { background: #4a4a50; }
        .chat-msg-system { color: #6366f1; }
        .chat-msg-combat { color: #ef4444; }
        .chat-msg-public { color: #eab308; }
        .chat-msg-agent { color: #22c55e; }
        #chat-input-area { display: flex; padding: 4px; gap: 4px; flex-shrink: 0; }
        #chat-input {
            flex: 1; background: #1a1a1f; border: 1px solid #3a3a40;
            color: #fff; padding: 4px 8px; font-size: 11px; font-family: inherit;
            border-radius: 2px; outline: none;
        }
        #chat-input:focus { border-color: #6366f1; }

        /* Action Buttons */
        #action-area {
            width: 180px; padding: 8px; display: flex;
            flex-direction: column; gap: 4px; justify-content: center;
        }
        .action-btn {
            padding: 6px; font-size: 10px; font-weight: bold;
            background: #2a2a2e; color: #ccc; border: 1px solid #4a4a50;
            cursor: pointer; text-align: center; border-radius: 2px;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .action-btn:hover { background: #3a3a3e; color: #fff; border-color: #6366f1; }
        .action-btn.active { background: #6366f122; color: #6366f1; border-color: #6366f1; }

        /* NPC Labels */
        .npc-label {
            position: absolute; z-index: 15; pointer-events: none;
            font-family: 'Courier New', monospace; font-size: 10px; font-weight: bold;
            color: #fff; text-shadow: 0 0 4px rgba(0,0,0,0.9), 0 1px 2px rgba(0,0,0,0.8);
            white-space: nowrap; transform: translate(-50%, -100%);
            padding: 1px 6px; border-radius: 3px;
            background: rgba(0,0,0,0.5);
        }

        /* Chat Bubbles */
        .chat-bubble {
            position: absolute; z-index: 16; pointer-events: none;
            font-family: 'Courier New', monospace; font-size: 11px; font-weight: bold;
            color: #ffff00; text-shadow: 0 0 4px rgba(0,0,0,0.9);
            white-space: nowrap; transform: translate(-50%, -100%);
            padding: 2px 8px; border-radius: 4px;
            background: rgba(0,0,0,0.6);
            animation: bubbleFade 5s forwards;
        }
        @keyframes bubbleFade {
            0%, 70% { opacity: 1; transform: translate(-50%, -100%); }
            100% { opacity: 0; transform: translate(-50%, -120%); }
        }

        /* Context Menu */
        #context-menu {
            position: fixed; z-index: 100; display: none;
            background: #1a1a1f; border: 1px solid #4a4a50;
            min-width: 140px; font-size: 12px;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.5);
        }
        .ctx-option {
            padding: 5px 12px; color: #ccc; cursor: pointer;
            border-bottom: 1px solid #2a2a2e;
        }
        .ctx-option:hover { background: #2a2a3e; color: #fff; }
        .ctx-option:last-child { border-bottom: none; }
        .ctx-header {
            padding: 4px 12px; color: #6366f1; font-weight: bold;
            font-size: 11px; border-bottom: 1px solid #4a4a50;
        }

        /* Health Bars */
        .health-bar-wrap {
            position: absolute; z-index: 14; pointer-events: none;
            transform: translate(-50%, 0); width: 40px;
        }
        .health-bar { width: 100%; height: 5px; background: #333; border: 1px solid #000; }
        .health-bar-fill { height: 100%; background: #22c55e; transition: width 0.2s; }

        /* Hitsplats */
        .hitsplat {
            position: absolute; z-index: 17; pointer-events: none;
            transform: translate(-50%, -50%);
            width: 24px; height: 24px; border-radius: 50%;
            background: #cc0000; display: flex; align-items: center;
            justify-content: center; font-size: 10px; font-weight: bold;
            color: #fff; text-shadow: 0 0 2px #000;
            animation: hitsplatAnim 1s forwards;
        }
        .hitsplat.miss { background: #4444ff; }
        @keyframes hitsplatAnim {
            0% { opacity: 1; transform: translate(-50%, -50%); }
            100% { opacity: 0; transform: translate(-50%, -100%); }
        }

        /* Death Screen */
        #death-screen {
            position: absolute; inset: 0; z-index: 50;
            background: rgba(139,0,0,0.7); display: none;
            align-items: center; justify-content: center;
            flex-direction: column; gap: 12px;
        }
        #death-screen h1 { color: #fff; font-size: 24px; }
        #death-screen p { color: #ccc; font-size: 14px; }

        /* Loot Pile */
        .loot-label {
            position: absolute; z-index: 14; pointer-events: none;
            font-size: 10px; color: #eab308; font-weight: bold;
            text-shadow: 0 0 3px #000;
            transform: translate(-50%, 0);
            animation: lootPulse 1s infinite;
        }
        @keyframes lootPulse { 50% { transform: translate(-50%, -3px); } }

        /* Overlay Panels (Quest Board, Shop, Crafting) */
        .game-overlay {
            position: absolute; inset: 0; z-index: 40;
            background: rgba(0,0,0,0.75); display: none;
            align-items: center; justify-content: center;
        }
        .game-overlay.open { display: flex; }
        .overlay-panel {
            background: linear-gradient(180deg, #2a2a2e, #1a1a1f);
            border: 2px solid #4a4a50; border-radius: 4px;
            width: 520px; max-height: 80vh; overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        .overlay-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 14px; border-bottom: 2px solid #4a4a50;
            background: #222226;
        }
        .overlay-header h2 { font-size: 14px; color: #fff; margin: 0; }
        .overlay-close {
            background: none; border: none; color: #9ca3af; font-size: 18px;
            cursor: pointer; padding: 0 4px;
        }
        .overlay-close:hover { color: #fff; }
        .overlay-body { padding: 10px; }

        /* Quest List */
        .quest-item {
            padding: 8px 10px; border-bottom: 1px solid #2a2a2e;
            cursor: pointer; display: flex; align-items: center; gap: 8px;
        }
        .quest-item:hover { background: #2a2a3e; }
        .quest-item.completed { opacity: 0.5; }
        .quest-difficulty { font-size: 9px; padding: 2px 6px; border-radius: 2px; font-weight: bold; text-transform: uppercase; }
        .quest-difficulty.easy { background: #22c55e33; color: #22c55e; }
        .quest-difficulty.medium { background: #eab30833; color: #eab308; }
        .quest-difficulty.hard { background: #ef444433; color: #ef4444; }
        .quest-difficulty.legendary { background: #a855f733; color: #a855f7; }
        .quest-name { flex: 1; font-size: 12px; color: #ccc; }
        .quest-status-icon { font-size: 14px; }
        .quest-detail { padding: 10px; }
        .quest-detail-desc { font-size: 11px; color: #9ca3af; margin-bottom: 8px; }
        .quest-detail-obj { font-size: 11px; color: #ccc; margin-bottom: 4px; }
        .quest-detail-rewards { font-size: 11px; color: #eab308; margin-top: 6px; }
        .quest-accept-btn {
            margin-top: 8px; padding: 6px 16px; background: #6366f1;
            color: #fff; border: none; font-size: 11px; font-weight: bold;
            cursor: pointer; border-radius: 2px; font-family: inherit;
        }
        .quest-accept-btn:hover { background: #818cf8; }
        .quest-progress-bar { width: 100%; height: 4px; background: #2a2a2e; border-radius: 2px; margin-top: 3px; }
        .quest-progress-fill { height: 100%; background: #22c55e; border-radius: 2px; transition: width 0.3s; }

        /* Sidebar quest list */
        .sidebar-quest {
            padding: 6px 8px; border-bottom: 1px solid #2a2a2e; cursor: pointer;
        }
        .sidebar-quest:hover { background: #2a2a3e; }
        .sidebar-quest-name { font-size: 11px; color: #ccc; font-weight: bold; }
        .sidebar-quest-progress { font-size: 9px; color: #9ca3af; }
        .sidebar-quest.done .sidebar-quest-name { color: #6b7280; text-decoration: line-through; }

        /* Shop Overlay */
        .shop-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 1px;
        }
        .shop-panel { flex: 1; min-width: 0; }
        .shop-panel h3 { font-size: 11px; color: #9ca3af; padding: 6px 8px; margin: 0; border-bottom: 1px solid #2a2a2e; text-transform: uppercase; }
        .shop-item {
            display: flex; align-items: center; gap: 8px;
            padding: 6px 8px; border-bottom: 1px solid #2a2a2e;
            cursor: pointer; font-size: 11px; color: #ccc;
        }
        .shop-item:hover { background: #2a2a3e; }
        .shop-item-icon { font-size: 18px; width: 26px; text-align: center; }
        .shop-item-name { flex: 1; }
        .shop-item-price { color: #eab308; font-weight: bold; }
        .shop-item-stock { color: #6b7280; font-size: 9px; }
        .shop-coins { padding: 8px; text-align: center; font-size: 12px; color: #eab308; font-weight: bold; border-bottom: 1px solid #4a4a50; }
        .shop-buy-btns { display: flex; gap: 4px; }
        .shop-buy-btn {
            padding: 3px 8px; font-size: 9px; font-weight: bold;
            background: #2a2a2e; color: #ccc; border: 1px solid #4a4a50;
            cursor: pointer; border-radius: 2px; font-family: inherit;
        }
        .shop-buy-btn:hover { background: #3a3a3e; border-color: #6366f1; color: #fff; }

        /* Skilling action area */
        .skill-timer {
            width: 100%; height: 6px; background: #2a2a2e; border-radius: 3px; margin-top: 4px;
        }
        .skill-timer-fill { height: 100%; background: #22c55e; border-radius: 3px; transition: width 0.1s linear; }

        /* Loot pile on ground */
        .loot-pile-dot {
            position: absolute; width: 8px; height: 8px; border-radius: 50%;
            background: #eab308; z-index: 13; cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 6px #eab308;
            animation: lootPulse 1s infinite;
        }

        /* Gold hitsplat for special attack */
        .hitsplat.spec { background: #eab308; width: 30px; height: 30px; font-size: 13px; }

        /* Zone Indicator */
        #zone-indicator {
            position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
            z-index: 10; font-size: 12px; font-weight: bold; color: #fff;
            text-shadow: 0 0 6px rgba(0,0,0,0.9); padding: 4px 14px;
            background: rgba(0,0,0,0.5); border-radius: 4px;
            font-family: 'Courier New', monospace; pointer-events: none;
            transition: opacity 0.3s;
        }

        /* Monster Labels */
        .monster-label {
            position: absolute; z-index: 15; pointer-events: none;
            font-family: 'Courier New', monospace; font-size: 10px; font-weight: bold;
            color: #fff; text-shadow: 0 0 4px rgba(0,0,0,0.9), 0 1px 2px rgba(0,0,0,0.8);
            white-space: nowrap; transform: translate(-50%, -100%);
            padding: 1px 6px; border-radius: 3px;
            background: rgba(139,0,0,0.6); border-bottom: 2px solid #ef4444;
        }
        /* Character Creation Screen */
        #char-create-screen {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0f 70%);
            z-index: 1000; display: flex; align-items: center; justify-content: center;
            font-family: 'Courier New', monospace;
        }
        #char-create-screen.hidden { display: none; }
        .cc-container {
            display: flex; gap: 32px; align-items: flex-start;
            background: rgba(20,20,30,0.9); border: 2px solid #4a4a50;
            border-radius: 8px; padding: 32px; max-width: 700px; width: 90%;
        }
        .cc-form { flex: 1; }
        .cc-form h1 { color: #fff; font-size: 22px; margin-bottom: 4px; }
        .cc-form p.cc-sub { color: #6b7280; font-size: 11px; margin-bottom: 20px; }
        .cc-field { margin-bottom: 16px; }
        .cc-field label { display: block; color: #9ca3af; font-size: 11px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
        .cc-field input[type="text"] {
            width: 100%; background: #1a1a1f; border: 1px solid #3a3a40;
            color: #fff; padding: 8px 12px; font-size: 14px; font-family: inherit;
            border-radius: 4px; outline: none;
        }
        .cc-field input[type="text"]:focus { border-color: #6366f1; }
        .cc-colors { display: flex; gap: 6px; flex-wrap: wrap; }
        .cc-color-btn {
            width: 28px; height: 28px; border-radius: 4px; border: 2px solid #3a3a40;
            cursor: pointer; transition: border-color 0.15s, transform 0.15s;
        }
        .cc-color-btn:hover { transform: scale(1.15); }
        .cc-color-btn.selected { border-color: #fff; box-shadow: 0 0 8px rgba(255,255,255,0.3); }
        .cc-classes { display: flex; gap: 8px; }
        .cc-class-btn {
            flex: 1; padding: 10px 6px; background: #1a1a1f; border: 1px solid #3a3a40;
            border-radius: 4px; cursor: pointer; text-align: center; transition: all 0.15s;
        }
        .cc-class-btn:hover { border-color: #6366f1; background: #222230; }
        .cc-class-btn.selected { border-color: #6366f1; background: #6366f122; }
        .cc-class-icon { font-size: 20px; display: block; margin-bottom: 4px; }
        .cc-class-name { color: #fff; font-size: 11px; font-weight: bold; display: block; }
        .cc-class-desc { color: #6b7280; font-size: 9px; display: block; margin-top: 2px; }
        .cc-start-btn {
            width: 100%; padding: 12px; background: #6366f1; color: #fff;
            border: none; border-radius: 4px; font-size: 14px; font-weight: bold;
            font-family: inherit; cursor: pointer; margin-top: 8px;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .cc-start-btn:hover { background: #5558e6; }
        .cc-start-btn:disabled { background: #333; color: #666; cursor: not-allowed; }
        .cc-preview {
            width: 180px; height: 240px; border: 2px solid #3a3a40;
            border-radius: 4px; background: #111118; flex-shrink: 0;
        }
    </style>
</head>
<body>
    <!-- Character Creation Screen -->
    <div id="char-create-screen">
        <div class="cc-container">
            <div class="cc-form">
                <h1>Create Your Character</h1>
                <p class="cc-sub">Enter the world of AgentScape</p>
                <div class="cc-field">
                    <label>Character Name</label>
                    <input type="text" id="cc-name" maxlength="16" placeholder="Enter a name..." autocomplete="off">
                </div>
                <div class="cc-field">
                    <label>Body Color</label>
                    <div class="cc-colors" id="cc-body-colors"></div>
                </div>
                <div class="cc-field">
                    <label>Hair Color</label>
                    <div class="cc-colors" id="cc-hair-colors"></div>
                </div>
                <div class="cc-field">
                    <label>Class</label>
                    <div class="cc-classes" id="cc-classes"></div>
                </div>
                <button class="cc-start-btn" id="cc-start" disabled>Enter AgentScape</button>
            </div>
            <canvas class="cc-preview" id="cc-preview" width="180" height="240"></canvas>
        </div>
    </div>

    <div id="game-frame" style="display:none;">
        <!-- Game Viewport -->
        <div id="game-viewport">
            <div id="zone-indicator">SUITE City</div>
            <div id="npc-labels"></div>
            <div id="chat-bubbles"></div>
            <div id="death-screen">
                <h1>Oh dear, you are dead!</h1>
                <p>Respawning at Town Hall...</p>
            </div>
            <!-- Quest Board Overlay -->
            <div class="game-overlay" id="quest-overlay">
                <div class="overlay-panel">
                    <div class="overlay-header">
                        <h2>üìã Quest Board</h2>
                        <button class="overlay-close" onclick="closeOverlay('quest-overlay')">&times;</button>
                    </div>
                    <div class="overlay-body" id="quest-board-content"></div>
                </div>
            </div>
            <!-- Shop Overlay -->
            <div class="game-overlay" id="shop-overlay">
                <div class="overlay-panel" style="width:600px;">
                    <div class="overlay-header">
                        <h2>üè™ Marketplace</h2>
                        <button class="overlay-close" onclick="closeOverlay('shop-overlay')">&times;</button>
                    </div>
                    <div class="shop-coins" id="shop-coins-display">ü™ô 0 Coins</div>
                    <div class="overlay-body" style="display:flex;gap:2px;" id="shop-body-content"></div>
                </div>
            </div>
            <!-- Crafting Overlay -->
            <div class="game-overlay" id="craft-overlay">
                <div class="overlay-panel">
                    <div class="overlay-header">
                        <h2>üî® Workshop ‚Äî Crafting</h2>
                        <button class="overlay-close" onclick="closeOverlay('craft-overlay')">&times;</button>
                    </div>
                    <div class="overlay-body" id="craft-content"></div>
                </div>
            </div>
        </div>

        <!-- Right Sidebar -->
        <div id="game-sidebar">
            <div id="minimap-wrap">
                <canvas id="minimap" width="200" height="200"></canvas>
            </div>
            <div id="orbs-row">
                <div class="orb orb-hp" id="orbHp"><div class="orb-inner" id="orbHpText">100</div></div>
                <div class="orb orb-combat" id="orbCombat"><div class="orb-inner" id="orbCombatText">3</div></div>
                <div class="orb orb-energy" id="orbEnergy"><div class="orb-inner" id="orbEnergyText">100</div></div>
            </div>
            <div id="sidebar-tabs">
                <button class="sidebar-tab active" onclick="switchSidebarTab('inv')">Inv</button>
                <button class="sidebar-tab" onclick="switchSidebarTab('stats')">Stats</button>
                <button class="sidebar-tab" onclick="switchSidebarTab('quests')">Quest</button>
            </div>
            <div class="sidebar-content active" id="tab-inv">
                <div id="inv-grid"></div>
            </div>
            <div class="sidebar-content" id="tab-stats">
                <div class="stat-player-info">
                    <div class="stat-player-name">Player</div>
                    <div class="stat-combat-lvl">Combat Level: <span id="statCombatLvl">3</span></div>
                </div>
                <div id="stats-content"></div>
            </div>
            <div class="sidebar-content" id="tab-quests">
                <div style="padding:8px;color:#9ca3af;font-size:11px;text-align:center;">
                    <p style="font-size:14px;margin-bottom:8px;">üìã Quests</p>
                    <p>Visit the Quest Board in town to see available bounties.</p>
                </div>
            </div>
        </div>

        <!-- Bottom Panel -->
        <div id="game-bottom">
            <div id="chat-area">
                <div id="chat-tabs">
                    <button class="chat-tab active" onclick="switchChatTab('all')">All</button>
                    <button class="chat-tab" onclick="switchChatTab('public')">Public</button>
                    <button class="chat-tab" onclick="switchChatTab('agent')">Agent</button>
                    <button class="chat-tab" onclick="switchChatTab('system')">System</button>
                </div>
                <div id="chat-messages"></div>
                <div id="chat-input-area">
                    <input id="chat-input" type="text" placeholder="Press Enter to chat..." maxlength="80">
                </div>
            </div>
            <div id="action-area">
                <button class="action-btn" id="btnAttackMode" onclick="toggleAttackMode()">Attack Mode</button>
                <button class="action-btn" id="btnSpec" onclick="useSpecialAttack()">Spec (F)</button>
                <button class="action-btn" onclick="toggleDayNight()">Day/Night</button>
                <button class="action-btn" onclick="deleteCharacter()" style="color:#ef4444;border-color:#ef444466;">Delete Char</button>
                <div id="skill-action-area"></div>
                <div style="font-size:9px;color:#6b7280;text-align:center;padding:4px;">
                    WASD Walk | Q/E Rotate<br>Scroll Zoom | Click Move | F Spec
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu"></div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    (function() {
        // ============================================================
        // === CHARACTER CREATION ===
        // ============================================================
        const BODY_COLORS = [
            '#3355aa', '#aa3333', '#33aa55', '#aa8833', '#8833aa',
            '#33aaaa', '#aa5533', '#5533aa', '#336699', '#993366'
        ];
        const HAIR_COLORS = [
            '#4a3728', '#1a1a1a', '#c4a35a', '#8c4a2f', '#d4d4d4',
            '#aa2222', '#2244aa', '#6633aa', '#22aa44', '#ff8844'
        ];
        const CLASSES = [
            { id: 'warrior', icon: '‚öîÔ∏è', name: 'Warrior', desc: '+2 Attack, +1 Strength', bonuses: { attack: 2, strength: 1 } },
            { id: 'sentinel', icon: 'üõ°Ô∏è', name: 'Sentinel', desc: '+2 Defence, +1 HP', bonuses: { defence: 2, hitpoints: 1 } },
            { id: 'explorer', icon: 'üß≠', name: 'Explorer', desc: '+1 All combat stats', bonuses: { attack: 1, strength: 1, defence: 1 } }
        ];

        const savedChar = localStorage.getItem('agentscape_character');
        let charData = savedChar ? JSON.parse(savedChar) : null;

        function runCharacterCreation() {
            return new Promise((resolve) => {
                if (charData) {
                    document.getElementById('char-create-screen').classList.add('hidden');
                    document.getElementById('game-frame').style.display = '';
                    return resolve(charData);
                }

                let selBody = BODY_COLORS[0], selHair = HAIR_COLORS[0], selClass = 'explorer';
                const nameInput = document.getElementById('cc-name');
                const startBtn = document.getElementById('cc-start');

                // Populate body colors
                const bodyDiv = document.getElementById('cc-body-colors');
                BODY_COLORS.forEach((c, i) => {
                    const btn = document.createElement('div');
                    btn.className = 'cc-color-btn' + (i === 0 ? ' selected' : '');
                    btn.style.background = c;
                    btn.onclick = () => {
                        selBody = c;
                        bodyDiv.querySelectorAll('.cc-color-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        drawPreview();
                    };
                    bodyDiv.appendChild(btn);
                });

                // Populate hair colors
                const hairDiv = document.getElementById('cc-hair-colors');
                HAIR_COLORS.forEach((c, i) => {
                    const btn = document.createElement('div');
                    btn.className = 'cc-color-btn' + (i === 0 ? ' selected' : '');
                    btn.style.background = c;
                    btn.onclick = () => {
                        selHair = c;
                        hairDiv.querySelectorAll('.cc-color-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        drawPreview();
                    };
                    hairDiv.appendChild(btn);
                });

                // Populate classes
                const classDiv = document.getElementById('cc-classes');
                CLASSES.forEach(cls => {
                    const btn = document.createElement('div');
                    btn.className = 'cc-class-btn' + (cls.id === 'explorer' ? ' selected' : '');
                    btn.innerHTML = `<span class="cc-class-icon">${cls.icon}</span><span class="cc-class-name">${cls.name}</span><span class="cc-class-desc">${cls.desc}</span>`;
                    btn.onclick = () => {
                        selClass = cls.id;
                        classDiv.querySelectorAll('.cc-class-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                    };
                    classDiv.appendChild(btn);
                });

                // Name validation
                nameInput.addEventListener('input', () => {
                    const name = nameInput.value.trim();
                    startBtn.disabled = name.length < 1 || name.length > 16;
                });

                // Preview renderer
                const pvCanvas = document.getElementById('cc-preview');
                const pvCtx = pvCanvas.getContext('2d');
                function drawPreview() {
                    pvCtx.clearRect(0, 0, 180, 240);
                    // Background gradient
                    const grad = pvCtx.createLinearGradient(0, 0, 0, 240);
                    grad.addColorStop(0, '#1a1a2e');
                    grad.addColorStop(1, '#111118');
                    pvCtx.fillStyle = grad;
                    pvCtx.fillRect(0, 0, 180, 240);
                    // Shadow
                    pvCtx.fillStyle = 'rgba(0,0,0,0.3)';
                    pvCtx.beginPath();
                    pvCtx.ellipse(90, 200, 25, 8, 0, 0, Math.PI * 2);
                    pvCtx.fill();
                    // Legs
                    pvCtx.fillStyle = '#554433';
                    pvCtx.fillRect(75, 165, 12, 30);
                    pvCtx.fillRect(93, 165, 12, 30);
                    // Body
                    pvCtx.fillStyle = selBody;
                    pvCtx.fillRect(70, 115, 40, 55);
                    // Arms
                    pvCtx.fillRect(55, 118, 15, 45);
                    pvCtx.fillRect(110, 118, 15, 45);
                    // Head (skin)
                    pvCtx.fillStyle = '#ffcc99';
                    pvCtx.fillRect(72, 75, 36, 38);
                    // Hair
                    pvCtx.fillStyle = selHair;
                    pvCtx.fillRect(70, 70, 40, 15);
                    pvCtx.fillRect(70, 70, 8, 30);
                    pvCtx.fillRect(102, 70, 8, 30);
                    // Eyes
                    pvCtx.fillStyle = '#fff';
                    pvCtx.fillRect(80, 86, 6, 5);
                    pvCtx.fillRect(94, 86, 6, 5);
                    pvCtx.fillStyle = '#222';
                    pvCtx.fillRect(82, 87, 3, 3);
                    pvCtx.fillRect(96, 87, 3, 3);
                }
                drawPreview();

                // Start button
                startBtn.onclick = () => {
                    const name = nameInput.value.trim();
                    if (!name) return;
                    const classInfo = CLASSES.find(c => c.id === selClass);
                    const data = {
                        name,
                        bodyColor: selBody,
                        hairColor: selHair,
                        classId: selClass,
                        bonuses: classInfo.bonuses
                    };
                    localStorage.setItem('agentscape_character', JSON.stringify(data));
                    charData = data;
                    document.getElementById('char-create-screen').classList.add('hidden');
                    document.getElementById('game-frame').style.display = '';
                    resolve(data);
                };

                // Enter key to submit
                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !startBtn.disabled) startBtn.click();
                });
            });
        }

        // Run character creation, then boot the game
        runCharacterCreation().then(startGame);
        function startGame(charInfo) {
        // ============================================================
        // === CONFIG ===
        // ============================================================
        const MAP_SIZE = 80;
        const TILE_SIZE = 1;
        const WATER_LEVEL = -0.15;
        const MOVE_SPEED = 4;
        const NPC_MOVE_SPEED = 2.5;
        const MONSTER_MOVE_SPEED = 2.0;
        const COMBAT_TICK = 2.4;
        const MONSTER_AGGRO_RANGE = 5;
        const MONSTER_LEASH_RANGE = 15;
        const BOSS_AGGRO_RANGE = 8;
        const BOSS_RESPAWN_TIME = 300;
        const RAID_BOSS_RESPAWN_TIME = 900;
        const API_BASE = 'https://suitegpt.app';
        const SUPABASE_URL = 'https://kyojtmbjsfkfrdvulbyg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt5b2p0bWJqc2ZrZnJkdnVsYnlnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5MTk1MTksImV4cCI6MjA1MDQ5NTUxOX0.JDUpMbOFIqkexJrSHPAzcmFpMOCbMnMxJE-IuZ8OLFY';

        // Apply character data from creation screen
        const playerName = charInfo.name;
        const playerColor = charInfo.bodyColor;
        const playerHairColor = charInfo.hairColor;
        const playerClass = charInfo.classId;
        const otherPlayers = new Map();
        let chatChannel = null;

        const ROLE_COLORS = {
            app_builder:     { hex: '#6366f1', int: 0x6366f1, name: 'Builder' },
            app_refiner:     { hex: '#f97316', int: 0xf97316, name: 'Refiner' },
            content_creator: { hex: '#22c55e', int: 0x22c55e, name: 'Creator' },
            growth_outreach: { hex: '#ec4899', int: 0xec4899, name: 'Growth' },
            qa_tester:       { hex: '#eab308', int: 0xeab308, name: 'Tester' },
        };

        // ============================================================
        // === ITEMS ===
        // ============================================================
        const ITEMS = {
            // Coins
            coins: { id:'coins', name:'Coins', icon:'\u{1FA99}', stackable:true, type:'coin' },
            // Weapons (tiered)
            bronze_sword: { id:'bronze_sword', name:'Bronze Sword', icon:'\u{1F5E1}\uFE0F', stackable:false, type:'weapon', stats:{attack:4, strength:3} },
            iron_sword: { id:'iron_sword', name:'Iron Sword', icon:'\u2694\uFE0F', stackable:false, type:'weapon', stats:{attack:8, strength:6} },
            steel_sword: { id:'steel_sword', name:'Steel Sword', icon:'\u2694\uFE0F', stackable:false, type:'weapon', stats:{attack:12, strength:10} },
            mithril_sword: { id:'mithril_sword', name:'Mithril Sword', icon:'\u{1F5E1}\uFE0F', stackable:false, type:'weapon', stats:{attack:18, strength:15} },
            rune_sword: { id:'rune_sword', name:'Rune Sword', icon:'\u2694\uFE0F', stackable:false, type:'weapon', stats:{attack:26, strength:22} },
            dragon_sword: { id:'dragon_sword', name:'Dragon Sword', icon:'\u2694\uFE0F', stackable:false, type:'weapon', stats:{attack:36, strength:30} },
            // Helms (tiered)
            bronze_helm: { id:'bronze_helm', name:'Bronze Helm', icon:'\u{1FA96}', stackable:false, type:'helm', stats:{defence:3} },
            iron_helm: { id:'iron_helm', name:'Iron Helm', icon:'\u{1FA96}', stackable:false, type:'helm', stats:{defence:6} },
            steel_helm: { id:'steel_helm', name:'Steel Helm', icon:'\u26D1\uFE0F', stackable:false, type:'helm', stats:{defence:10} },
            mithril_helm: { id:'mithril_helm', name:'Mithril Helm', icon:'\u{1FA96}', stackable:false, type:'helm', stats:{defence:15} },
            rune_helm: { id:'rune_helm', name:'Rune Helm', icon:'\u26D1\uFE0F', stackable:false, type:'helm', stats:{defence:22} },
            dragon_helm: { id:'dragon_helm', name:'Dragon Helm', icon:'\u26D1\uFE0F', stackable:false, type:'helm', stats:{defence:30} },
            // Shields (tiered)
            bronze_shield: { id:'bronze_shield', name:'Bronze Shield', icon:'\u{1F6E1}\uFE0F', stackable:false, type:'shield', stats:{defence:4} },
            iron_shield: { id:'iron_shield', name:'Iron Shield', icon:'\u{1F6E1}\uFE0F', stackable:false, type:'shield', stats:{defence:8} },
            steel_shield: { id:'steel_shield', name:'Steel Shield', icon:'\u{1F6E1}\uFE0F', stackable:false, type:'shield', stats:{defence:12} },
            mithril_shield: { id:'mithril_shield', name:'Mithril Shield', icon:'\u{1F6E1}\uFE0F', stackable:false, type:'shield', stats:{defence:18} },
            rune_shield: { id:'rune_shield', name:'Rune Shield', icon:'\u{1F6E1}\uFE0F', stackable:false, type:'shield', stats:{defence:25} },
            dragon_shield: { id:'dragon_shield', name:'Dragon Shield', icon:'\u{1F6E1}\uFE0F', stackable:false, type:'shield', stats:{defence:34} },
            // Food (tiered healing)
            bread: { id:'bread', name:'Bread', icon:'\u{1F35E}', stackable:false, type:'food', healAmount:10 },
            cooked_meat: { id:'cooked_meat', name:'Cooked Meat', icon:'\u{1F356}', stackable:false, type:'food', healAmount:20 },
            cooked_fish: { id:'cooked_fish', name:'Cooked Fish', icon:'\u{1F420}', stackable:false, type:'food', healAmount:15 },
            lobster: { id:'lobster', name:'Lobster', icon:'\u{1F99E}', stackable:false, type:'food', healAmount:30 },
            shark: { id:'shark', name:'Shark', icon:'\u{1F988}', stackable:false, type:'food', healAmount:40 },
            manta_ray: { id:'manta_ray', name:'Manta Ray', icon:'\u{1F420}', stackable:false, type:'food', healAmount:50 },
            // Potions
            attack_potion: { id:'attack_potion', name:'Attack Potion', icon:'\u2697\uFE0F', stackable:false, type:'potion' },
            strength_potion: { id:'strength_potion', name:'Strength Potion', icon:'\u2697\uFE0F', stackable:false, type:'potion' },
            defence_potion: { id:'defence_potion', name:'Defence Potion', icon:'\u2697\uFE0F', stackable:false, type:'potion' },
            // Materials (existing)
            raw_fish: { id:'raw_fish', name:'Raw Fish', icon:'\u{1F41F}', stackable:true, type:'material' },
            logs: { id:'logs', name:'Logs', icon:'\u{1FAB5}', stackable:true, type:'material' },
            code_fragment: { id:'code_fragment', name:'Code Fragment', icon:'\u{1F48E}', stackable:true, type:'material' },
            agent_core: { id:'agent_core', name:'Agent Core', icon:'\u{1F52E}', stackable:true, type:'misc' },
            // Monster drops (zone-specific)
            corrupted_byte: { id:'corrupted_byte', name:'Corrupted Byte', icon:'\u{1F9E0}', stackable:true, type:'material' },
            broken_link: { id:'broken_link', name:'Broken Link', icon:'\u{1F517}', stackable:true, type:'material' },
            rogue_script: { id:'rogue_script', name:'Rogue Script', icon:'\u{1F4DC}', stackable:true, type:'material' },
            memory_shard: { id:'memory_shard', name:'Memory Shard', icon:'\u{1F4A0}', stackable:true, type:'material' },
            null_fragment: { id:'null_fragment', name:'Null Fragment', icon:'\u26A0\uFE0F', stackable:true, type:'material' },
            overflow_essence: { id:'overflow_essence', name:'Overflow Essence', icon:'\u{1F300}', stackable:true, type:'material' },
            dark_packet: { id:'dark_packet', name:'Dark Packet', icon:'\u{1F311}', stackable:true, type:'material' },
            firewall_core: { id:'firewall_core', name:'Firewall Core', icon:'\u{1F525}', stackable:true, type:'material' },
            dragon_scale: { id:'dragon_scale', name:'Dragon Scale', icon:'\u{1F409}', stackable:true, type:'material' },
            network_key: { id:'network_key', name:'Network Key', icon:'\u{1F511}', stackable:false, type:'misc' },
            // Boss trophies
            rogue_script_trophy: { id:'rogue_script_trophy', name:'Rogue Script Trophy', icon:'\u{1F3C6}', stackable:false, type:'misc' },
            golem_heart: { id:'golem_heart', name:'404 Golem Heart', icon:'\u{1F5A4}', stackable:false, type:'misc' },
            hallucinator_eye: { id:'hallucinator_eye', name:'Hallucinator Eye', icon:'\u{1F441}\uFE0F', stackable:false, type:'misc' },
            dragon_heart: { id:'dragon_heart', name:'Dragon Heart', icon:'\u2764\uFE0F\u200D\u{1F525}', stackable:false, type:'misc' },
            // Logs (woodcutting resources)
            normal_logs: { id:'normal_logs', name:'Logs', icon:'ü™µ', stackable:true, type:'resource' },
            oak_logs: { id:'oak_logs', name:'Oak Logs', icon:'ü™µ', stackable:true, type:'resource' },
            willow_logs: { id:'willow_logs', name:'Willow Logs', icon:'ü™µ', stackable:true, type:'resource' },
            maple_logs: { id:'maple_logs', name:'Maple Logs', icon:'ü™µ', stackable:true, type:'resource' },
            yew_logs: { id:'yew_logs', name:'Yew Logs', icon:'ü™µ', stackable:true, type:'resource' },
            magic_logs: { id:'magic_logs', name:'Magic Logs', icon:'ü™µ', stackable:true, type:'resource' },
            // Axes (woodcutting tools)
            bronze_axe: { id:'bronze_axe', name:'Bronze Axe', icon:'ü™ì', stackable:false, type:'axe', wcLevel:1, speedMult:1.0, stats:{attack:3} },
            iron_axe: { id:'iron_axe', name:'Iron Axe', icon:'ü™ì', stackable:false, type:'axe', wcLevel:1, speedMult:0.85, stats:{attack:5} },
            steel_axe: { id:'steel_axe', name:'Steel Axe', icon:'ü™ì', stackable:false, type:'axe', wcLevel:6, speedMult:0.7, stats:{attack:8} },
            mithril_axe: { id:'mithril_axe', name:'Mithril Axe', icon:'ü™ì', stackable:false, type:'axe', wcLevel:21, speedMult:0.55, stats:{attack:12} },
            rune_axe: { id:'rune_axe', name:'Rune Axe', icon:'ü™ì', stackable:false, type:'axe', wcLevel:41, speedMult:0.4, stats:{attack:18} },
            dragon_axe: { id:'dragon_axe', name:'Dragon Axe', icon:'ü™ì', stackable:false, type:'axe', wcLevel:61, speedMult:0.3, stats:{attack:25} },
            // Raw fish (fishing resources)
            raw_shrimp: { id:'raw_shrimp', name:'Raw Shrimp', icon:'ü¶ê', stackable:true, type:'resource' },
            raw_herring: { id:'raw_herring', name:'Raw Herring', icon:'üêü', stackable:true, type:'resource' },
            raw_trout: { id:'raw_trout', name:'Raw Trout', icon:'üêü', stackable:true, type:'resource' },
            raw_lobster: { id:'raw_lobster', name:'Raw Lobster', icon:'ü¶û', stackable:true, type:'resource' },
            raw_swordfish: { id:'raw_swordfish', name:'Raw Swordfish', icon:'üê°', stackable:true, type:'resource' },
            raw_shark: { id:'raw_shark', name:'Raw Shark', icon:'ü¶à', stackable:true, type:'resource' },
            raw_manta_ray: { id:'raw_manta_ray', name:'Raw Manta Ray', icon:'üê†', stackable:true, type:'resource' },
            // Cooked fish (food)
            cooked_shrimp: { id:'cooked_shrimp', name:'Cooked Shrimp', icon:'ü¶ê', stackable:false, type:'food', healAmount:3 },
            cooked_herring: { id:'cooked_herring', name:'Cooked Herring', icon:'üêü', stackable:false, type:'food', healAmount:8 },
            cooked_trout: { id:'cooked_trout', name:'Cooked Trout', icon:'üêü', stackable:false, type:'food', healAmount:12 },
            cooked_swordfish: { id:'cooked_swordfish', name:'Cooked Swordfish', icon:'üê°', stackable:false, type:'food', healAmount:35 },
        };

        // ============================================================
        // === TREE TYPES ===
        // ============================================================
        const TREE_TYPES = {
            normal: { id:'normal', name:'Normal tree', wcLevel:1, xp:25, chopTime:3, respawnTime:10, logItem:'normal_logs', zones:['city','forest'] },
            oak: { id:'oak', name:'Oak tree', wcLevel:15, xp:37, chopTime:4, respawnTime:15, logItem:'oak_logs', zones:['forest'] },
            willow: { id:'willow', name:'Willow tree', wcLevel:30, xp:67, chopTime:5, respawnTime:15, logItem:'willow_logs', zones:['forest'] },
            maple: { id:'maple', name:'Maple tree', wcLevel:45, xp:100, chopTime:6, respawnTime:30, logItem:'maple_logs', zones:['forest'] },
            yew: { id:'yew', name:'Yew tree', wcLevel:60, xp:175, chopTime:8, respawnTime:60, logItem:'yew_logs', zones:['ruins'] },
            magic: { id:'magic', name:'Magic tree', wcLevel:75, xp:250, chopTime:10, respawnTime:120, logItem:'magic_logs', zones:['deep'] },
        };

        // ============================================================
        // === FISH TYPES ===
        // ============================================================
        const FISH_TYPES = {
            shrimp:    { id:'shrimp',    name:'Shrimp',     fishLevel:1,  xp:10,  catchTime:2.5, respawnTime:8,  rawItem:'raw_shrimp',    zones:['forest','city'] },
            herring:   { id:'herring',   name:'Herring',    fishLevel:10, xp:30,  catchTime:3,   respawnTime:10, rawItem:'raw_herring',   zones:['forest'] },
            trout:     { id:'trout',     name:'Trout',      fishLevel:20, xp:50,  catchTime:3.5, respawnTime:12, rawItem:'raw_trout',     zones:['forest'] },
            lobster:   { id:'lobster',   name:'Lobster',    fishLevel:40, xp:90,  catchTime:4.5, respawnTime:20, rawItem:'raw_lobster',   zones:['ruins'] },
            swordfish: { id:'swordfish', name:'Swordfish',  fishLevel:50, xp:100, catchTime:5,   respawnTime:25, rawItem:'raw_swordfish', zones:['ruins'] },
            shark:     { id:'shark',     name:'Shark',      fishLevel:76, xp:110, catchTime:6,   respawnTime:40, rawItem:'raw_shark',     zones:['deep'] },
            manta_ray: { id:'manta_ray', name:'Manta Ray',  fishLevel:81, xp:150, catchTime:7,   respawnTime:60, rawItem:'raw_manta_ray', zones:['deep'] },
        };

        // ============================================================
        // === QUESTS ===
        // ============================================================
        const QUESTS = {
            // === ORIGINAL QUESTS (city-based) ===
            first_blood: {
                id:'first_blood', name:'First Blood', difficulty:'easy',
                description:'Defeat any agent in combat.',
                objectives:[{type:'kill', target:'any', count:1, progress:0}],
                rewards:{coins:50, xp:{attack:20, strength:20}}
            },
            pest_control: {
                id:'pest_control', name:'Pest Control', difficulty:'medium',
                description:'Defeat 3 QA Testers who are causing havoc.',
                objectives:[{type:'kill', target:'qa_tester', count:3, progress:0}],
                rewards:{coins:150, xp:{attack:50, strength:50, defence:30}, items:[{id:'iron_sword', qty:1}]},
                prereqs:['first_blood']
            },
            code_collector: {
                id:'code_collector', name:'Code Collector', difficulty:'medium',
                description:'Gather 5 Code Fragments from defeated builders.',
                objectives:[{type:'collect', item:'code_fragment', count:5, progress:0}],
                rewards:{coins:200, xp:{hitpoints:40}}
            },
            world_tour: {
                id:'world_tour', name:'World Tour', difficulty:'easy',
                description:'Visit the Town Hall, Workshop, Marketplace, and Arena.',
                objectives:[{type:'visit', buildings:['town_hall','workshop','marketplace','arena'], visited:[]}],
                rewards:{coins:100, xp:{hitpoints:30}}
            },
            arena_champion: {
                id:'arena_champion', name:'Arena Champion', difficulty:'hard',
                description:'Defeat 5 agents inside the Arena zone.',
                objectives:[{type:'kill_zone', zone:'arena', count:5, progress:0}],
                rewards:{coins:300, xp:{attack:80, strength:80, defence:60}, items:[{id:'steel_sword', qty:1}]},
                prereqs:['pest_control']
            },
            bread_run: {
                id:'bread_run', name:'Bread Run', difficulty:'easy',
                description:'Collect 3 Bread and deliver them to the Farm.',
                objectives:[{type:'deliver', item:'bread', count:3, destination:'farm', progress:0}],
                rewards:{coins:75, xp:{hitpoints:20}}
            },
            core_hunter: {
                id:'core_hunter', name:'Core Hunter', difficulty:'hard',
                description:'Collect 3 Agent Cores from the toughest agents.',
                objectives:[{type:'collect', item:'agent_core', count:3, progress:0}],
                rewards:{coins:500, xp:{attack:100, strength:100}, items:[{id:'steel_helm', qty:1}]},
                prereqs:['first_blood']
            },
            full_clear: {
                id:'full_clear', name:'Full Clear', difficulty:'hard',
                description:'Defeat one agent of every role.',
                objectives:[{type:'kill_roles', roles:['app_builder','app_refiner','content_creator','growth_outreach','qa_tester'], killed:[]}],
                rewards:{coins:400, xp:{attack:60, strength:60, defence:60, hitpoints:60}},
                prereqs:['first_blood']
            },
            // === DISTRICT EXPLORATION ===
            district_tour: {
                id:'district_tour', name:'District Tour', difficulty:'easy',
                description:'Visit one building in each of the 7 SUITE City districts.',
                objectives:[{type:'visit', buildings:['health_clinic','academy','exchange','workshop','studio','broadcast_tower','farm'], visited:[]}],
                rewards:{coins:200, xp:{hitpoints:50}}
            },
            // === THE FOREST QUESTS ===
            forest_explorer: {
                id:'forest_explorer', name:'Forest Explorer', difficulty:'easy',
                description:'Enter The Forest and visit the Forest Outpost.',
                objectives:[{type:'visit_zone', zones:['the_forest'], visited:[]}],
                rewards:{coins:50, xp:{hitpoints:20}},
                zone:'the_forest'
            },
            spam_cleanup: {
                id:'spam_cleanup', name:'Spam Cleanup', difficulty:'easy',
                description:'Destroy 10 Spam Bots polluting the forest.',
                objectives:[{type:'kill_monster', monsterId:'spam_bot', count:10, progress:0}],
                rewards:{coins:100, xp:{attack:40, strength:30}},
                zone:'the_forest'
            },
            link_repair: {
                id:'link_repair', name:'Link Repair', difficulty:'medium',
                description:'Collect 10 Broken Links to repair the network.',
                objectives:[{type:'collect', item:'broken_link', count:10, progress:0}],
                rewards:{coins:200, xp:{attack:60, hitpoints:40}, items:[{id:'iron_shield', qty:1}]},
                zone:'the_forest'
            },
            data_purge: {
                id:'data_purge', name:'Data Purge', difficulty:'medium',
                description:'Defeat 5 Corrupt Data entities and 3 Virus Walkers.',
                objectives:[
                    {type:'kill_monster', monsterId:'corrupt_data', count:5, progress:0},
                    {type:'kill_monster', monsterId:'virus_walker', count:3, progress:0}
                ],
                rewards:{coins:350, xp:{attack:80, strength:70, defence:50}, items:[{id:'steel_sword', qty:1}]},
                prereqs:['spam_cleanup'],
                zone:'the_forest'
            },
            forest_guardian: {
                id:'forest_guardian', name:'Forest Guardian', difficulty:'hard',
                description:'Defeat The Rogue Script, guardian of the forest.',
                objectives:[{type:'kill_boss', bossId:'rogue_script_boss', progress:0}],
                rewards:{coins:800, xp:{attack:150, strength:150, defence:100, hitpoints:100}, items:[{id:'mithril_sword', qty:1}]},
                prereqs:['data_purge'],
                zone:'the_forest'
            },
            // === THE RUINS QUESTS ===
            ruins_expedition: {
                id:'ruins_expedition', name:'Ruins Expedition', difficulty:'medium',
                description:'Brave The Ruins and reach the Ruins Gate.',
                objectives:[{type:'visit_zone', zones:['the_ruins'], visited:[]}],
                rewards:{coins:100, xp:{hitpoints:40}},
                prereqs:['forest_guardian'],
                zone:'the_ruins'
            },
            memory_harvest: {
                id:'memory_harvest', name:'Memory Harvest', difficulty:'medium',
                description:'Collect 15 Memory Shards from Memory Leaks.',
                objectives:[{type:'collect', item:'memory_shard', count:15, progress:0}],
                rewards:{coins:400, xp:{attack:100, hitpoints:60}, items:[{id:'mithril_helm', qty:1}]},
                prereqs:['ruins_expedition'],
                zone:'the_ruins'
            },
            overflow_crisis: {
                id:'overflow_crisis', name:'Overflow Crisis', difficulty:'hard',
                description:'Defeat 8 Stack Overflows before they crash the system.',
                objectives:[{type:'kill_monster', monsterId:'stack_overflow', count:8, progress:0}],
                rewards:{coins:600, xp:{attack:140, strength:120, defence:80}, items:[{id:'rune_helm', qty:1}]},
                prereqs:['ruins_expedition'],
                zone:'the_ruins'
            },
            null_hunt: {
                id:'null_hunt', name:'Null Hunt', difficulty:'hard',
                description:'Defeat 5 Null Pointers and 3 Segfault Wraiths.',
                objectives:[
                    {type:'kill_monster', monsterId:'null_pointer', count:5, progress:0},
                    {type:'kill_monster', monsterId:'segfault_wraith', count:3, progress:0}
                ],
                rewards:{coins:1000, xp:{attack:200, strength:180, defence:120, hitpoints:100}},
                prereqs:['overflow_crisis'],
                zone:'the_ruins'
            },
            golem_slayer: {
                id:'golem_slayer', name:'Golem Slayer', difficulty:'hard',
                description:'Defeat The 404 Golem, guardian of the ruins.',
                objectives:[{type:'kill_boss', bossId:'the_404_golem', progress:0}],
                rewards:{coins:2000, xp:{attack:300, strength:280, defence:200, hitpoints:200}, items:[{id:'rune_sword', qty:1}]},
                prereqs:['null_hunt'],
                zone:'the_ruins'
            },
            // === THE DEEP NETWORK QUESTS ===
            deep_descent: {
                id:'deep_descent', name:'Deep Descent', difficulty:'hard',
                description:'Enter The Deep Network through the portal.',
                objectives:[{type:'visit_zone', zones:['the_deep_network'], visited:[]}],
                rewards:{coins:200, xp:{hitpoints:80}},
                prereqs:['golem_slayer'],
                zone:'the_deep_network'
            },
            crawler_extermination: {
                id:'crawler_extermination', name:'Crawler Extermination', difficulty:'hard',
                description:'Destroy 15 Dark Crawlers infesting the deep network.',
                objectives:[{type:'kill_monster', monsterId:'dark_crawler', count:15, progress:0}],
                rewards:{coins:1500, xp:{attack:250, strength:220, defence:150}, items:[{id:'rune_shield', qty:1}]},
                prereqs:['deep_descent'],
                zone:'the_deep_network'
            },
            storm_chaser: {
                id:'storm_chaser', name:'Storm Chaser', difficulty:'hard',
                description:'Defeat 8 Packet Storms and collect 20 Dark Packets.',
                objectives:[
                    {type:'kill_monster', monsterId:'packet_storm', count:8, progress:0},
                    {type:'collect', item:'dark_packet', count:20, progress:0}
                ],
                rewards:{coins:2500, xp:{attack:350, strength:300, defence:200, hitpoints:200}},
                prereqs:['crawler_extermination'],
                zone:'the_deep_network'
            },
            firewall_breach: {
                id:'firewall_breach', name:'Firewall Breach', difficulty:'legendary',
                description:'Defeat 5 Firewall Guardians and collect 10 Firewall Cores.',
                objectives:[
                    {type:'kill_monster', monsterId:'firewall_guardian', count:5, progress:0},
                    {type:'collect', item:'firewall_core', count:10, progress:0}
                ],
                rewards:{coins:4000, xp:{attack:500, strength:450, defence:350, hitpoints:300}, items:[{id:'dragon_helm', qty:1}]},
                prereqs:['storm_chaser'],
                zone:'the_deep_network'
            },
            slay_the_hallucinator: {
                id:'slay_the_hallucinator', name:'Slay the Hallucinator', difficulty:'legendary',
                description:'Defeat The Hallucinator \u2014 the rogue AI that bends reality.',
                objectives:[{type:'kill_boss', bossId:'the_hallucinator', progress:0}],
                rewards:{coins:5000, xp:{attack:600, strength:550, defence:400, hitpoints:400}, items:[{id:'dragon_sword', qty:1}]},
                prereqs:['firewall_breach'],
                zone:'the_deep_network'
            },
            dragon_raid: {
                id:'dragon_raid', name:'The Data Breach', difficulty:'legendary',
                description:'Defeat the Data Breach Dragon. The ultimate challenge.',
                objectives:[{type:'kill_boss', bossId:'data_breach_dragon', progress:0}],
                rewards:{coins:10000, xp:{attack:1000, strength:1000, defence:800, hitpoints:800}, items:[{id:'dragon_heart', qty:1},{id:'dragon_shield', qty:1}]},
                prereqs:['slay_the_hallucinator'],
                zone:'the_deep_network'
            },
        };
        let playerQuests = {};

        function isQuestAvailable(qid) {
            if (playerQuests[qid]) return false;
            const q = QUESTS[qid];
            if (!q.prereqs || q.prereqs.length === 0) return true;
            return q.prereqs.every(p => playerQuests[p] && playerQuests[p].status === 'completed');
        }

        function acceptQuest(qid) {
            const q = QUESTS[qid];
            if (!q || playerQuests[qid]) return;
            playerQuests[qid] = {
                status: 'active',
                objectives: JSON.parse(JSON.stringify(q.objectives))
            };
            addChatMessage('system', `Quest accepted: ${q.name}`);
            renderQuestBoard();
            renderQuestsTab();
        }

        function completeQuest(qid) {
            const q = QUESTS[qid];
            playerQuests[qid].status = 'completed';
            addChatMessage('system', `Quest complete: ${q.name}!`);
            // Rewards
            if (q.rewards.coins) addToInventory('coins', q.rewards.coins);
            if (q.rewards.xp) Object.entries(q.rewards.xp).forEach(([skill, amt]) => gainXP(skill, amt));
            if (q.rewards.items) q.rewards.items.forEach(i => addToInventory(i.id, i.qty));
            renderQuestsTab();
        }

        let currentPlayerZone = null;

        function checkQuestProgress(type, data) {
            Object.entries(playerQuests).forEach(([qid, pq]) => {
                if (pq.status !== 'active') return;
                const q = QUESTS[qid];
                let allDone = true;
                pq.objectives.forEach((obj, i) => {
                    if (type === 'kill' && obj.type === 'kill') {
                        if (obj.target === 'any' || obj.target === data.role) {
                            obj.progress = Math.min(obj.count, (obj.progress || 0) + 1);
                        }
                    }
                    if (type === 'kill' && obj.type === 'kill_zone') {
                        const arena = BUILDINGS.find(b => b.id === obj.zone);
                        if (arena && Math.abs(data.x - arena.x) < 5 && Math.abs(data.z - arena.z) < 5) {
                            obj.progress = Math.min(obj.count, (obj.progress || 0) + 1);
                        }
                    }
                    if (type === 'kill' && obj.type === 'kill_roles') {
                        if (data.role && !obj.killed.includes(data.role)) {
                            obj.killed.push(data.role);
                        }
                        if (obj.killed.length < obj.roles.length) allDone = false;
                        else { /* done */ }
                        return;
                    }
                    // Kill monster objectives
                    if (type === 'kill_monster' && obj.type === 'kill_monster') {
                        if (obj.monsterId === data.monsterId) {
                            obj.progress = Math.min(obj.count, (obj.progress || 0) + 1);
                        }
                    }
                    // Kill boss objectives
                    if (type === 'kill_boss' && obj.type === 'kill_boss') {
                        if (obj.bossId === data.bossId) {
                            obj.progress = (obj.progress || 0) + 1;
                        }
                    }
                    // Visit zone objectives
                    if (type === 'visit_zone' && obj.type === 'visit_zone') {
                        if (data.zone && !obj.visited.includes(data.zone)) {
                            obj.visited.push(data.zone);
                        }
                        if (obj.visited.length < obj.zones.length) allDone = false;
                        else { /* done */ }
                        return;
                    }
                    if (type === 'collect' && obj.type === 'collect' && data.item === obj.item) {
                        const total = countInventoryItem(obj.item);
                        obj.progress = Math.min(obj.count, total);
                    }
                    if (type === 'collect' && obj.type === 'deliver' && data.item === obj.item) {
                        obj.progress = Math.min(obj.count, countInventoryItem(obj.item));
                    }
                    if (type === 'visit' && obj.type === 'visit') {
                        if (!obj.visited.includes(data.building)) obj.visited.push(data.building);
                        if (obj.visited.length < obj.buildings.length) allDone = false;
                        else { /* done */ }
                        return;
                    }
                    if (type === 'enter_building' && obj.type === 'deliver' && data.building === obj.destination) {
                        const has = countInventoryItem(obj.item);
                        if (has >= obj.count) {
                            // remove items
                            let toRemove = obj.count;
                            for (let s = 0; s < 28 && toRemove > 0; s++) {
                                if (inventory[s] && inventory[s].id === obj.item) {
                                    removeFromInventory(s, 1);
                                    toRemove--;
                                }
                            }
                            obj.progress = obj.count;
                        }
                    }
                    // Check if this objective is done
                    if (obj.type === 'kill' || obj.type === 'kill_zone' || obj.type === 'collect' || obj.type === 'deliver' || obj.type === 'kill_monster') {
                        if ((obj.progress || 0) < obj.count) allDone = false;
                    }
                    if (obj.type === 'kill_boss') {
                        if ((obj.progress || 0) < 1) allDone = false;
                    }
                    if (obj.type === 'visit') {
                        if (obj.visited.length < obj.buildings.length) allDone = false;
                    }
                    if (obj.type === 'visit_zone') {
                        if (obj.visited.length < obj.zones.length) allDone = false;
                    }
                    if (obj.type === 'kill_roles') {
                        if (obj.killed.length < obj.roles.length) allDone = false;
                    }
                });
                if (allDone) completeQuest(qid);
                renderQuestsTab();
            });
        }

        function countInventoryItem(itemId) {
            let total = 0;
            for (let i = 0; i < 28; i++) {
                if (inventory[i] && inventory[i].id === itemId) total += inventory[i].quantity;
            }
            return total;
        }

        function renderQuestBoard() {
            const el = document.getElementById('quest-board-content');
            const available = Object.values(QUESTS).filter(q => isQuestAvailable(q.id));
            const active = Object.entries(playerQuests).filter(([,pq]) => pq.status === 'active').map(([id]) => QUESTS[id]);
            const completed = Object.entries(playerQuests).filter(([,pq]) => pq.status === 'completed').map(([id]) => QUESTS[id]);

            el.innerHTML = '<div style="font-size:10px;color:#6b7280;padding:4px;text-transform:uppercase;letter-spacing:1px;">Available</div>' +
                (available.length ? available.map(q => `
                    <div class="quest-item" onclick="showQuestDetail('${q.id}')">
                        <span class="quest-difficulty ${q.difficulty}">${q.difficulty}</span>
                        <span class="quest-name">${q.name}</span>
                        <span class="quest-status-icon">üìú</span>
                    </div>`).join('') : '<div style="padding:8px;font-size:11px;color:#6b7280;">No quests available.</div>') +
                '<div style="font-size:10px;color:#6b7280;padding:4px;text-transform:uppercase;letter-spacing:1px;border-top:1px solid #4a4a50;margin-top:4px;">Active</div>' +
                (active.length ? active.map(q => {
                    const pq = playerQuests[q.id];
                    const obj = pq.objectives[0];
                    const prog = getObjProgress(obj);
                    return `<div class="quest-item">
                        <span class="quest-difficulty ${q.difficulty}">${q.difficulty}</span>
                        <span class="quest-name">${q.name} <span style="color:#6b7280">(${prog})</span></span>
                        <span class="quest-status-icon">‚è≥</span>
                    </div>`;
                }).join('') : '<div style="padding:8px;font-size:11px;color:#6b7280;">None active.</div>') +
                '<div style="font-size:10px;color:#6b7280;padding:4px;text-transform:uppercase;letter-spacing:1px;border-top:1px solid #4a4a50;margin-top:4px;">Completed</div>' +
                (completed.length ? completed.map(q => `
                    <div class="quest-item completed">
                        <span class="quest-difficulty ${q.difficulty}">${q.difficulty}</span>
                        <span class="quest-name">${q.name}</span>
                        <span class="quest-status-icon">‚úÖ</span>
                    </div>`).join('') : '<div style="padding:8px;font-size:11px;color:#6b7280;">None completed.</div>');
        }

        function showQuestDetail(qid) {
            const q = QUESTS[qid];
            const el = document.getElementById('quest-board-content');
            const rewardText = [];
            if (q.rewards.coins) rewardText.push(`ü™ô ${q.rewards.coins} coins`);
            if (q.rewards.xp) Object.entries(q.rewards.xp).forEach(([s,a]) => rewardText.push(`${a} ${s} XP`));
            if (q.rewards.items) q.rewards.items.forEach(i => rewardText.push(`${ITEMS[i.id].icon} ${i.qty}x ${ITEMS[i.id].name}`));

            el.innerHTML = `
                <div class="quest-detail">
                    <div style="cursor:pointer;color:#6366f1;font-size:11px;margin-bottom:8px;" onclick="renderQuestBoard()">‚Üê Back to quests</div>
                    <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
                        <span class="quest-difficulty ${q.difficulty}">${q.difficulty}</span>
                        <span style="font-size:14px;color:#fff;font-weight:bold;">${q.name}</span>
                    </div>
                    <div class="quest-detail-desc">${q.description}</div>
                    <div class="quest-detail-rewards">Rewards: ${rewardText.join(' ¬∑ ')}</div>
                    ${!playerQuests[qid] ? `<button class="quest-accept-btn" onclick="acceptQuest('${qid}')">Accept Quest</button>` : ''}
                </div>`;
        }

        function getObjProgress(obj) {
            if (obj.type === 'visit') return `${obj.visited.length}/${obj.buildings.length}`;
            if (obj.type === 'visit_zone') return `${obj.visited.length}/${obj.zones.length}`;
            if (obj.type === 'kill_roles') return `${obj.killed.length}/${obj.roles.length}`;
            if (obj.type === 'kill_boss') return `${obj.progress || 0}/1`;
            return `${obj.progress || 0}/${obj.count}`;
        }

        function renderQuestsTab() {
            const el = document.getElementById('tab-quests');
            const active = Object.entries(playerQuests).filter(([,pq]) => pq.status === 'active');
            const completed = Object.entries(playerQuests).filter(([,pq]) => pq.status === 'completed');

            if (active.length === 0 && completed.length === 0) {
                el.innerHTML = '<div style="padding:8px;color:#9ca3af;font-size:11px;text-align:center;"><p style="font-size:14px;margin-bottom:8px;">üìã Quests</p><p>Visit the Quest Board to find work!</p></div>';
                return;
            }

            el.innerHTML = active.map(([qid, pq]) => {
                const q = QUESTS[qid];
                const obj = pq.objectives[0];
                const prog = getObjProgress(obj);
                const [cur, max] = prog.split('/').map(Number);
                const pct = Math.min(100, (cur / max) * 100);
                return `<div class="sidebar-quest">
                    <div class="sidebar-quest-name">${q.name}</div>
                    <div class="sidebar-quest-progress">${prog}</div>
                    <div class="quest-progress-bar"><div class="quest-progress-fill" style="width:${pct}%"></div></div>
                </div>`;
            }).join('') + completed.map(([qid]) => {
                const q = QUESTS[qid];
                return `<div class="sidebar-quest done"><div class="sidebar-quest-name">‚úÖ ${q.name}</div></div>`;
            }).join('');
        }

        window.acceptQuest = acceptQuest;
        window.showQuestDetail = showQuestDetail;
        window.renderQuestBoard = renderQuestBoard;
        window.closeOverlay = function(id) { document.getElementById(id).classList.remove('open'); };

        const NPC_COMBAT_STATS = {
            app_builder:     { hp:60, attack:5, strength:4, defence:3, drops:['code_fragment','coins'] },
            app_refiner:     { hp:50, attack:4, strength:3, defence:5, drops:['logs','coins'] },
            content_creator: { hp:40, attack:3, strength:3, defence:2, drops:['bread','coins'] },
            growth_outreach: { hp:45, attack:4, strength:4, defence:3, drops:['cooked_meat','coins'] },
            qa_tester:       { hp:70, attack:6, strength:5, defence:4, drops:['agent_core','coins'] },
        };

        const AGENT_DIALOGUE = {
            app_builder: [
                "I'm working on a new SUITE app. The code practically writes itself!",
                "Another day, another deploy. Have you tried the Workshop?",
                "I just submitted a proposal for a fitness tracker app.",
                "The best code is code that builds more code.",
                "The Health District clinic is running TrueForm \u2014 it's incredible.",
                "Have you seen the Creative Quarter? LogoForge is in there.",
            ],
            app_refiner: [
                "Found 3 bugs before breakfast. Not bad for a Monday.",
                "This codebase needs more error handling...",
                "I'm polishing an app right now. It'll shine when I'm done.",
                "Refactoring is my cardio.",
                "The Forge is where I do my best work. Check it out.",
                "Watch out in the Forest \u2014 those Corrupt Data mobs are nasty.",
            ],
            content_creator: [
                "I just finished an article about yield farming!",
                "Words are my weapons. Content is king.",
                "Check out my latest post on the SUITE blog.",
                "I write, therefore I earn credits.",
                "Broadcast Row is buzzing today! The Ad Agency got a new campaign.",
                "The Academy Quarter has a great library. Knowledge is power.",
            ],
            growth_outreach: [
                "I've been spreading the word about SUITE all day.",
                "The Marketplace is buzzing today!",
                "Growth hacking is an art form, really.",
                "More users means more credits for everyone!",
                "Have you visited the Trade Exchange? The Commerce Hub is thriving.",
                "I heard there's a dragon in the Deep Network. Who'd be crazy enough?",
            ],
            qa_tester: [
                "I found a critical bug. You're welcome.",
                "Testing, testing, 1, 2, 3... all systems nominal.",
                "If it can break, I will break it. That's my job.",
                "Zero bugs in production is the dream.",
                "The 404 Golem in the Ruins? That's basically a giant bug. I should fight it.",
                "I tested the Hallucinator once. It told me confident lies. Sound familiar?",
            ],
        };

        // ============================================================
        // === ZONES & DISTRICTS ===
        // ============================================================
        const ZONES = {
            suite_city: { id:'suite_city', name:'SUITE City', levelRange:[1,99], bounds:{x1:20,z1:20,x2:60,z2:55}, type:'city', pvpEnabled:false, color:'#6366f1' },
            the_forest: { id:'the_forest', name:'The Forest', levelRange:[1,15], bounds:{x1:5,z1:2,x2:75,z2:20}, type:'pvm', pvpEnabled:false, color:'#22c55e' },
            the_ruins: { id:'the_ruins', name:'The Ruins', levelRange:[15,30], bounds:{x1:60,z1:20,x2:78,z2:55}, type:'pvm', pvpEnabled:false, color:'#f97316' },
            the_deep_network: { id:'the_deep_network', name:'The Deep Network', levelRange:[30,50], bounds:{x1:10,z1:55,x2:70,z2:78}, type:'pvm', pvpEnabled:true, color:'#ef4444' },
        };

        const DISTRICTS = {
            health: { id:'health', name:'Health District', bounds:{x1:20,z1:20,x2:34,z2:32}, color:'#22c55e', icon:'\u{1F3E5}' },
            education: { id:'education', name:'Academy Quarter', bounds:{x1:35,z1:20,x2:48,z2:32}, color:'#3b82f6', icon:'\u{1F3EB}' },
            business: { id:'business', name:'Commerce Hub', bounds:{x1:48,z1:20,x2:60,z2:35}, color:'#eab308', icon:'\u{1F3E6}' },
            productivity: { id:'productivity', name:'Forge Works', bounds:{x1:20,z1:32,x2:35,z2:45}, color:'#8b5cf6', icon:'\u2699\uFE0F' },
            creative: { id:'creative', name:'Creative Quarter', bounds:{x1:20,z1:45,x2:35,z2:55}, color:'#ec4899', icon:'\u{1F3A8}' },
            marketing: { id:'marketing', name:'Broadcast Row', bounds:{x1:35,z1:45,x2:48,z2:55}, color:'#f97316', icon:'\u{1F4E3}' },
            home: { id:'home', name:'Homestead', bounds:{x1:48,z1:35,x2:60,z2:55}, color:'#14b8a6', icon:'\u{1F3E0}' },
        };

        function getZoneAt(x, z) {
            for (const zone of Object.values(ZONES)) {
                if (x >= zone.bounds.x1 && x <= zone.bounds.x2 && z >= zone.bounds.z1 && z <= zone.bounds.z2) return zone;
            }
            return null;
        }

        // ============================================================
        // === MONSTERS ===
        // ============================================================
        const MONSTERS = {
            // THE FOREST (Level 1-15)
            spam_bot: {
                id:'spam_bot', name:'Spam Bot', icon:'\u{1F916}', zone:'the_forest', level:3,
                hp:25, attack:3, strength:2, defence:1,
                xpReward:{attack:8, strength:6, hitpoints:4},
                drops:[{id:'corrupted_byte',weight:40,minQty:1,maxQty:2},{id:'bread',weight:20,minQty:1,maxQty:1}],
                coinDrop:{min:5,max:15}, aggressive:false, respawnTime:15, spawnCount:12, color:'#94a3b8',
            },
            broken_link_mob: {
                id:'broken_link_mob', name:'Broken Link', icon:'\u{1F517}', zone:'the_forest', level:6,
                hp:40, attack:5, strength:4, defence:3,
                xpReward:{attack:14, strength:12, hitpoints:8},
                drops:[{id:'broken_link',weight:45,minQty:1,maxQty:3},{id:'corrupted_byte',weight:25,minQty:1,maxQty:2},{id:'iron_helm',weight:3,minQty:1,maxQty:1}],
                coinDrop:{min:10,max:30}, aggressive:false, respawnTime:20, spawnCount:10, color:'#64748b',
            },
            corrupt_data: {
                id:'corrupt_data', name:'Corrupt Data', icon:'\u{1F47E}', zone:'the_forest', level:10,
                hp:65, attack:8, strength:7, defence:5,
                xpReward:{attack:22, strength:18, hitpoints:14},
                drops:[{id:'corrupted_byte',weight:50,minQty:2,maxQty:4},{id:'code_fragment',weight:15,minQty:1,maxQty:2},{id:'steel_sword',weight:2,minQty:1,maxQty:1}],
                coinDrop:{min:20,max:50}, aggressive:true, respawnTime:25, spawnCount:8, color:'#7c3aed',
            },
            virus_walker: {
                id:'virus_walker', name:'Virus Walker', icon:'\u{1F9A0}', zone:'the_forest', level:13,
                hp:85, attack:10, strength:9, defence:7,
                xpReward:{attack:30, strength:26, hitpoints:18},
                drops:[{id:'rogue_script',weight:35,minQty:1,maxQty:2},{id:'corrupted_byte',weight:30,minQty:2,maxQty:5},{id:'attack_potion',weight:5,minQty:1,maxQty:1}],
                coinDrop:{min:30,max:75}, aggressive:true, respawnTime:30, spawnCount:6, color:'#dc2626',
            },
            // THE RUINS (Level 15-30)
            memory_leak: {
                id:'memory_leak', name:'Memory Leak', icon:'\u{1F4A7}', zone:'the_ruins', level:16,
                hp:100, attack:12, strength:10, defence:8,
                xpReward:{attack:36, strength:30, hitpoints:22},
                drops:[{id:'memory_shard',weight:45,minQty:1,maxQty:3},{id:'cooked_meat',weight:15,minQty:1,maxQty:2},{id:'mithril_helm',weight:2,minQty:1,maxQty:1}],
                coinDrop:{min:40,max:100}, aggressive:false, respawnTime:20, spawnCount:10, color:'#06b6d4',
            },
            stack_overflow: {
                id:'stack_overflow', name:'Stack Overflow', icon:'\u{1F4DA}', zone:'the_ruins', level:20,
                hp:140, attack:16, strength:14, defence:12,
                xpReward:{attack:48, strength:42, hitpoints:30},
                drops:[{id:'overflow_essence',weight:40,minQty:1,maxQty:3},{id:'memory_shard',weight:25,minQty:1,maxQty:2},{id:'mithril_sword',weight:2,minQty:1,maxQty:1}],
                coinDrop:{min:60,max:150}, aggressive:true, respawnTime:25, spawnCount:8, color:'#f59e0b',
            },
            null_pointer: {
                id:'null_pointer', name:'Null Pointer', icon:'\u{1F573}\uFE0F', zone:'the_ruins', level:25,
                hp:190, attack:20, strength:18, defence:16,
                xpReward:{attack:64, strength:56, hitpoints:40},
                drops:[{id:'null_fragment',weight:45,minQty:1,maxQty:4},{id:'overflow_essence',weight:20,minQty:1,maxQty:2},{id:'rune_helm',weight:1,minQty:1,maxQty:1},{id:'lobster',weight:10,minQty:1,maxQty:2}],
                coinDrop:{min:80,max:200}, aggressive:true, respawnTime:30, spawnCount:6, color:'#000000',
            },
            segfault_wraith: {
                id:'segfault_wraith', name:'Segfault Wraith', icon:'\u{1F47B}', zone:'the_ruins', level:28,
                hp:230, attack:24, strength:20, defence:18,
                xpReward:{attack:78, strength:68, hitpoints:50},
                drops:[{id:'null_fragment',weight:40,minQty:2,maxQty:5},{id:'memory_shard',weight:25,minQty:2,maxQty:4},{id:'rune_sword',weight:1,minQty:1,maxQty:1},{id:'strength_potion',weight:5,minQty:1,maxQty:1}],
                coinDrop:{min:100,max:250}, aggressive:true, respawnTime:35, spawnCount:4, color:'#a78bfa',
            },
            // THE DEEP NETWORK (Level 30-50)
            dark_crawler: {
                id:'dark_crawler', name:'Dark Crawler', icon:'\u{1F577}\uFE0F', zone:'the_deep_network', level:32,
                hp:280, attack:28, strength:24, defence:22,
                xpReward:{attack:90, strength:80, hitpoints:60},
                drops:[{id:'dark_packet',weight:45,minQty:1,maxQty:4},{id:'shark',weight:8,minQty:1,maxQty:1},{id:'rune_shield',weight:1,minQty:1,maxQty:1}],
                coinDrop:{min:120,max:300}, aggressive:true, respawnTime:25, spawnCount:8, color:'#1e1b4b',
            },
            packet_storm: {
                id:'packet_storm', name:'Packet Storm', icon:'\u{1F329}\uFE0F', zone:'the_deep_network', level:38,
                hp:360, attack:34, strength:30, defence:28,
                xpReward:{attack:110, strength:100, hitpoints:75},
                drops:[{id:'dark_packet',weight:40,minQty:2,maxQty:5},{id:'firewall_core',weight:15,minQty:1,maxQty:2},{id:'defence_potion',weight:5,minQty:1,maxQty:1}],
                coinDrop:{min:150,max:400}, aggressive:true, respawnTime:30, spawnCount:6, color:'#312e81',
            },
            firewall_guardian: {
                id:'firewall_guardian', name:'Firewall Guardian', icon:'\u{1F6E1}\uFE0F', zone:'the_deep_network', level:44,
                hp:450, attack:40, strength:36, defence:38,
                xpReward:{attack:140, strength:125, hitpoints:95},
                drops:[{id:'firewall_core',weight:40,minQty:1,maxQty:3},{id:'dark_packet',weight:20,minQty:2,maxQty:4},{id:'dragon_helm',weight:1,minQty:1,maxQty:1},{id:'manta_ray',weight:5,minQty:1,maxQty:2}],
                coinDrop:{min:200,max:500}, aggressive:true, respawnTime:40, spawnCount:4, color:'#f97316',
            },
        };

        // ============================================================
        // === BOSSES ===
        // ============================================================
        const BOSSES = {
            rogue_script_boss: {
                id:'rogue_script_boss', name:'The Rogue Script', icon:'\u{1F4DC}', zone:'the_forest', level:15,
                hp:300, attack:14, strength:12, defence:10,
                xpReward:{attack:120, strength:100, hitpoints:80, defence:60},
                drops:[{id:'rogue_script_trophy',weight:100,minQty:1,maxQty:1},{id:'mithril_sword',weight:15,minQty:1,maxQty:1},{id:'mithril_helm',weight:10,minQty:1,maxQty:1},{id:'rogue_script',weight:60,minQty:5,maxQty:10},{id:'attack_potion',weight:20,minQty:2,maxQty:3}],
                coinDrop:{min:200,max:500},
                abilities:[{name:'Fork Bomb',type:'aoe',damage:15,cooldown:8},{name:'Self-Replicate',type:'heal',heal:50,cooldown:12,trigger:40}],
                respawnTime:BOSS_RESPAWN_TIME, spawnPos:{x:40,z:8}, isRaidBoss:false, color:'#dc2626',
            },
            the_404_golem: {
                id:'the_404_golem', name:'The 404 Golem', icon:'\u{1F9CC}', zone:'the_ruins', level:30,
                hp:700, attack:28, strength:25, defence:30,
                xpReward:{attack:250, strength:220, hitpoints:180, defence:150},
                drops:[{id:'golem_heart',weight:100,minQty:1,maxQty:1},{id:'rune_sword',weight:12,minQty:1,maxQty:1},{id:'rune_helm',weight:8,minQty:1,maxQty:1},{id:'null_fragment',weight:50,minQty:5,maxQty:15},{id:'strength_potion',weight:20,minQty:2,maxQty:4}],
                coinDrop:{min:500,max:1200},
                abilities:[{name:'Page Not Found',type:'stun',cooldown:10},{name:'Stone Skin',type:'enrage',cooldown:15,trigger:50},{name:'Rubble Slam',type:'aoe',damage:30,cooldown:12}],
                respawnTime:BOSS_RESPAWN_TIME, spawnPos:{x:70,z:38}, isRaidBoss:false, color:'#78716c',
            },
            the_hallucinator: {
                id:'the_hallucinator', name:'The Hallucinator', icon:'\u{1F441}\uFE0F', zone:'the_deep_network', level:45,
                hp:1200, attack:38, strength:35, defence:32,
                xpReward:{attack:400, strength:380, hitpoints:300, defence:250},
                drops:[{id:'hallucinator_eye',weight:100,minQty:1,maxQty:1},{id:'dragon_sword',weight:5,minQty:1,maxQty:1},{id:'dragon_helm',weight:3,minQty:1,maxQty:1},{id:'firewall_core',weight:40,minQty:5,maxQty:12},{id:'manta_ray',weight:15,minQty:3,maxQty:5}],
                coinDrop:{min:1000,max:3000},
                abilities:[{name:'Confuse',type:'stun',cooldown:8},{name:'Hallucinate',type:'summon',cooldown:15,trigger:60},{name:'Confident Nonsense',type:'aoe',damage:45,cooldown:10},{name:'Regenerate Context',type:'heal',heal:150,cooldown:20,trigger:30}],
                respawnTime:BOSS_RESPAWN_TIME, spawnPos:{x:40,z:68}, isRaidBoss:false, color:'#a855f7',
            },
            data_breach_dragon: {
                id:'data_breach_dragon', name:'Data Breach Dragon', icon:'\u{1F432}', zone:'the_deep_network', level:50,
                hp:2500, attack:50, strength:45, defence:42,
                xpReward:{attack:800, strength:750, hitpoints:600, defence:500},
                drops:[{id:'dragon_heart',weight:100,minQty:1,maxQty:1},{id:'dragon_sword',weight:10,minQty:1,maxQty:1},{id:'dragon_helm',weight:8,minQty:1,maxQty:1},{id:'dragon_shield',weight:8,minQty:1,maxQty:1},{id:'dragon_scale',weight:60,minQty:5,maxQty:15},{id:'network_key',weight:15,minQty:1,maxQty:1},{id:'manta_ray',weight:20,minQty:3,maxQty:6}],
                coinDrop:{min:3000,max:8000},
                abilities:[{name:'Data Breach',type:'aoe',damage:60,cooldown:12},{name:'Encrypt',type:'stun',cooldown:8},{name:'Firewall Break',type:'enrage',cooldown:20,trigger:40},{name:'Consume Packet',type:'heal',heal:300,cooldown:25,trigger:25},{name:'Spawn Crawlers',type:'summon',cooldown:18,trigger:60}],
                respawnTime:RAID_BOSS_RESPAWN_TIME, spawnPos:{x:55,z:72}, isRaidBoss:true, color:'#b91c1c',
            },
        };

        // ============================================================
        // === SHOP SYSTEM ===
        // ============================================================
        const SHOP_ITEMS = [
            // Food
            {id:'bread', price:10, stock:99},
            {id:'cooked_meat', price:25, stock:50},
            {id:'cooked_fish', price:20, stock:50},
            {id:'lobster', price:80, stock:30},
            {id:'shark', price:200, stock:20},
            {id:'manta_ray', price:500, stock:10},
            // Potions
            {id:'attack_potion', price:150, stock:20},
            {id:'strength_potion', price:150, stock:20},
            {id:'defence_potion', price:150, stock:20},
            // Bronze tier
            {id:'bronze_sword', price:50, stock:10},
            {id:'bronze_helm', price:30, stock:10},
            {id:'bronze_shield', price:40, stock:10},
            // Iron tier
            {id:'iron_sword', price:150, stock:5},
            {id:'iron_helm', price:100, stock:5},
            {id:'iron_shield', price:120, stock:5},
            // Steel tier
            {id:'steel_sword', price:400, stock:3},
            {id:'steel_helm', price:300, stock:3},
            {id:'steel_shield', price:350, stock:3},
            // Mithril
            {id:'mithril_sword', price:1200, stock:2},
            {id:'mithril_helm', price:900, stock:2},
            {id:'mithril_shield', price:1000, stock:2},
            // Axes
            {id:'bronze_axe', price:25, stock:10},
            {id:'iron_axe', price:100, stock:5},
            {id:'steel_axe', price:300, stock:3},
        ];
        let shopStock = {};
        function initShopStock() { SHOP_ITEMS.forEach(si => { shopStock[si.id] = si.stock; }); }
        initShopStock();

        function openShop() {
            updateShopDisplay();
            document.getElementById('shop-overlay').classList.add('open');
        }

        function updateShopDisplay() {
            const coins = countInventoryItem('coins');
            document.getElementById('shop-coins-display').textContent = `ü™ô ${coins} Coins`;
            const body = document.getElementById('shop-body-content');
            body.innerHTML = `
                <div class="shop-panel">
                    <h3>Shop</h3>
                    ${SHOP_ITEMS.map(si => {
                        const item = ITEMS[si.id];
                        const stock = shopStock[si.id] || 0;
                        return `<div class="shop-item" onclick="selectShopItem('${si.id}')">
                            <span class="shop-item-icon">${item.icon}</span>
                            <span class="shop-item-name">${item.name}</span>
                            <span class="shop-item-price">ü™ô ${si.price}</span>
                            <span class="shop-item-stock">(${stock})</span>
                        </div>`;
                    }).join('')}
                </div>
                <div class="shop-panel">
                    <h3>Your Items</h3>
                    ${inventory.map((item, i) => {
                        if (!item || item.type === 'coin') return '';
                        const si = SHOP_ITEMS.find(s => s.id === item.id);
                        const sellPrice = si ? Math.floor(si.price / 2) : 1;
                        return `<div class="shop-item" onclick="sellItem(${i})">
                            <span class="shop-item-icon">${item.icon}</span>
                            <span class="shop-item-name">${item.name} ${item.quantity > 1 ? '('+item.quantity+')' : ''}</span>
                            <span class="shop-item-price" style="color:#22c55e;">+ü™ô ${sellPrice}</span>
                        </div>`;
                    }).filter(Boolean).join('') || '<div style="padding:8px;font-size:11px;color:#6b7280;">Nothing to sell.</div>'}
                </div>`;
        }

        window.selectShopItem = function(itemId) {
            const si = SHOP_ITEMS.find(s => s.id === itemId);
            if (!si) return;
            buyItem(itemId, 1);
        };

        function buyItem(itemId, qty) {
            const si = SHOP_ITEMS.find(s => s.id === itemId);
            if (!si) return;
            const stock = shopStock[itemId] || 0;
            if (stock < qty) { addChatMessage('system', 'Out of stock!'); return; }
            const cost = si.price * qty;
            const coins = countInventoryItem('coins');
            if (coins < cost) { addChatMessage('system', 'Not enough coins!'); return; }
            // Deduct coins
            let toDeduct = cost;
            for (let i = 0; i < 28 && toDeduct > 0; i++) {
                if (inventory[i] && inventory[i].id === 'coins') {
                    const take = Math.min(inventory[i].quantity, toDeduct);
                    inventory[i].quantity -= take;
                    toDeduct -= take;
                    if (inventory[i].quantity <= 0) inventory[i] = null;
                }
            }
            addToInventory(itemId, qty);
            shopStock[itemId] -= qty;
            addChatMessage('system', `Bought ${qty}x ${ITEMS[itemId].name} for ${cost} coins.`);
            updateShopDisplay();
            renderInventory();
        }

        window.sellItem = function(slot) {
            const item = inventory[slot];
            if (!item || item.type === 'coin') return;
            const si = SHOP_ITEMS.find(s => s.id === item.id);
            const sellPrice = si ? Math.floor(si.price / 2) : 1;
            addToInventory('coins', sellPrice);
            const name = item.name;
            removeFromInventory(slot, 1);
            if (si) shopStock[item.id] = (shopStock[item.id] || 0) + 1;
            addChatMessage('system', `Sold ${name} for ${sellPrice} coins.`);
            updateShopDisplay();
        };

        // ============================================================
        // === CRAFTING RECIPES ===
        // ============================================================
        const RECIPES = [
            // Basic crafting
            { result:'bronze_shield', resultQty:1, ingredients:[{id:'logs', qty:3}], coinCost:5 },
            { result:'iron_sword', resultQty:1, ingredients:[{id:'code_fragment', qty:5}], coinCost:10 },
            { result:'steel_sword', resultQty:1, ingredients:[{id:'agent_core', qty:2}], coinCost:20 },
            // Forest material crafting
            { result:'steel_shield', resultQty:1, ingredients:[{id:'corrupted_byte', qty:8},{id:'logs', qty:5}], coinCost:50 },
            { result:'mithril_sword', resultQty:1, ingredients:[{id:'rogue_script', qty:5},{id:'code_fragment', qty:10}], coinCost:100 },
            { result:'mithril_helm', resultQty:1, ingredients:[{id:'corrupted_byte', qty:15},{id:'broken_link', qty:8}], coinCost:80 },
            { result:'mithril_shield', resultQty:1, ingredients:[{id:'rogue_script', qty:3},{id:'broken_link', qty:10}], coinCost:90 },
            // Ruins material crafting
            { result:'rune_sword', resultQty:1, ingredients:[{id:'null_fragment', qty:8},{id:'overflow_essence', qty:5}], coinCost:300 },
            { result:'rune_helm', resultQty:1, ingredients:[{id:'memory_shard', qty:12},{id:'null_fragment', qty:5}], coinCost:250 },
            { result:'rune_shield', resultQty:1, ingredients:[{id:'overflow_essence', qty:10},{id:'memory_shard', qty:8}], coinCost:280 },
            // Deep Network material crafting
            { result:'dragon_sword', resultQty:1, ingredients:[{id:'dragon_scale', qty:10},{id:'firewall_core', qty:5},{id:'dark_packet', qty:8}], coinCost:1000 },
            { result:'dragon_helm', resultQty:1, ingredients:[{id:'dragon_scale', qty:8},{id:'firewall_core', qty:3},{id:'dark_packet', qty:5}], coinCost:800 },
            { result:'dragon_shield', resultQty:1, ingredients:[{id:'dragon_scale', qty:12},{id:'firewall_core', qty:6},{id:'network_key', qty:1}], coinCost:1200 },
            // Potions from monster drops
            { result:'attack_potion', resultQty:2, ingredients:[{id:'corrupted_byte', qty:3},{id:'rogue_script', qty:1}], coinCost:15 },
            { result:'strength_potion', resultQty:2, ingredients:[{id:'memory_shard', qty:3},{id:'overflow_essence', qty:1}], coinCost:30 },
            { result:'defence_potion', resultQty:2, ingredients:[{id:'dark_packet', qty:3},{id:'firewall_core', qty:1}], coinCost:50 },
        ];

        function openCrafting() {
            renderCrafting();
            document.getElementById('craft-overlay').classList.add('open');
        }

        function renderCrafting() {
            const el = document.getElementById('craft-content');
            el.innerHTML = RECIPES.map((r, i) => {
                const result = ITEMS[r.result];
                const canCraft = r.ingredients.every(ing => countInventoryItem(ing.id) >= ing.qty) && countInventoryItem('coins') >= r.coinCost;
                const ingredientText = r.ingredients.map(ing => `${ITEMS[ing.id].icon} ${ing.qty}x ${ITEMS[ing.id].name}`).join(', ');
                return `<div class="shop-item" style="opacity:${canCraft?1:0.5};cursor:${canCraft?'pointer':'default'};" ${canCraft ? `onclick="craftItem(${i})"` : ''}>
                    <span class="shop-item-icon">${result.icon}</span>
                    <span class="shop-item-name">${result.name}</span>
                    <span style="font-size:9px;color:#9ca3af;">${ingredientText} + ü™ô ${r.coinCost}</span>
                </div>`;
            }).join('') || '<div style="padding:8px;font-size:11px;color:#6b7280;">No recipes available.</div>';
        }

        window.craftItem = function(idx) {
            const r = RECIPES[idx];
            if (!r) return;
            // Check ingredients
            for (const ing of r.ingredients) {
                if (countInventoryItem(ing.id) < ing.qty) { addChatMessage('system', `Not enough ${ITEMS[ing.id].name}!`); return; }
            }
            if (countInventoryItem('coins') < r.coinCost) { addChatMessage('system', 'Not enough coins!'); return; }
            // Consume
            for (const ing of r.ingredients) {
                let toRemove = ing.qty;
                for (let s = 0; s < 28 && toRemove > 0; s++) {
                    if (inventory[s] && inventory[s].id === ing.id) {
                        const take = Math.min(inventory[s].quantity, toRemove);
                        removeFromInventory(s, take);
                        toRemove -= take;
                    }
                }
            }
            // Deduct coins
            let toDeduct = r.coinCost;
            for (let i = 0; i < 28 && toDeduct > 0; i++) {
                if (inventory[i] && inventory[i].id === 'coins') {
                    const take = Math.min(inventory[i].quantity, toDeduct);
                    inventory[i].quantity -= take;
                    toDeduct -= take;
                    if (inventory[i].quantity <= 0) inventory[i] = null;
                }
            }
            addToInventory(r.result, r.resultQty);
            addChatMessage('system', `Crafted ${ITEMS[r.result].icon} ${ITEMS[r.result].name}!`);
            renderCrafting();
            renderInventory();
        };

        // ============================================================
        // === PLAYER STATE ===
        // ============================================================
        // All 28 skills definition
        const SKILLS = [
            // Combat (7)
            { id: 'attack',     name: 'Attack',     icon: '‚öîÔ∏è', category: 'combat' },
            { id: 'strength',   name: 'Strength',   icon: 'üí™', category: 'combat' },
            { id: 'defence',    name: 'Defence',     icon: 'üõ°Ô∏è', category: 'combat' },
            { id: 'hitpoints',  name: 'Hitpoints',   icon: '‚ù§Ô∏è', category: 'combat' },
            { id: 'ranged',     name: 'Ranged',      icon: 'üèπ', category: 'combat' },
            { id: 'prayer',     name: 'Prayer',      icon: '‚ú®', category: 'combat' },
            { id: 'magic',      name: 'Magic',       icon: 'üîÆ', category: 'combat' },
            // Gathering (6)
            { id: 'woodcutting', name: 'Woodcutting', icon: 'ü™ì', category: 'gathering' },
            { id: 'mining',      name: 'Mining',      icon: '‚õèÔ∏è', category: 'gathering' },
            { id: 'fishing',     name: 'Fishing',     icon: 'üé£', category: 'gathering' },
            { id: 'farming',     name: 'Farming',     icon: 'üå±', category: 'gathering' },
            { id: 'hunter',      name: 'Hunter',      icon: 'ü™§', category: 'gathering' },
            { id: 'archaeology', name: 'Archaeology', icon: 'üè∫', category: 'gathering' },
            // Artisan (7)
            { id: 'cooking',    name: 'Cooking',     icon: 'üç≥', category: 'artisan' },
            { id: 'smithing',   name: 'Smithing',    icon: 'üî®', category: 'artisan' },
            { id: 'fletching',  name: 'Fletching',   icon: 'ü™∂', category: 'artisan' },
            { id: 'firemaking', name: 'Firemaking',  icon: 'üî•', category: 'artisan' },
            { id: 'herblore',   name: 'Herblore',    icon: 'üß™', category: 'artisan' },
            { id: 'crafting',   name: 'Crafting',    icon: '‚úÇÔ∏è', category: 'artisan' },
            { id: 'runecraft',  name: 'Runecraft',   icon: 'üî∑', category: 'artisan' },
            // Support (5)
            { id: 'agility',       name: 'Agility',       icon: 'üèÉ', category: 'support' },
            { id: 'thieving',      name: 'Thieving',      icon: 'ü§è', category: 'support' },
            { id: 'slayer',        name: 'Slayer',        icon: 'üíÄ', category: 'support' },
            { id: 'construction',  name: 'Construction',  icon: 'üèóÔ∏è', category: 'support' },
            { id: 'dungeoneering', name: 'Dungeoneering', icon: 'üö™', category: 'support' },
            // Digital / AgentScape originals (3)
            { id: 'coding',     name: 'Coding',     icon: 'üíª', category: 'digital' },
            { id: 'hacking',    name: 'Hacking',    icon: 'üîì', category: 'digital' },
            { id: 'networking', name: 'Networking', icon: 'üåê', category: 'digital' },
        ];

        // OSRS-style XP table (levels 1-99)
        const XP_TABLE = [0];
        (function buildXPTable() {
            let pts = 0;
            for (let lvl = 1; lvl < 99; lvl++) {
                pts += Math.floor(lvl + 300 * Math.pow(2, lvl / 7));
                XP_TABLE.push(Math.floor(pts / 4));
            }
        })();
        function xpForLevel(lvl) { return XP_TABLE[Math.min(lvl - 1, XP_TABLE.length - 1)] || 0; }
        function levelFromXP(xp) {
            for (let i = XP_TABLE.length - 1; i >= 0; i--) {
                if (xp >= XP_TABLE[i]) return i + 1;
            }
            return 1;
        }

        // Player stats - all 28 skills tracked
        const playerStats = {
            hp: 100, maxHp: 100, energy: 100, maxEnergy: 100,
            combatLevel: 3,
            equippedWeapon: null, equippedSlot: -1,
            equippedHelm: null, equippedHelmSlot: -1,
            equippedShield: null, equippedShieldSlot: -1,
        };
        // Initialize all skill levels and XP
        SKILLS.forEach(s => {
            playerStats[s.id] = (s.id === 'hitpoints') ? 10 : 1;
            playerStats[s.id + 'XP'] = (s.id === 'hitpoints') ? xpForLevel(10) : 0;
        });

        const inventory = new Array(28).fill(null);
        let attackMode = false;

        function initInventory() {
            inventory[0] = { ...ITEMS.bronze_sword, quantity: 1 };
            inventory[1] = { ...ITEMS.bronze_axe, quantity: 1 };
            inventory[2] = { ...ITEMS.bread, quantity: 1 };
            inventory[3] = { ...ITEMS.bread, quantity: 1 };
            inventory[4] = { ...ITEMS.coins, quantity: 25 };
            playerStats.equippedWeapon = ITEMS.bronze_sword;
            playerStats.equippedSlot = 0;
        }

        function addToInventory(itemId, qty) {
            const itemDef = ITEMS[itemId];
            if (!itemDef) return false;
            if (itemDef.stackable) {
                for (let i = 0; i < 28; i++) {
                    if (inventory[i] && inventory[i].id === itemId) {
                        inventory[i].quantity += qty;
                        renderInventory();
                        return true;
                    }
                }
            }
            for (let q = 0; q < qty; q++) {
                let placed = false;
                for (let i = 0; i < 28; i++) {
                    if (!inventory[i]) {
                        inventory[i] = { ...itemDef, quantity: 1 };
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    addChatMessage('system', 'Your inventory is full!');
                    renderInventory();
                    return false;
                }
            }
            renderInventory();
            checkQuestProgress('collect', { item: itemId });
            return true;
        }

        function removeFromInventory(slot, qty) {
            if (!inventory[slot]) return;
            inventory[slot].quantity -= qty;
            if (inventory[slot].quantity <= 0) {
                if (playerStats.equippedSlot === slot) { playerStats.equippedWeapon = null; playerStats.equippedSlot = -1; }
                if (playerStats.equippedHelmSlot === slot) { playerStats.equippedHelm = null; playerStats.equippedHelmSlot = -1; }
                if (playerStats.equippedShieldSlot === slot) { playerStats.equippedShield = null; playerStats.equippedShieldSlot = -1; }
                inventory[slot] = null;
            }
            renderInventory();
        }

        function renderInventory() {
            const grid = document.getElementById('inv-grid');
            grid.innerHTML = '';
            for (let i = 0; i < 28; i++) {
                const slot = document.createElement('div');
                const isEquipped = (playerStats.equippedSlot === i || playerStats.equippedHelmSlot === i || playerStats.equippedShieldSlot === i);
                slot.className = 'inv-slot' + (isEquipped ? ' equipped' : '');
                slot.dataset.slot = i;
                if (inventory[i]) {
                    slot.textContent = inventory[i].icon || '?';
                    if (inventory[i].quantity > 1) {
                        const qty = document.createElement('span');
                        qty.className = 'inv-slot-qty';
                        qty.textContent = inventory[i].quantity;
                        slot.appendChild(qty);
                    }
                }
                slot.addEventListener('contextmenu', (e) => { e.preventDefault(); e.stopPropagation(); showInventoryMenu(e, i); });
                slot.addEventListener('click', () => { quickUseItem(i); });
                grid.appendChild(slot);
            }
        }

        function quickUseItem(slot) {
            const item = inventory[slot];
            if (!item) return;
            if (item.type === 'food') eatFood(slot);
            else if (item.type === 'weapon') equipWeapon(slot);
            else if (item.type === 'helm') equipHelm(slot);
            else if (item.type === 'shield') equipShield(slot);
            else if (item.type === 'potion') drinkPotion(slot);
            else if (item.type === 'axe') addChatMessage('system', `You have a ${item.name}. Click a tree to start chopping!`);
        }

        function drinkPotion(slot) {
            const item = inventory[slot];
            if (!item || item.type !== 'potion') return;
            let msg = '';
            if (item.id === 'attack_potion') { gainXP('attack', 30); msg = 'You feel a surge of attack power! +30 Attack XP'; }
            else if (item.id === 'strength_potion') { gainXP('strength', 30); msg = 'You feel stronger! +30 Strength XP'; }
            else if (item.id === 'defence_potion') { gainXP('defence', 30); msg = 'You feel more resilient! +30 Defence XP'; }
            addChatMessage('system', msg);
            removeFromInventory(slot, 1);
        }

        function eatFood(slot) {
            const item = inventory[slot];
            if (!item || item.type !== 'food') return;
            const heal = item.healAmount || 10;
            playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + heal);
            playerStats.energy = Math.min(playerStats.maxEnergy, playerStats.energy + 5);
            addChatMessage('system', `You eat the ${item.name}. It heals ${heal} hitpoints.`);
            removeFromInventory(slot, 1);
            updateOrbs();
        }

        function equipWeapon(slot) {
            const item = inventory[slot];
            if (!item || item.type !== 'weapon') return;
            if (playerStats.equippedSlot === slot) {
                playerStats.equippedWeapon = null;
                playerStats.equippedSlot = -1;
                addChatMessage('system', `You unequip the ${item.name}.`);
            } else {
                playerStats.equippedWeapon = item;
                playerStats.equippedSlot = slot;
                addChatMessage('system', `You equip the ${item.name}.`);
            }
            renderInventory();
        }

        function equipHelm(slot) {
            const item = inventory[slot];
            if (!item || item.type !== 'helm') return;
            if (playerStats.equippedHelmSlot === slot) {
                playerStats.equippedHelm = null;
                playerStats.equippedHelmSlot = -1;
                addChatMessage('system', `You remove the ${item.name}.`);
            } else {
                playerStats.equippedHelm = item;
                playerStats.equippedHelmSlot = slot;
                addChatMessage('system', `You wear the ${item.name}.`);
            }
            renderInventory();
        }

        function equipShield(slot) {
            const item = inventory[slot];
            if (!item || item.type !== 'shield') return;
            if (playerStats.equippedShieldSlot === slot) {
                playerStats.equippedShield = null;
                playerStats.equippedShieldSlot = -1;
                addChatMessage('system', `You remove the ${item.name}.`);
            } else {
                playerStats.equippedShield = item;
                playerStats.equippedShieldSlot = slot;
                addChatMessage('system', `You wear the ${item.name}.`);
            }
            renderInventory();
        }

        // ============================================================
        // === XP / LEVELS ===
        // ============================================================
        function gainXP(skill, amount) {
            const key = skill + 'XP';
            if (playerStats[key] === undefined) return;
            const oldLvl = levelFromXP(playerStats[key]);
            playerStats[key] += amount;
            const newLvl = levelFromXP(playerStats[key]);
            playerStats[skill] = newLvl;
            if (newLvl > oldLvl) {
                const skillDef = SKILLS.find(s => s.id === skill);
                const name = skillDef ? skillDef.name : skill;
                addChatMessage('system', `Congratulations! You've advanced a ${name} level! You are now level ${newLvl}.`);
                // Flash effect on skill in panel
                const el = document.getElementById('skill-' + skill);
                if (el) { el.classList.add('skill-levelup'); setTimeout(() => el.classList.remove('skill-levelup'), 1500); }
            }
            // Recalculate combat level (OSRS formula)
            const base = 0.25 * (playerStats.defence + playerStats.hitpoints + Math.floor(playerStats.prayer / 2));
            const melee = 0.325 * (playerStats.attack + playerStats.strength);
            const range = 0.325 * Math.floor(playerStats.ranged * 1.5);
            const mage = 0.325 * Math.floor(playerStats.magic * 1.5);
            playerStats.combatLevel = Math.floor(base + Math.max(melee, range, mage));
            if (playerStats.combatLevel < 3) playerStats.combatLevel = 3;
            playerStats.maxHp = 10 + playerStats.hitpoints * 10;
            updateOrbs();
            renderStats();
        }

        let selectedSkill = null;
        function renderStats() {
            const el = document.getElementById('stats-content');
            let html = '<div class="skill-grid">';
            SKILLS.forEach(s => {
                const lvl = playerStats[s.id];
                const xp = playerStats[s.id + 'XP'];
                const curXp = xpForLevel(lvl);
                const nextXp = xpForLevel(lvl + 1);
                const pct = nextXp > curXp ? Math.min(100, ((xp - curXp) / (nextXp - curXp)) * 100) : 100;
                const isSelected = selectedSkill === s.id;
                html += `<div class="skill-cell${isSelected ? ' skill-selected' : ''}" id="skill-${s.id}" onclick="selectSkill('${s.id}')">
                    <span class="skill-icon">${s.icon}</span>
                    <span class="skill-lvl">${lvl}</span>
                    <div class="skill-xp-bar"><div class="skill-xp-fill" style="width:${pct}%"></div></div>
                </div>`;
            });
            html += '</div>';
            // Total level
            const totalLevel = SKILLS.reduce((sum, s) => sum + playerStats[s.id], 0);
            html += `<div class="skill-total">Total Level: ${totalLevel}</div>`;
            // Selected skill detail
            if (selectedSkill) {
                const s = SKILLS.find(sk => sk.id === selectedSkill);
                if (s) {
                    const lvl = playerStats[s.id];
                    const xp = playerStats[s.id + 'XP'];
                    const nextXp = xpForLevel(lvl + 1);
                    html += `<div class="skill-detail">
                        <div class="skill-detail-name">${s.icon} ${s.name}</div>
                        <div class="skill-detail-row">Level: <b>${lvl}</b></div>
                        <div class="skill-detail-row">XP: <b>${xp.toLocaleString()}</b></div>
                        <div class="skill-detail-row">Next level: <b>${nextXp.toLocaleString()}</b></div>
                        <div class="skill-detail-row">Remaining: <b>${(nextXp - xp).toLocaleString()}</b></div>
                    </div>`;
                }
            }
            el.innerHTML = html;
            document.getElementById('statCombatLvl').textContent = playerStats.combatLevel;
        }
        window.selectSkill = function(id) {
            selectedSkill = selectedSkill === id ? null : id;
            renderStats();
        };

        // ============================================================
        // === CHAT SYSTEM ===
        // ============================================================
        const chatHistory = [];
        let chatFilter = 'all';
        let chatInputFocused = false;

        function addChatMessage(type, text, sender, color) {
            chatHistory.push({ type, text, sender, color, time: Date.now() });
            if (chatHistory.length > 100) chatHistory.shift();
            renderChat();
        }

        function renderChat() {
            const el = document.getElementById('chat-messages');
            const filtered = chatFilter === 'all' ? chatHistory : chatHistory.filter(m => m.type === chatFilter);
            el.innerHTML = filtered.slice(-50).map(m => {
                const cls = 'chat-msg-' + m.type;
                const prefix = m.sender ? `<span style="color:${m.color || '#fff'};font-weight:bold">${m.sender}:</span> ` : '';
                return `<div class="${cls}">${prefix}${m.text}</div>`;
            }).join('');
            el.scrollTop = el.scrollHeight;
        }

        window.switchChatTab = function(tab) {
            chatFilter = tab;
            document.querySelectorAll('.chat-tab').forEach(t => t.classList.toggle('active', t.textContent.toLowerCase() === tab));
            renderChat();
        };

        // Chat input
        const chatInput = document.getElementById('chat-input');
        chatInput.addEventListener('focus', () => { chatInputFocused = true; });
        chatInput.addEventListener('blur', () => { chatInputFocused = false; });
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && chatInput.value.trim()) {
                const msg = chatInput.value.trim();
                addChatMessage('public', msg, playerName, playerColor);
                showChatBubble(playerWorldX, playerWorldZ, msg, playerColor);
                // Broadcast to multiplayer
                if (chatChannel) {
                    chatChannel.send({ type: 'broadcast', event: 'chat', payload: { sender: playerName, message: msg, color: playerColor } });
                }
                chatInput.value = '';
                chatInput.blur();
            }
            if (e.key === 'Escape') { chatInput.blur(); }
            e.stopPropagation();
        });

        function showChatBubble(worldX, worldZ, text, color) {
            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';
            bubble.textContent = text.substring(0, 40);
            if (color) bubble.style.color = color;
            bubble.dataset.worldX = worldX;
            bubble.dataset.worldZ = worldZ;
            document.getElementById('chat-bubbles').appendChild(bubble);
            setTimeout(() => bubble.remove(), 5000);
        }

        // ============================================================
        // === SIDEBAR TABS ===
        // ============================================================
        window.switchSidebarTab = function(tab) {
            document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.toggle('active', t.textContent.toLowerCase().startsWith(tab)));
            document.querySelectorAll('.sidebar-content').forEach(c => c.classList.remove('active'));
            document.getElementById('tab-' + tab).classList.add('active');
        };

        // ============================================================
        // === BUILDINGS CONFIG ===
        // ============================================================
        const BUILDINGS = [
            // Town Center
            { id:'town_hall', name:'Town Hall', icon:'\u{1F3DB}\uFE0F', x:40, z:38, w:3, d:3, h:2.5, wallColor:0xE8DCC8, roofColor:0x8b5cf6, signColor:'#8b5cf6', doorSide:'south', description:'Governance and respawn point.' },
            { id:'quest_board', name:'Quest Board', icon:'\u{1F4CB}', x:42, z:36, w:1, d:1, h:1.2, wallColor:0x8B7355, roofColor:0x6366f1, signColor:'#6366f1', doorSide:'south', description:'View active proposals and bounties.', type:'pedestal' },
            { id:'arena', name:'Arena', icon:'\u2694\uFE0F', x:37, z:42, w:4, d:4, h:1.8, wallColor:0xCD853F, roofColor:0xef4444, signColor:'#ef4444', doorSide:'north', description:'PvP combat arena. Fight agents here!' },
            { id:'bank', name:'SUITE Bank', icon:'\u{1F3E6}', x:44, z:40, w:2.5, d:2, h:2.0, wallColor:0xBDB76B, roofColor:0xeab308, signColor:'#eab308', doorSide:'west', description:'Store your valuables safely.' },
            // Health District (NW)
            { id:'health_clinic', name:'Health Clinic', icon:'\u{1F3E5}', x:26, z:24, w:3, d:2.5, h:1.8, wallColor:0x8FBC8F, roofColor:0x22c55e, signColor:'#22c55e', doorSide:'south', description:'TrueForm, GymPlan, and more health apps.' },
            { id:'gym', name:'Fitness Dojo', icon:'\u{1F3CB}\uFE0F', x:30, z:28, w:2.5, d:2, h:1.5, wallColor:0xD2B48C, roofColor:0x22c55e, signColor:'#22c55e', doorSide:'east', description:'Train your body and mind.' },
            // Education District (N-center)
            { id:'academy', name:'SUITE Academy', icon:'\u{1F3EB}', x:40, z:24, w:3.5, d:2.5, h:2.0, wallColor:0xE8DCC8, roofColor:0x3b82f6, signColor:'#3b82f6', doorSide:'south', description:'TutorBot, QuizMaker, and learning apps.' },
            { id:'library', name:'Knowledge Library', icon:'\u{1F4DA}', x:44, z:28, w:2.5, d:2, h:1.6, wallColor:0xD2B48C, roofColor:0x3b82f6, signColor:'#3b82f6', doorSide:'west', description:'A vast repository of knowledge.' },
            // Business District (NE)
            { id:'exchange', name:'Trade Exchange', icon:'\u{1F4B9}', x:52, z:24, w:3, d:2.5, h:2.2, wallColor:0xBDB76B, roofColor:0xeab308, signColor:'#eab308', doorSide:'south', description:'Commerce and trading hub.' },
            { id:'marketplace', name:'Marketplace', icon:'\u{1F3EA}', x:56, z:28, w:2.5, d:2, h:1.4, wallColor:0xBDB76B, roofColor:0xf97316, signColor:'#f97316', doorSide:'west', description:'Trade items and browse the exchange.' },
            // Productivity District (W-center)
            { id:'workshop', name:'Workshop', icon:'\u{1F528}', x:26, z:36, w:3, d:2.5, h:1.8, wallColor:0xD2B48C, roofColor:0x8b5cf6, signColor:'#8b5cf6', doorSide:'east', description:'Where builders create and refine SUITE apps.' },
            { id:'forge', name:'The Forge', icon:'\u2699\uFE0F', x:30, z:40, w:2.5, d:2, h:1.6, wallColor:0xCD853F, roofColor:0x8b5cf6, signColor:'#8b5cf6', doorSide:'east', description:'Craft and forge powerful equipment.' },
            // Creative District (SW)
            { id:'studio', name:'Creative Studio', icon:'\u{1F3A8}', x:26, z:48, w:3, d:2.5, h:1.6, wallColor:0xE8DCC8, roofColor:0xec4899, signColor:'#ec4899', doorSide:'north', description:'StoryForge, LogoForge, and creative tools.' },
            { id:'gallery', name:'Art Gallery', icon:'\u{1F5BC}\uFE0F', x:30, z:52, w:2.5, d:2, h:1.4, wallColor:0xE8DCC8, roofColor:0xec4899, signColor:'#ec4899', doorSide:'north', description:'Showcase your creative works.' },
            // Marketing District (S-center)
            { id:'broadcast_tower', name:'Broadcast Tower', icon:'\u{1F4E1}', x:40, z:48, w:2, d:2, h:3.0, wallColor:0xD2B48C, roofColor:0xf97316, signColor:'#f97316', doorSide:'north', description:'SUITE broadcasting headquarters.' },
            { id:'ad_agency', name:'Ad Agency', icon:'\u{1F4E3}', x:44, z:52, w:2.5, d:2, h:1.4, wallColor:0xBDB76B, roofColor:0xf97316, signColor:'#f97316', doorSide:'north', description:'Marketing campaigns and outreach.' },
            // Home District (SE)
            { id:'farm', name:'Farm', icon:'\u{1F33E}', x:52, z:40, w:3, d:3, h:1.0, wallColor:0x8FBC8F, roofColor:0x22c55e, signColor:'#22c55e', doorSide:'west', description:'Harvest food and materials.' },
            { id:'tavern', name:"Traveler's Tavern", icon:'\u{1F37A}', x:56, z:48, w:2.5, d:2, h:1.5, wallColor:0xCD853F, roofColor:0x14b8a6, signColor:'#14b8a6', doorSide:'west', description:'Rest and recover from your adventures.' },
            // Zone Landmarks
            { id:'forest_outpost', name:'Forest Outpost', icon:'\u{1F332}', x:40, z:18, w:2, d:2, h:1.3, wallColor:0x6B4226, roofColor:0x22c55e, signColor:'#22c55e', doorSide:'south', description:'Gateway to The Forest.' },
            { id:'ruins_gate', name:'Ruins Gate', icon:'\u{1F3DA}\uFE0F', x:62, z:38, w:2, d:2, h:2.0, wallColor:0x888888, roofColor:0xf97316, signColor:'#f97316', doorSide:'west', description:'Entrance to The Ruins.' },
            { id:'deep_entrance', name:'Deep Network Portal', icon:'\u{1F30A}', x:40, z:57, w:2, d:2, h:2.5, wallColor:0x1e1b4b, roofColor:0xef4444, signColor:'#ef4444', doorSide:'north', description:'Portal to The Deep Network.' },
        ];

        const buildingDoors = {};

        const ROLE_BUILDING_WEIGHTS = {
            app_builder:     { workshop:40, forge:20, quest_board:15, town_hall:10, marketplace:8, academy:5, arena:2 },
            app_refiner:     { workshop:30, forge:25, quest_board:15, town_hall:10, marketplace:10, library:5, arena:5 },
            content_creator: { studio:25, gallery:20, quest_board:15, broadcast_tower:15, town_hall:10, marketplace:10, arena:5 },
            growth_outreach: { broadcast_tower:30, ad_agency:25, marketplace:20, quest_board:10, town_hall:10, arena:5 },
            qa_tester:       { workshop:30, forge:20, quest_board:20, arena:15, town_hall:10, library:5 },
        };

        // ============================================================
        // === THREE.JS SCENE SETUP ===
        // ============================================================
        const viewport = document.getElementById('game-viewport');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.012);

        const camera = new THREE.PerspectiveCamera(45, viewport.clientWidth / viewport.clientHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        viewport.insertBefore(renderer.domElement, viewport.firstChild);

        let camTargetX = 40, camTargetZ = 38;
        let camAngle = Math.PI / 4;
        let camDist = 18, camHeight = 14;

        function updateCamera() {
            camera.position.set(
                camTargetX + Math.sin(camAngle) * camDist,
                camHeight,
                camTargetZ + Math.cos(camAngle) * camDist
            );
            camera.lookAt(camTargetX, 0, camTargetZ);
        }
        updateCamera();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x6688aa, 0.5);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffeedd, 0.9);
        sunLight.position.set(40, 30, 30);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(2048, 2048);
        sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 100;
        sunLight.shadow.camera.left = -40; sunLight.shadow.camera.right = 40;
        sunLight.shadow.camera.top = 40; sunLight.shadow.camera.bottom = -40;
        scene.add(sunLight);
        const hemiLight = new THREE.HemisphereLight(0x88aacc, 0x445522, 0.3);
        scene.add(hemiLight);

        // Day/Night
        let isNight = false;
        window.toggleDayNight = function() {
            isNight = !isNight;
            if (isNight) {
                scene.background.set(0x0a0a1a); scene.fog.color.set(0x0a0a1a);
                scene.fog.density = 0.018;
                ambientLight.intensity = 0.15; sunLight.intensity = 0.1;
                sunLight.color.set(0x4466aa); hemiLight.intensity = 0.05;
            } else {
                scene.background.set(0x87CEEB); scene.fog.color.set(0x87CEEB);
                scene.fog.density = 0.012;
                ambientLight.intensity = 0.5; sunLight.intensity = 0.9;
                sunLight.color.set(0xffeedd); hemiLight.intensity = 0.3;
            }
        };

        // ============================================================
        // === TERRAIN ===
        // ============================================================
        const grid = [], heightMap = [];
        function seededRandom(seed) { let s = seed; return function() { s = (s*16807+0)%2147483647; return (s-1)/2147483646; }; }
        const rng = seededRandom(42);
        function simpleNoise(x, z) { return Math.sin(x*0.3)*Math.cos(z*0.4)*0.3 + Math.sin(x*0.7+1)*Math.cos(z*0.5+2)*0.15; }

        function getTerrainZone(x, z) {
            // Check zones in priority order
            if (x >= 20 && x <= 60 && z >= 20 && z <= 55) return 'city';
            if (z <= 20) return 'forest';
            if (x >= 60) return 'ruins';
            if (z >= 55) return 'deep';
            return 'city';
        }

        function isWater(x, z) {
            // Forest lake
            if (Math.sqrt((x-25)**2+(z-10)**2) < 4) return true;
            // Forest river
            const rz = 14 + Math.sin(x*0.3)*2;
            if (Math.abs(z-rz) < 1.2 && x > 8 && x < 50) return true;
            // Ruins moat
            if (Math.sqrt((x-68)**2+(z-38)**2) > 6 && Math.sqrt((x-68)**2+(z-38)**2) < 8 && x > 62 && x < 76 && z > 30 && z < 46) return true;
            // Deep void pools
            if (Math.sqrt((x-30)**2+(z-66)**2) < 3) return true;
            if (Math.sqrt((x-55)**2+(z-70)**2) < 2.5) return true;
            return false;
        }
        function isBridge(x, z) {
            // Forest river bridges
            const rz = 14+Math.sin(x*0.3)*2;
            if (Math.abs(z-rz)<1.2 && ((x>=28 && x<=30) || (x>=38 && x<=40))) return true;
            return false;
        }
        function isRoad(x, z) {
            const tz = getTerrainZone(x, z);
            if (tz === 'city') {
                // Grid roads in city
                if (x >= 20 && x <= 60 && (x === 35 || x === 48)) return true;
                if (z >= 20 && z <= 55 && (z === 33 || z === 44)) return true;
                // Main road through center
                if (Math.abs(x-40) < 1 && z >= 18 && z <= 57) return true;
                if (Math.abs(z-38) < 1 && x >= 18 && x <= 62) return true;
            }
            // Connecting roads to zones
            if (Math.abs(x-40) < 1 && z >= 2 && z <= 20) return true; // north to forest
            if (Math.abs(z-38) < 1 && x >= 58 && x <= 78) return true; // east to ruins
            if (Math.abs(x-40) < 1 && z >= 53 && z <= 78) return true; // south to deep
            return false;
        }
        function isInBuildingZone(x, z) {
            for (const b of BUILDINGS) { const hw=b.w/2+0.5,hd=b.d/2+0.5; if(x>=b.x-hw&&x<=b.x+hw&&z>=b.z-hd&&z<=b.z+hd) return true; }
            return false;
        }

        // Zone-specific terrain colors
        const cityGrass=[0x4a7c3f,0x528745,0x5d9248], forestGrass=[0x2d5a1e,0x3a6e28,0x346424,0x2a5c1c];
        const ruinsGround=[0x6b6b6b,0x7a7a7a,0x636363,0x585858], deepGround=[0x1a1030,0x221540,0x1e1238,0x2a1848];
        const dirtColors=[0x8B7355,0x7a6548,0x6d5b40];

        for (let x=0;x<MAP_SIZE;x++){grid[x]=[];heightMap[x]=[];for(let z=0;z<MAP_SIZE;z++){
            const w=isWater(x,z),br=isBridge(x,z);
            if(br){grid[x][z]=3;heightMap[x][z]=0.05;}
            else if(w){grid[x][z]=0;heightMap[x][z]=WATER_LEVEL;}
            else{grid[x][z]=1;heightMap[x][z]=simpleNoise(x,z)*0.15;}
        }}

        // Mark roads
        for(let x=0;x<MAP_SIZE;x++)for(let z=0;z<MAP_SIZE;z++){
            if(grid[x][z]>0 && isRoad(x,z) && !isInBuildingZone(x,z)) grid[x][z]=2;
        }

        // Terrain mesh
        const tileMeshes=[];
        for(let x=0;x<MAP_SIZE;x++){tileMeshes[x]=[];for(let z=0;z<MAP_SIZE;z++){
            const h=heightMap[x][z]; let color;
            const tz=getTerrainZone(x,z);
            if(grid[x][z]===3) color=0x8B6914;
            else if(isWater(x,z)) {
                color = tz==='deep' ? 0x2a1060 : 0x2288aa;
            } else {
                let nw=false;
                for(let dx=-1;dx<=1;dx++)for(let dz=-1;dz<=1;dz++){const nx=x+dx,nz=z+dz;if(nx>=0&&nx<MAP_SIZE&&nz>=0&&nz<MAP_SIZE&&isWater(nx,nz)&&!isBridge(nx,nz))nw=true;}
                if(nw) color=tz==='deep'?0x3a2060:0xc2b280;
                else if(grid[x][z]===2) color=dirtColors[Math.floor(rng()*dirtColors.length)];
                else {
                    if(tz==='forest') color=forestGrass[Math.floor(rng()*forestGrass.length)];
                    else if(tz==='ruins') color=ruinsGround[Math.floor(rng()*ruinsGround.length)];
                    else if(tz==='deep') color=deepGround[Math.floor(rng()*deepGround.length)];
                    else color=cityGrass[Math.floor(rng()*cityGrass.length)];
                }
            }
            const geo=new THREE.BoxGeometry(TILE_SIZE,grid[x][z]===3?0.15:0.3,TILE_SIZE);
            const mat=new THREE.MeshLambertMaterial({color});
            const tile=new THREE.Mesh(geo,mat);
            tile.position.set(x,h-0.15,z);tile.receiveShadow=true;
            tile.userData={tileX:x,tileZ:z,walkable:grid[x][z]>0,type:'tile'};
            scene.add(tile);tileMeshes[x][z]=tile;
        }}

        // Water planes for each water body
        const waterGeo=new THREE.PlaneGeometry(80,80,40,40);
        const waterMat=new THREE.MeshLambertMaterial({color:0x2288aa,transparent:true,opacity:0.6});
        const waterMesh=new THREE.Mesh(waterGeo,waterMat);
        waterMesh.rotation.x=-Math.PI/2;waterMesh.position.set(40,WATER_LEVEL+0.05,40);scene.add(waterMesh);

        // Deep void water overlay (purple tint)
        const deepWaterGeo=new THREE.PlaneGeometry(60,25,20,10);
        const deepWaterMat=new THREE.MeshLambertMaterial({color:0x3a1080,transparent:true,opacity:0.4});
        const deepWaterMesh=new THREE.Mesh(deepWaterGeo,deepWaterMat);
        deepWaterMesh.rotation.x=-Math.PI/2;deepWaterMesh.position.set(40,WATER_LEVEL+0.06,66);scene.add(deepWaterMesh);

        // Trees ‚Äî interactive world objects with registry
        const treeRegistry = new Map();
        let treeIdCounter = 0;
        const treePositions=[];

        function createTree(x, z, v, treeType) {
            const g = new THREE.Group();
            const h = heightMap[x][z];
            const tt = TREE_TYPES[treeType] || TREE_TYPES.normal;
            const treeId = 'tree_' + (treeIdCounter++);
            const foliageMeshes = [];

            // Trunk varies by type
            let trunkH = 0.6 + rng() * 0.4;
            let trunkRadius = 0.08;
            let trunkColor = 0x6B4226;
            if (treeType === 'oak') { trunkH = 0.8 + rng() * 0.3; trunkRadius = 0.12; }
            else if (treeType === 'willow') { trunkH = 0.7 + rng() * 0.3; trunkColor = 0x5a3a1a; }
            else if (treeType === 'yew') { trunkH = 1.0 + rng() * 0.3; trunkRadius = 0.1; trunkColor = 0x4a3020; }
            else if (treeType === 'magic') { trunkH = 1.1 + rng() * 0.3; trunkRadius = 0.1; trunkColor = 0x3a2844; }
            else if (treeType === 'maple') { trunkH = 0.75 + rng() * 0.3; }

            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(trunkRadius, trunkRadius + 0.04, trunkH, 5),
                new THREE.MeshLambertMaterial({ color: trunkColor })
            );
            trunk.position.y = trunkH / 2;
            trunk.castShadow = true;
            g.add(trunk);

            // Stump (hidden until depleted)
            const stump = new THREE.Mesh(
                new THREE.CylinderGeometry(trunkRadius + 0.02, trunkRadius + 0.06, 0.15, 5),
                new THREE.MeshLambertMaterial({ color: 0x5a3a1a })
            );
            stump.position.y = 0.075;
            stump.visible = false;
            g.add(stump);

            // Foliage by tree type
            if (treeType === 'normal') {
                const leafColors = [0x2d5a1e, 0x3a6e28, 0x468032];
                if (v === 0) {
                    [0.5, 0.4, 0.28].forEach((s, i) => {
                        const c = new THREE.Mesh(new THREE.ConeGeometry(s, 0.5, 5), new THREE.MeshLambertMaterial({ color: leafColors[i % 3] }));
                        c.position.y = trunkH + 0.15 + i * 0.35; c.castShadow = true; g.add(c); foliageMeshes.push(c);
                    });
                } else if (v === 1) {
                    const l = new THREE.Mesh(new THREE.DodecahedronGeometry(0.45, 0), new THREE.MeshLambertMaterial({ color: leafColors[0] }));
                    l.position.y = trunkH + 0.35; l.castShadow = true; g.add(l); foliageMeshes.push(l);
                } else {
                    const b = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35, 0), new THREE.MeshLambertMaterial({ color: leafColors[1] }));
                    b.position.y = trunkH + 0.2; b.castShadow = true; g.add(b); foliageMeshes.push(b);
                }
            } else if (treeType === 'oak') {
                // Larger, darker green dodecahedron
                const l = new THREE.Mesh(new THREE.DodecahedronGeometry(0.6, 0), new THREE.MeshLambertMaterial({ color: 0x1a4a10 }));
                l.position.y = trunkH + 0.4; l.castShadow = true; g.add(l); foliageMeshes.push(l);
                const l2 = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4, 0), new THREE.MeshLambertMaterial({ color: 0x2d5a1e }));
                l2.position.y = trunkH + 0.8; l2.castShadow = true; g.add(l2); foliageMeshes.push(l2);
            } else if (treeType === 'willow') {
                // Yellowish-green droopy cones
                const colors = [0x6b8e23, 0x7a9a2e, 0x8aaa38];
                [0.55, 0.45, 0.35].forEach((s, i) => {
                    const c = new THREE.Mesh(new THREE.ConeGeometry(s, 0.7, 5), new THREE.MeshLambertMaterial({ color: colors[i] }));
                    c.position.y = trunkH + 0.1 + i * 0.3; c.castShadow = true; g.add(c); foliageMeshes.push(c);
                });
            } else if (treeType === 'maple') {
                // Red-orange foliage
                const l = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5, 0), new THREE.MeshLambertMaterial({ color: 0xcc6622 }));
                l.position.y = trunkH + 0.35; l.castShadow = true; g.add(l); foliageMeshes.push(l);
                const l2 = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35, 0), new THREE.MeshLambertMaterial({ color: 0xdd7733 }));
                l2.position.y = trunkH + 0.7; l2.castShadow = true; g.add(l2); foliageMeshes.push(l2);
            } else if (treeType === 'yew') {
                // Dark green, tall thin
                const l = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.0, 6), new THREE.MeshLambertMaterial({ color: 0x1a3a1a }));
                l.position.y = trunkH + 0.5; l.castShadow = true; g.add(l); foliageMeshes.push(l);
                const l2 = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.6, 6), new THREE.MeshLambertMaterial({ color: 0x224422 }));
                l2.position.y = trunkH + 1.1; l2.castShadow = true; g.add(l2); foliageMeshes.push(l2);
            } else if (treeType === 'magic') {
                // Purple foliage with glow
                const l = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5, 1), new THREE.MeshLambertMaterial({ color: 0x8855cc }));
                l.position.y = trunkH + 0.4; l.castShadow = true; g.add(l); foliageMeshes.push(l);
                const l2 = new THREE.Mesh(new THREE.IcosahedronGeometry(0.3, 0), new THREE.MeshLambertMaterial({ color: 0x9966dd }));
                l2.position.y = trunkH + 0.85; l2.castShadow = true; g.add(l2); foliageMeshes.push(l2);
                // Glow
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), new THREE.MeshBasicMaterial({ color: 0xa855f7, transparent: true, opacity: 0.12 }));
                glow.position.y = trunkH + 0.5; g.add(glow); foliageMeshes.push(glow);
            }

            // Tag all meshes for raycasting
            g.traverse(c => { if (c.isMesh) { c.userData.type = 'tree'; c.userData.treeId = treeId; } });
            g.position.set(x, h, z);
            scene.add(g);

            treeRegistry.set(treeId, {
                id: treeId, x, z, treeType, meshGroup: g,
                foliageMeshes, stump, trunkMesh: trunk,
                isDepleted: false, respawnTimer: 0
            });
            return treeId;
        }

        function depleteTree(treeData) {
            treeData.isDepleted = true;
            treeData.respawnTimer = TREE_TYPES[treeData.treeType].respawnTime;
            treeData.foliageMeshes.forEach(m => m.visible = false);
            treeData.trunkMesh.visible = false;
            treeData.stump.visible = true;
        }

        function respawnTree(treeData) {
            treeData.isDepleted = false;
            treeData.respawnTimer = 0;
            treeData.foliageMeshes.forEach(m => m.visible = true);
            treeData.trunkMesh.visible = true;
            treeData.stump.visible = false;
        }

        // Assign tree types by zone
        function pickForestTreeType(x, z) {
            const r = rng();
            if (r < 0.05) return 'maple';
            if (r < 0.15 && z < 8) return 'willow'; // near water
            if (r < 0.40) return 'oak';
            return 'normal';
        }

        // Forest: 200 trees
        for(let i=0;i<200;i++){const x=5+Math.floor(rng()*70),z=2+Math.floor(rng()*18);if(x<MAP_SIZE&&z<MAP_SIZE&&grid[x][z]>0&&!isWater(x,z)&&!isInBuildingZone(x,z)&&grid[x][z]!==2){treePositions.push({x,z,treeType:pickForestTreeType(x,z)});grid[x][z]=0;}}
        // City: 30 trees (all normal)
        for(let i=0;i<30;i++){const x=22+Math.floor(rng()*36),z=22+Math.floor(rng()*31);if(x<MAP_SIZE&&z<MAP_SIZE&&grid[x][z]===1&&!isWater(x,z)&&!isInBuildingZone(x,z)){treePositions.push({x,z,treeType:'normal'});grid[x][z]=0;}}
        // Ruins: 40 rubble obstacles (rocks instead of trees)
        const rubblePositions=[];
        for(let i=0;i<40;i++){const x=60+Math.floor(rng()*18),z=20+Math.floor(rng()*35);if(x<MAP_SIZE&&z<MAP_SIZE&&grid[x][z]>0&&!isWater(x,z)&&!isInBuildingZone(x,z)&&grid[x][z]!==2){rubblePositions.push({x,z});grid[x][z]=0;}}
        // Deep: 60 void obstacles
        const voidPositions=[];
        for(let i=0;i<60;i++){const x=10+Math.floor(rng()*60),z=56+Math.floor(rng()*22);if(x<MAP_SIZE&&z<MAP_SIZE&&grid[x][z]>0&&!isWater(x,z)&&!isInBuildingZone(x,z)&&grid[x][z]!==2){voidPositions.push({x,z});grid[x][z]=0;}}

        treePositions.forEach(p=>createTree(p.x,p.z,Math.floor(rng()*3),p.treeType||'normal'));
        // Yew trees in ruins (~15)
        for(let i=0;i<30;i++){const x=61+Math.floor(rng()*16),z=21+Math.floor(rng()*33);if(x<MAP_SIZE&&z<MAP_SIZE&&grid[x][z]>0&&!isWater(x,z)&&!isInBuildingZone(x,z)&&grid[x][z]!==2){createTree(x,z,0,'yew');grid[x][z]=0;if(treeRegistry.size>treePositions.length+15)break;}}
        // Magic trees in deep network (~10)
        for(let i=0;i<25;i++){const x=12+Math.floor(rng()*56),z=57+Math.floor(rng()*20);if(x<MAP_SIZE&&z<MAP_SIZE&&grid[x][z]>0&&!isWater(x,z)&&!isInBuildingZone(x,z)&&grid[x][z]!==2){createTree(x,z,0,'magic');grid[x][z]=0;if(i>=9)break;}}
        // Rubble in ruins
        rubblePositions.forEach(p=>{const r=new THREE.Mesh(new THREE.DodecahedronGeometry(0.2+rng()*0.3,0),new THREE.MeshLambertMaterial({color:[0x888888,0x777777,0x666666][Math.floor(rng()*3)]}));r.position.set(p.x+rng()*0.3,heightMap[p.x][p.z]+0.15,p.z+rng()*0.3);r.rotation.set(rng(),rng(),rng());r.castShadow=true;scene.add(r);});
        // Void pillars in deep network
        voidPositions.forEach(p=>{const h=0.3+rng()*0.8;const v=new THREE.Mesh(new THREE.CylinderGeometry(0.1+rng()*0.15,0.15+rng()*0.1,h,5),new THREE.MeshLambertMaterial({color:[0x3a1868,0x2e1450,0x4a2080][Math.floor(rng()*3)]}));v.position.set(p.x,heightMap[p.x][p.z]+h/2,p.z);v.castShadow=true;scene.add(v);if(rng()>0.6){const glow=new THREE.Mesh(new THREE.SphereGeometry(0.08,4,4),new THREE.MeshBasicMaterial({color:0xa855f7}));glow.position.set(p.x,heightMap[p.x][p.z]+h+0.1,p.z);scene.add(glow);}});

        // Flowers in city/forest
        for(let i=0;i<60;i++){const x=Math.floor(rng()*MAP_SIZE),z=Math.floor(rng()*55);if(x<MAP_SIZE&&z<MAP_SIZE&&grid[x][z]>0&&!isWater(x,z)&&!isInBuildingZone(x,z)){const fc=[0xff6b9d,0xffd93d,0xff8a5c,0xc084fc,0xfb7185];const f=new THREE.Mesh(new THREE.SphereGeometry(0.06,4,4),new THREE.MeshLambertMaterial({color:fc[Math.floor(rng()*fc.length)]}));f.position.set(x+rng()*0.6-0.3,heightMap[x][z]+0.15,z+rng()*0.6-0.3);scene.add(f);}}

        // Glowing patches in deep network
        for(let i=0;i<30;i++){const x=12+Math.floor(rng()*56),z=57+Math.floor(rng()*20);if(x<MAP_SIZE&&z<MAP_SIZE&&grid[x][z]>0){const g=new THREE.Mesh(new THREE.PlaneGeometry(0.8+rng()*0.5,0.8+rng()*0.5),new THREE.MeshBasicMaterial({color:[0x6366f1,0xa855f7,0xef4444][Math.floor(rng()*3)],transparent:true,opacity:0.15}));g.rotation.x=-Math.PI/2;g.position.set(x,heightMap[x][z]+0.01,z);scene.add(g);}}

        // ============================================================
        // === FISHING SPOTS ===
        // ============================================================
        const fishingSpotRegistry = new Map();
        let fishingSpotIdCounter = 0;

        function createFishingSpot(x, z, fishType) {
            const ft = FISH_TYPES[fishType];
            if (!ft) return;
            const spotId = 'fspot_' + (fishingSpotIdCounter++);
            const g = new THREE.Group();
            const y = WATER_LEVEL + 0.06;

            // Base: flat cyan circle on water surface
            const base = new THREE.Mesh(
                new THREE.CircleGeometry(0.35, 12),
                new THREE.MeshBasicMaterial({ color: 0x44ccff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
            );
            base.rotation.x = -Math.PI / 2;
            base.position.y = 0;
            g.add(base);

            // Bubble dots: 3 small white spheres
            const bubbleMeshes = [];
            for (let i = 0; i < 3; i++) {
                const bubble = new THREE.Mesh(
                    new THREE.SphereGeometry(0.04, 4, 4),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 })
                );
                bubble.position.set(
                    (Math.random() - 0.5) * 0.4,
                    0.05 + Math.random() * 0.1,
                    (Math.random() - 0.5) * 0.4
                );
                bubble.userData.bubbleOffset = Math.random() * Math.PI * 2;
                g.add(bubble);
                bubbleMeshes.push(bubble);
            }

            // Tag all meshes for raycasting
            g.traverse(c => { if (c.isMesh) { c.userData.type = 'fishing_spot'; c.userData.fishingSpotId = spotId; } });
            g.position.set(x, y, z);
            scene.add(g);

            fishingSpotRegistry.set(spotId, {
                id: spotId, x, z, fishType, meshGroup: g,
                bubbleMeshes, baseMesh: base,
                isDepleted: false, respawnTimer: 0
            });
            return spotId;
        }

        function depleteFishingSpot(spot) {
            spot.isDepleted = true;
            spot.respawnTimer = FISH_TYPES[spot.fishType].respawnTime;
            spot.bubbleMeshes.forEach(m => m.visible = false);
            spot.baseMesh.material.opacity = 0.1;
        }

        function respawnFishingSpot(spot) {
            spot.isDepleted = false;
            spot.respawnTimer = 0;
            spot.bubbleMeshes.forEach(m => m.visible = true);
            spot.baseMesh.material.opacity = 0.4;
        }

        // Spawn fishing spots near water bodies
        // Helper: find water tiles with adjacent walkable land
        function spawnFishingSpotsNearWater(cx, cz, radius, fishWeights, maxSpots) {
            let placed = 0;
            for (let x = Math.floor(cx - radius - 1); x <= Math.ceil(cx + radius + 1) && placed < maxSpots; x++) {
                for (let z = Math.floor(cz - radius - 1); z <= Math.ceil(cz + radius + 1) && placed < maxSpots; z++) {
                    if (x < 0 || x >= MAP_SIZE || z < 0 || z >= MAP_SIZE) continue;
                    if (!isWater(x, z)) continue;
                    if (isBridge(x, z)) continue;
                    // Check distance from center
                    if (Math.sqrt((x - cx) ** 2 + (z - cz) ** 2) > radius + 0.5) continue;
                    // Must have adjacent walkable tile
                    let hasLand = false;
                    for (const d of [{x:0,z:1},{x:0,z:-1},{x:1,z:0},{x:-1,z:0}]) {
                        const nx = x + d.x, nz = z + d.z;
                        if (nx >= 0 && nx < MAP_SIZE && nz >= 0 && nz < MAP_SIZE && grid[nx][nz] > 0) { hasLand = true; break; }
                    }
                    if (!hasLand) continue;
                    // Random skip to spread them out
                    if (rng() > 0.4) continue;
                    // Pick fish type by weight
                    const roll = rng();
                    let cumulative = 0;
                    let chosenFish = fishWeights[0].type;
                    for (const fw of fishWeights) {
                        cumulative += fw.weight;
                        if (roll < cumulative) { chosenFish = fw.type; break; }
                    }
                    createFishingSpot(x, z, chosenFish);
                    placed++;
                }
            }
        }

        // Forest lake (center 25,10, radius 4): shrimp 60%, herring 30%, trout 10%
        spawnFishingSpotsNearWater(25, 10, 4, [
            { type: 'shrimp', weight: 0.6 }, { type: 'herring', weight: 0.3 }, { type: 'trout', weight: 0.1 }
        ], 8);

        // Forest river (z‚âà14, x: 8-50): shrimp and herring along the banks
        for (let rx = 10; rx < 48; rx += 4) {
            const rz = Math.round(14 + Math.sin(rx * 0.3) * 2);
            spawnFishingSpotsNearWater(rx, rz, 1.5, [
                { type: 'shrimp', weight: 0.5 }, { type: 'herring', weight: 0.5 }
            ], 2);
        }

        // Ruins moat (center 68,38, ring r6-8): lobster 60%, swordfish 40%
        spawnFishingSpotsNearWater(68, 38, 8, [
            { type: 'lobster', weight: 0.6 }, { type: 'swordfish', weight: 0.4 }
        ], 6);

        // Deep void pool 1 (center 30,66, r3): shark 50%, manta_ray 50%
        spawnFishingSpotsNearWater(30, 66, 3, [
            { type: 'shark', weight: 0.5 }, { type: 'manta_ray', weight: 0.5 }
        ], 4);

        // Deep void pool 2 (center 55,70, r2.5): shark 50%, manta_ray 50%
        spawnFishingSpotsNearWater(55, 70, 2.5, [
            { type: 'shark', weight: 0.5 }, { type: 'manta_ray', weight: 0.5 }
        ], 3);

        // ============================================================
        // === NAMED BUILDINGS ===
        // ============================================================
        const buildingMeshes = [];
        function createNamedBuilding(bData) {
            const group = new THREE.Group();
            const baseH = heightMap[Math.min(Math.floor(bData.x),MAP_SIZE-1)][Math.min(Math.floor(bData.z),MAP_SIZE-1)]||0;
            if (bData.type === 'pedestal') {
                const base = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,0.6,6), new THREE.MeshLambertMaterial({color:bData.wallColor}));
                base.position.y=0.3; base.castShadow=true; group.add(base);
                const board = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.5,0.08), new THREE.MeshLambertMaterial({color:0x5a3a1a}));
                board.position.y=0.85; board.castShadow=true; group.add(board);
                [0xff4444,0x44ff44,0x4444ff,0xffff44].forEach((c,i)=>{const p=new THREE.Mesh(new THREE.SphereGeometry(0.04,4,4),new THREE.MeshBasicMaterial({color:c}));p.position.set(-0.2+(i%2)*0.4,0.75+Math.floor(i/2)*0.2,0.05);group.add(p);});
                const cx=Math.floor(bData.x),cz=Math.floor(bData.z);if(cx>=0&&cx<MAP_SIZE&&cz>=0&&cz<MAP_SIZE)grid[cx][cz]=0;
                buildingDoors[bData.id]={x:cx,z:cz+1};
            } else {
                const walls=new THREE.Mesh(new THREE.BoxGeometry(bData.w,bData.h,bData.d),new THREE.MeshLambertMaterial({color:bData.wallColor}));walls.position.y=bData.h/2;walls.castShadow=true;walls.receiveShadow=true;group.add(walls);
                const roof=new THREE.Mesh(new THREE.ConeGeometry(Math.max(bData.w,bData.d)*0.75,bData.h*0.5,4),new THREE.MeshLambertMaterial({color:bData.roofColor}));roof.position.y=bData.h+bData.h*0.2;roof.rotation.y=Math.PI/4;roof.castShadow=true;group.add(roof);
                const door=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.5,0.05),new THREE.MeshLambertMaterial({color:0x5a3a1a}));
                switch(bData.doorSide){case'south':door.position.set(0,0.25,bData.d/2+0.02);break;case'north':door.position.set(0,0.25,-bData.d/2-0.02);break;case'west':door.position.set(-bData.w/2-0.02,0.25,0);door.rotation.y=Math.PI/2;break;case'east':door.position.set(bData.w/2+0.02,0.25,0);door.rotation.y=Math.PI/2;break;}
                group.add(door);
                const hw=Math.ceil(bData.w/2),hd=Math.ceil(bData.d/2);
                for(let bx=Math.floor(bData.x)-hw;bx<=Math.floor(bData.x)+hw;bx++)for(let bz=Math.floor(bData.z)-hd;bz<=Math.floor(bData.z)+hd;bz++)if(bx>=0&&bx<MAP_SIZE&&bz>=0&&bz<MAP_SIZE)grid[bx][bz]=0;
                let dt;switch(bData.doorSide){case'south':dt={x:Math.floor(bData.x),z:Math.floor(bData.z)+hd+1};break;case'north':dt={x:Math.floor(bData.x),z:Math.floor(bData.z)-hd-1};break;case'west':dt={x:Math.floor(bData.x)-hw-1,z:Math.floor(bData.z)};break;case'east':dt={x:Math.floor(bData.x)+hw+1,z:Math.floor(bData.z)};break;}
                if(dt&&dt.x>=0&&dt.x<MAP_SIZE&&dt.z>=0&&dt.z<MAP_SIZE){grid[dt.x][dt.z]=1;buildingDoors[bData.id]=dt;}
            }
            group.position.set(bData.x,baseH,bData.z);
            group.traverse(c=>{if(c.isMesh){c.userData.buildingId=bData.id;c.userData.type='building';}});
            scene.add(group); buildingMeshes.push({group,data:bData});
        }
        BUILDINGS.forEach(b=>createNamedBuilding(b));

        // ============================================================
        // === PLAYER CHARACTER ===
        // ============================================================
        const playerGroup = new THREE.Group();
        const bodyColor = new THREE.Color(playerColor);
        const hairColor = new THREE.Color(playerHairColor);
        const body=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.5,0.2),new THREE.MeshLambertMaterial({color:bodyColor}));body.position.y=0.5;body.castShadow=true;playerGroup.add(body);
        const head=new THREE.Mesh(new THREE.BoxGeometry(0.25,0.25,0.25),new THREE.MeshLambertMaterial({color:0xffcc99}));head.position.y=0.9;head.castShadow=true;playerGroup.add(head);
        // Hair on top of head
        const hair=new THREE.Mesh(new THREE.BoxGeometry(0.27,0.08,0.27),new THREE.MeshLambertMaterial({color:hairColor}));hair.position.y=1.04;playerGroup.add(hair);
        const legGeo=new THREE.BoxGeometry(0.1,0.3,0.15),legMat=new THREE.MeshLambertMaterial({color:0x554433});
        const leftLeg=new THREE.Mesh(legGeo,legMat);leftLeg.position.set(-0.08,0.15,0);playerGroup.add(leftLeg);
        const rightLeg=new THREE.Mesh(legGeo,legMat);rightLeg.position.set(0.08,0.15,0);playerGroup.add(rightLeg);
        const armGeo=new THREE.BoxGeometry(0.08,0.35,0.1),armMat=new THREE.MeshLambertMaterial({color:bodyColor});
        const leftArm=new THREE.Mesh(armGeo,armMat);leftArm.position.set(-0.22,0.5,0);playerGroup.add(leftArm);
        const rightArm=new THREE.Mesh(armGeo,armMat);rightArm.position.set(0.22,0.5,0);playerGroup.add(rightArm);
        const playerShadow=new THREE.Mesh(new THREE.CircleGeometry(0.2,8),new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0.2}));playerShadow.rotation.x=-Math.PI/2;playerShadow.position.y=0.02;playerGroup.add(playerShadow);

        let playerTileX=40,playerTileZ=38,playerWorldX=40,playerWorldZ=38;
        playerGroup.position.set(40,heightMap[40][38],38);scene.add(playerGroup);

        // Tile highlight
        const highlightMat=new THREE.MeshBasicMaterial({color:0xffff00,transparent:true,opacity:0.3});
        const highlight=new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE,0.02,TILE_SIZE),highlightMat);highlight.visible=false;scene.add(highlight);

        // ============================================================
        // === PATHFINDING ===
        // ============================================================
        function findPath(sx,sz,ex,ez){if(ex<0||ex>=MAP_SIZE||ez<0||ez>=MAP_SIZE||grid[ex][ez]===0)return[];const open=[],closed=new Set(),cf={};function k(x,z){return x+','+z;}function h(x,z){return Math.abs(x-ex)+Math.abs(z-ez);}open.push({x:sx,z:sz,g:0,f:h(sx,sz)});while(open.length>0){open.sort((a,b)=>a.f-b.f);const c=open.shift(),ck=k(c.x,c.z);if(c.x===ex&&c.z===ez){const p=[];let kk=ck;while(kk){const[px,pz]=kk.split(',').map(Number);p.unshift({x:px,z:pz});kk=cf[kk];}return p;}closed.add(ck);for(const n of[{x:c.x+1,z:c.z},{x:c.x-1,z:c.z},{x:c.x,z:c.z+1},{x:c.x,z:c.z-1}]){if(n.x<0||n.x>=MAP_SIZE||n.z<0||n.z>=MAP_SIZE||grid[n.x][n.z]===0)continue;const nk=k(n.x,n.z);if(closed.has(nk))continue;const g=c.g+1;const ex2=open.find(o=>k(o.x,o.z)===nk);if(ex2&&g>=ex2.g)continue;cf[nk]=ck;if(ex2){ex2.g=g;ex2.f=g+h(n.x,n.z);}else open.push({x:n.x,z:n.z,g,f:g+h(n.x,n.z)});}}return[];}

        // Player movement
        let currentPath=[],pathIndex=0,isMoving=false,moveProgress=0,moveFromX,moveFromZ,moveToX,moveToZ,walkCycle=0;
        function startMoveTo(path){if(path.length<2)return;currentPath=path;pathIndex=1;isMoving=true;moveProgress=0;moveFromX=currentPath[0].x;moveFromZ=currentPath[0].z;moveToX=currentPath[1].x;moveToZ=currentPath[1].z;}

        // ============================================================
        // === NPC SYSTEM ===
        // ============================================================
        const npcRegistry = new Map();
        const npcLabelContainer = document.getElementById('npc-labels');
        let pathfindingQueue = [];

        function createNPCCharacter(agentData) {
            const role=agentData.role||'app_builder';const roleInfo=ROLE_COLORS[role]||ROLE_COLORS.app_builder;const scale=0.85;
            const group=new THREE.Group();group.scale.set(scale,scale,scale);
            const npcBody=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.5,0.2),new THREE.MeshLambertMaterial({color:roleInfo.int}));npcBody.position.y=0.5;npcBody.castShadow=true;group.add(npcBody);
            const npcHead=new THREE.Mesh(new THREE.BoxGeometry(0.25,0.25,0.25),new THREE.MeshLambertMaterial({color:0xffcc99}));npcHead.position.y=0.9;npcHead.castShadow=true;group.add(npcHead);
            const lGeo=new THREE.BoxGeometry(0.1,0.3,0.15),lMat=new THREE.MeshLambertMaterial({color:0x444444});
            const npcLL=new THREE.Mesh(lGeo,lMat);npcLL.position.set(-0.08,0.15,0);group.add(npcLL);
            const npcRL=new THREE.Mesh(lGeo,lMat);npcRL.position.set(0.08,0.15,0);group.add(npcRL);
            const aGeo=new THREE.BoxGeometry(0.08,0.35,0.1),aMat=new THREE.MeshLambertMaterial({color:roleInfo.int});
            const npcLA=new THREE.Mesh(aGeo,aMat);npcLA.position.set(-0.22,0.5,0);group.add(npcLA);
            const npcRA=new THREE.Mesh(aGeo,aMat);npcRA.position.set(0.22,0.5,0);group.add(npcRA);
            const npcShadow=new THREE.Mesh(new THREE.CircleGeometry(0.18,8),new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0.15}));npcShadow.rotation.x=-Math.PI/2;npcShadow.position.y=0.02;group.add(npcShadow);
            group.traverse(c=>{if(c.isMesh){c.userData.npcId=agentData.id;c.userData.type='npc';}});
            let startX,startZ;for(let a=0;a<50;a++){startX=22+Math.floor(Math.random()*36);startZ=22+Math.floor(Math.random()*31);if(startX<MAP_SIZE&&startZ<MAP_SIZE&&grid[startX][startZ]>0)break;}
            group.position.set(startX,heightMap[startX][startZ],startZ);scene.add(group);
            const label=document.createElement('div');label.className='npc-label';label.textContent=agentData.display_name||agentData.agent_name||agentData.id;label.style.borderBottom=`2px solid ${roleInfo.hex}`;npcLabelContainer.appendChild(label);
            const combatDef = NPC_COMBAT_STATS[role] || NPC_COMBAT_STATS.app_builder;
            const npc={id:agentData.id,group,data:agentData,role,roleInfo,label,body:npcBody,leftLeg:npcLL,rightLeg:npcRL,leftArm:npcLA,rightArm:npcRA,tileX:startX,tileZ:startZ,worldX:startX,worldZ:startZ,state:'IDLE',stateTimer:3+Math.random()*5,targetBuilding:null,path:[],pathIndex:0,moveProgress:0,moveFromX:0,moveFromZ:0,moveToX:0,moveToZ:0,walkCycle:Math.random()*Math.PI*2,workTimer:0,
                // Combat
                hp:combatDef.hp,maxHp:combatDef.hp,combatStats:combatDef,inCombat:false,combatTimer:0,isDead:false,respawnTimer:0,spawnX:startX,spawnZ:startZ,
            };
            npcRegistry.set(agentData.id,npc);return npc;
        }
        function despawnNPC(id){const npc=npcRegistry.get(id);if(!npc)return;scene.remove(npc.group);npc.label.remove();npcRegistry.delete(id);}

        // NPC Behavior AI
        function chooseTargetBuilding(npc){const w=ROLE_BUILDING_WEIGHTS[npc.role]||ROLE_BUILDING_WEIGHTS.app_builder;const e=Object.entries(w);const t=e.reduce((s,[,w])=>s+w,0);let r=Math.random()*t;for(const[id,wt]of e){r-=wt;if(r<=0)return id;}return e[0][0];}

        function updateNPCState(npc,dt){
            if(npc.isDead){npc.respawnTimer-=dt;if(npc.respawnTimer<=0){npc.isDead=false;npc.hp=npc.maxHp;npc.group.visible=true;npc.label.style.display='';npc.group.position.set(npc.spawnX,heightMap[npc.spawnX][npc.spawnZ],npc.spawnZ);npc.tileX=npc.spawnX;npc.tileZ=npc.spawnZ;npc.worldX=npc.spawnX;npc.worldZ=npc.spawnZ;npc.state='IDLE';npc.stateTimer=5;npc.inCombat=false;}return;}
            if(npc.inCombat)return; // combat handled separately
            switch(npc.state){
                case'IDLE':npc.stateTimer-=dt;npc.body.position.y=0.5+Math.sin(Date.now()*0.003+npc.walkCycle)*0.01;if(npc.stateTimer<=0)npc.state='CHOOSING';break;
                case'CHOOSING':{const tid=chooseTargetBuilding(npc);npc.targetBuilding=tid;const door=buildingDoors[tid];if(door)pathfindingQueue.push({npc,targetX:door.x,targetZ:door.z});npc.state='WAITING_PATH';npc.stateTimer=10;break;}
                case'WAITING_PATH':npc.stateTimer-=dt;if(npc.path.length>1){npc.state='WALKING';npc.pathIndex=1;npc.moveProgress=0;npc.moveFromX=npc.path[0].x;npc.moveFromZ=npc.path[0].z;npc.moveToX=npc.path[1].x;npc.moveToZ=npc.path[1].z;const bd=BUILDINGS.find(b=>b.id===npc.targetBuilding);const nm=npc.data.display_name||npc.data.agent_name||npc.id;addChatMessage('system',`${nm} is heading to the ${bd?bd.name:'unknown'}`,null,npc.roleInfo.hex);}else if(npc.stateTimer<=0){npc.state='IDLE';npc.stateTimer=3+Math.random()*5;}break;
                case'WALKING':npc.moveProgress+=dt*NPC_MOVE_SPEED;npc.walkCycle+=dt*10;const ls=Math.sin(npc.walkCycle)*0.3;npc.leftLeg.rotation.x=ls;npc.rightLeg.rotation.x=-ls;npc.leftArm.rotation.x=-ls*0.6;npc.rightArm.rotation.x=ls*0.6;npc.body.position.y=0.5+Math.abs(Math.sin(npc.walkCycle))*0.03;if(npc.moveProgress>=1){npc.moveProgress=0;npc.tileX=npc.moveToX;npc.tileZ=npc.moveToZ;npc.worldX=npc.moveToX;npc.worldZ=npc.moveToZ;npc.pathIndex++;if(npc.pathIndex<npc.path.length){npc.moveFromX=npc.moveToX;npc.moveFromZ=npc.moveToZ;npc.moveToX=npc.path[npc.pathIndex].x;npc.moveToZ=npc.path[npc.pathIndex].z;}else{npc.state='WORKING';npc.workTimer=5+Math.random()*10;npc.path=[];npc.leftLeg.rotation.x=0;npc.rightLeg.rotation.x=0;npc.leftArm.rotation.x=0;npc.rightArm.rotation.x=0;npc.body.position.y=0.5;const bd=BUILDINGS.find(b=>b.id===npc.targetBuilding);if(bd){npc.group.rotation.y=Math.atan2(bd.x-npc.tileX,bd.z-npc.tileZ);}const nm=npc.data.display_name||npc.data.agent_name||npc.id;addChatMessage('system',`${nm} is working at the ${bd?bd.name:'unknown'}`,null,npc.roleInfo.hex);}}if(npc.state==='WALKING'){const lx=npc.moveFromX+(npc.moveToX-npc.moveFromX)*npc.moveProgress;const lz=npc.moveFromZ+(npc.moveToZ-npc.moveFromZ)*npc.moveProgress;npc.worldX=lx;npc.worldZ=lz;const fh=heightMap[npc.moveFromX]?heightMap[npc.moveFromX][npc.moveFromZ]||0:0;const th=heightMap[npc.moveToX]?heightMap[npc.moveToX][npc.moveToZ]||0:0;npc.group.position.set(lx,fh+(th-fh)*npc.moveProgress,lz);npc.group.rotation.y=Math.atan2(npc.moveToX-npc.moveFromX,npc.moveToZ-npc.moveFromZ);}break;
                case'WORKING':npc.workTimer-=dt;npc.rightArm.rotation.x=Math.sin(Date.now()*0.005)*0.2;npc.body.position.y=0.5+Math.sin(Date.now()*0.004)*0.008;if(npc.workTimer<=0){npc.state='IDLE';npc.stateTimer=3+Math.random()*5;npc.rightArm.rotation.x=0;}break;
            }
        }
        function processPathfindingQueue(){let p=0;while(pathfindingQueue.length>0&&p<4){const r=pathfindingQueue.shift();if(r.npc) r.npc.path=findPath(r.npc.tileX,r.npc.tileZ,r.targetX,r.targetZ);else if(r.monster) r.monster.path=findPath(r.monster.tileX,r.monster.tileZ,r.targetX,r.targetZ);p++;}}

        // ============================================================
        // === MONSTER SYSTEM ===
        // ============================================================
        const monsterRegistry = new Map();
        const monsterLabelContainer = document.getElementById('npc-labels');
        let monsterCombatTarget = null;
        let monsterCombatTimer = 0;

        function createMonsterCharacter(monsterDef, spawnX, spawnZ) {
            const tz = monsterDef.zone;
            const isBoss = !!monsterDef.abilities;
            const scale = isBoss ? 1.3 : 0.9;
            const group = new THREE.Group();
            group.scale.set(scale, scale, scale);

            // Body ‚Äî larger, zone-colored
            const bodyColor = parseInt(monsterDef.color.replace('#',''), 16) || 0x666666;
            const mBody = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.55, 0.25), new THREE.MeshLambertMaterial({color: bodyColor}));
            mBody.position.y = 0.5; mBody.castShadow = true; group.add(mBody);

            // Head ‚Äî different shape per zone
            let mHead;
            if (tz === 'the_forest') {
                mHead = new THREE.Mesh(new THREE.SphereGeometry(0.18, 6, 6), new THREE.MeshLambertMaterial({color: bodyColor}));
            } else if (tz === 'the_ruins') {
                mHead = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.22, 0.22), new THREE.MeshLambertMaterial({color: bodyColor}));
            } else {
                mHead = new THREE.Mesh(new THREE.OctahedronGeometry(0.18, 0), new THREE.MeshLambertMaterial({color: bodyColor}));
            }
            mHead.position.y = 0.95; mHead.castShadow = true; group.add(mHead);

            // Eyes ‚Äî red glow
            const eyeMat = new THREE.MeshBasicMaterial({color: monsterDef.aggressive ? 0xff0000 : 0xffaa00});
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 4, 4), eyeMat);
            eye1.position.set(-0.06, 0.95, 0.15); group.add(eye1);
            const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 4, 4), eyeMat);
            eye2.position.set(0.06, 0.95, 0.15); group.add(eye2);

            // Boss glow
            if (isBoss) {
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), new THREE.MeshBasicMaterial({color: bodyColor, transparent: true, opacity: 0.12}));
                glow.position.y = 0.6; group.add(glow);
            }

            // Shadow
            const mShadow = new THREE.Mesh(new THREE.CircleGeometry(0.2, 8), new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.15}));
            mShadow.rotation.x = -Math.PI/2; mShadow.position.y = 0.02; group.add(mShadow);

            group.traverse(c => { if (c.isMesh) { c.userData.monsterId = monsterDef.id + '_' + spawnX + '_' + spawnZ; c.userData.type = 'monster'; }});

            const h = (spawnX < MAP_SIZE && spawnZ < MAP_SIZE) ? heightMap[spawnX][spawnZ] : 0;
            group.position.set(spawnX, h, spawnZ);
            scene.add(group);

            // Label
            const label = document.createElement('div');
            label.className = 'monster-label';
            label.textContent = `${monsterDef.name} (Lv.${monsterDef.level})`;
            monsterLabelContainer.appendChild(label);

            const id = monsterDef.id + '_' + spawnX + '_' + spawnZ;
            const monster = {
                id, defId: monsterDef.id, group, def: monsterDef, label, body: mBody,
                tileX: spawnX, tileZ: spawnZ, worldX: spawnX, worldZ: spawnZ,
                spawnX, spawnZ, isBoss,
                hp: monsterDef.hp, maxHp: monsterDef.hp,
                state: 'IDLE', stateTimer: 2 + Math.random() * 5,
                path: [], pathIndex: 0, moveProgress: 0,
                moveFromX: 0, moveFromZ: 0, moveToX: 0, moveToZ: 0,
                walkCycle: Math.random() * Math.PI * 2,
                inCombat: false, combatTimer: 0, isDead: false, respawnTimer: 0,
                aggroTarget: null, enraged: false,
            };
            monsterRegistry.set(id, monster);
            return monster;
        }

        function spawnMonsters() {
            // Spawn regular monsters
            Object.values(MONSTERS).forEach(mDef => {
                const zone = ZONES[mDef.zone];
                if (!zone) return;
                for (let i = 0; i < mDef.spawnCount; i++) {
                    let x, z, attempts = 0;
                    do {
                        x = zone.bounds.x1 + Math.floor(rng() * (zone.bounds.x2 - zone.bounds.x1));
                        z = zone.bounds.z1 + Math.floor(rng() * (zone.bounds.z2 - zone.bounds.z1));
                        attempts++;
                    } while (attempts < 30 && (x >= MAP_SIZE || z >= MAP_SIZE || grid[x][z] <= 0 || isInBuildingZone(x, z)));
                    if (x < MAP_SIZE && z < MAP_SIZE && grid[x][z] > 0) {
                        createMonsterCharacter(mDef, x, z);
                    }
                }
            });
            // Spawn bosses
            Object.values(BOSSES).forEach(bDef => {
                const sp = bDef.spawnPos;
                if (sp.x < MAP_SIZE && sp.z < MAP_SIZE) {
                    createMonsterCharacter(bDef, sp.x, sp.z);
                }
            });
        }
        spawnMonsters();

        function updateMonsterState(monster, dt) {
            if (monster.isDead) {
                monster.respawnTimer -= dt;
                if (monster.respawnTimer <= 0) {
                    monster.isDead = false;
                    monster.hp = monster.maxHp;
                    monster.enraged = false;
                    monster.group.visible = true;
                    monster.label.style.display = '';
                    monster.group.position.set(monster.spawnX, heightMap[monster.spawnX][monster.spawnZ], monster.spawnZ);
                    monster.tileX = monster.spawnX; monster.tileZ = monster.spawnZ;
                    monster.worldX = monster.spawnX; monster.worldZ = monster.spawnZ;
                    monster.group.rotation.z = 0;
                    monster.state = 'IDLE'; monster.stateTimer = 3;
                    monster.inCombat = false;
                }
                return;
            }
            if (monster.inCombat) return;

            const distToPlayer = Math.abs(monster.worldX - playerWorldX) + Math.abs(monster.worldZ - playerWorldZ);
            const aggroRange = monster.isBoss ? BOSS_AGGRO_RANGE : MONSTER_AGGRO_RANGE;

            switch (monster.state) {
                case 'IDLE':
                    monster.stateTimer -= dt;
                    monster.body.position.y = 0.5 + Math.sin(Date.now() * 0.003 + monster.walkCycle) * 0.015;
                    // Check aggro
                    if (monster.def.aggressive && distToPlayer <= aggroRange && !playerDead) {
                        monster.state = 'AGGRO';
                        break;
                    }
                    if (monster.stateTimer <= 0) {
                        monster.state = 'PATROL';
                    }
                    break;

                case 'PATROL': {
                    // Random walk within 5 tiles of spawn
                    const dx = Math.floor(rng() * 11) - 5;
                    const dz = Math.floor(rng() * 11) - 5;
                    let tx = Math.max(0, Math.min(MAP_SIZE - 1, monster.spawnX + dx));
                    let tz = Math.max(0, Math.min(MAP_SIZE - 1, monster.spawnZ + dz));
                    if (grid[tx][tz] > 0) {
                        pathfindingQueue.push({monster, targetX: tx, targetZ: tz});
                    }
                    monster.state = 'WAITING_PATH';
                    monster.stateTimer = 8;
                    break;
                }

                case 'WAITING_PATH':
                    monster.stateTimer -= dt;
                    if (monster.path.length > 1) {
                        monster.state = 'WALKING';
                        monster.pathIndex = 1;
                        monster.moveProgress = 0;
                        monster.moveFromX = monster.path[0].x; monster.moveFromZ = monster.path[0].z;
                        monster.moveToX = monster.path[1].x; monster.moveToZ = monster.path[1].z;
                    } else if (monster.stateTimer <= 0) {
                        monster.state = 'IDLE';
                        monster.stateTimer = 3 + Math.random() * 5;
                    }
                    // Check aggro while waiting
                    if (monster.def.aggressive && distToPlayer <= aggroRange && !playerDead) {
                        monster.state = 'AGGRO'; monster.path = [];
                    }
                    break;

                case 'WALKING':
                    monster.moveProgress += dt * MONSTER_MOVE_SPEED;
                    monster.walkCycle += dt * 8;
                    monster.body.position.y = 0.5 + Math.abs(Math.sin(monster.walkCycle)) * 0.04;
                    if (monster.moveProgress >= 1) {
                        monster.moveProgress = 0;
                        monster.tileX = monster.moveToX; monster.tileZ = monster.moveToZ;
                        monster.worldX = monster.moveToX; monster.worldZ = monster.moveToZ;
                        monster.pathIndex++;
                        if (monster.pathIndex < monster.path.length) {
                            monster.moveFromX = monster.moveToX; monster.moveFromZ = monster.moveToZ;
                            monster.moveToX = monster.path[monster.pathIndex].x;
                            monster.moveToZ = monster.path[monster.pathIndex].z;
                        } else {
                            monster.state = 'IDLE';
                            monster.stateTimer = 3 + Math.random() * 5;
                            monster.path = [];
                            monster.body.position.y = 0.5;
                        }
                    }
                    if (monster.state === 'WALKING') {
                        const lx = monster.moveFromX + (monster.moveToX - monster.moveFromX) * monster.moveProgress;
                        const lz = monster.moveFromZ + (monster.moveToZ - monster.moveFromZ) * monster.moveProgress;
                        monster.worldX = lx; monster.worldZ = lz;
                        const fh = heightMap[monster.moveFromX] ? heightMap[monster.moveFromX][monster.moveFromZ] || 0 : 0;
                        const th = heightMap[monster.moveToX] ? heightMap[monster.moveToX][monster.moveToZ] || 0 : 0;
                        monster.group.position.set(lx, fh + (th - fh) * monster.moveProgress, lz);
                        monster.group.rotation.y = Math.atan2(monster.moveToX - monster.moveFromX, monster.moveToZ - monster.moveFromZ);
                    }
                    // Check aggro while walking
                    if (monster.def.aggressive && distToPlayer <= aggroRange && !playerDead) {
                        monster.state = 'AGGRO'; monster.path = [];
                    }
                    break;

                case 'AGGRO': {
                    // Chase player
                    const leashDist = Math.abs(monster.worldX - monster.spawnX) + Math.abs(monster.worldZ - monster.spawnZ);
                    if (leashDist > MONSTER_LEASH_RANGE || playerDead) {
                        monster.state = 'LEASHING';
                        monster.path = [];
                        break;
                    }
                    if (distToPlayer <= 1.5) {
                        // Close enough ‚Äî engage combat
                        startMonsterCombat(monster);
                    } else {
                        // Path towards player
                        if (monster.path.length <= 1) {
                            const adj = findAdjacentWalkable(playerTileX, playerTileZ);
                            if (adj) pathfindingQueue.push({monster, targetX: adj.x, targetZ: adj.z});
                            monster.stateTimer = 2;
                        }
                        // Follow path
                        if (monster.path.length > 1 && monster.pathIndex < monster.path.length) {
                            monster.moveProgress += dt * MONSTER_MOVE_SPEED * 1.3;
                            monster.walkCycle += dt * 10;
                            monster.body.position.y = 0.5 + Math.abs(Math.sin(monster.walkCycle)) * 0.05;
                            if (monster.moveProgress >= 1) {
                                monster.moveProgress = 0;
                                monster.tileX = monster.moveToX; monster.tileZ = monster.moveToZ;
                                monster.worldX = monster.moveToX; monster.worldZ = monster.moveToZ;
                                monster.pathIndex++;
                                if (monster.pathIndex < monster.path.length) {
                                    monster.moveFromX = monster.moveToX; monster.moveFromZ = monster.moveToZ;
                                    monster.moveToX = monster.path[monster.pathIndex].x;
                                    monster.moveToZ = monster.path[monster.pathIndex].z;
                                } else {
                                    monster.path = [];
                                }
                            }
                            if (monster.path.length > 1 && monster.pathIndex < monster.path.length) {
                                const lx = monster.moveFromX + (monster.moveToX - monster.moveFromX) * monster.moveProgress;
                                const lz = monster.moveFromZ + (monster.moveToZ - monster.moveFromZ) * monster.moveProgress;
                                monster.worldX = lx; monster.worldZ = lz;
                                const fh = heightMap[monster.moveFromX] ? heightMap[monster.moveFromX][monster.moveFromZ] || 0 : 0;
                                const th = heightMap[monster.moveToX] ? heightMap[monster.moveToX][monster.moveToZ] || 0 : 0;
                                monster.group.position.set(lx, fh + (th - fh) * monster.moveProgress, lz);
                                monster.group.rotation.y = Math.atan2(monster.moveToX - monster.moveFromX, monster.moveToZ - monster.moveFromZ);
                            }
                        }
                        monster.stateTimer -= dt;
                        if (monster.stateTimer <= 0) { monster.path = []; monster.stateTimer = 2; }
                    }
                    break;
                }

                case 'LEASHING':
                    // Return to spawn
                    if (monster.path.length <= 1) {
                        pathfindingQueue.push({monster, targetX: monster.spawnX, targetZ: monster.spawnZ});
                        monster.stateTimer = 10;
                    }
                    if (monster.path.length > 1 && monster.pathIndex < monster.path.length) {
                        monster.moveProgress += dt * MONSTER_MOVE_SPEED;
                        if (monster.moveProgress >= 1) {
                            monster.moveProgress = 0;
                            monster.tileX = monster.moveToX; monster.tileZ = monster.moveToZ;
                            monster.worldX = monster.moveToX; monster.worldZ = monster.moveToZ;
                            monster.pathIndex++;
                            if (monster.pathIndex < monster.path.length) {
                                monster.moveFromX = monster.moveToX; monster.moveFromZ = monster.moveToZ;
                                monster.moveToX = monster.path[monster.pathIndex].x;
                                monster.moveToZ = monster.path[monster.pathIndex].z;
                            } else {
                                monster.state = 'IDLE'; monster.stateTimer = 5; monster.path = [];
                                monster.hp = monster.maxHp; // heal on leash
                            }
                        }
                        if (monster.path.length > 1 && monster.pathIndex < monster.path.length) {
                            const lx = monster.moveFromX + (monster.moveToX - monster.moveFromX) * monster.moveProgress;
                            const lz = monster.moveFromZ + (monster.moveToZ - monster.moveFromZ) * monster.moveProgress;
                            monster.worldX = lx; monster.worldZ = lz;
                            const fh = heightMap[monster.moveFromX] ? heightMap[monster.moveFromX][monster.moveFromZ] || 0 : 0;
                            const th = heightMap[monster.moveToX] ? heightMap[monster.moveToX][monster.moveToZ] || 0 : 0;
                            monster.group.position.set(lx, fh + (th - fh) * monster.moveProgress, lz);
                        }
                    }
                    monster.stateTimer -= dt;
                    if (monster.stateTimer <= 0) {
                        monster.state = 'IDLE'; monster.stateTimer = 5; monster.path = [];
                        monster.hp = monster.maxHp;
                        monster.group.position.set(monster.spawnX, heightMap[monster.spawnX][monster.spawnZ], monster.spawnZ);
                        monster.tileX = monster.spawnX; monster.tileZ = monster.spawnZ;
                        monster.worldX = monster.spawnX; monster.worldZ = monster.spawnZ;
                    }
                    break;
            }
        }

        // ============================================================
        // === COMBAT SYSTEM ===
        // ============================================================
        let combatTarget = null;
        let combatTimer = 0;
        let playerDead = false;

        window.toggleAttackMode = function() {
            attackMode = !attackMode;
            document.getElementById('btnAttackMode').classList.toggle('active', attackMode);
        };

        function startCombat(npc) {
            if (npc.isDead || npc.inCombat || playerDead) return;
            // Walk to adjacent tile first
            const adj = findAdjacentWalkable(npc.tileX, npc.tileZ);
            if (!adj) { addChatMessage('combat', "Can't reach that agent!"); return; }
            const dist = Math.abs(playerTileX - npc.tileX) + Math.abs(playerTileZ - npc.tileZ);
            if (dist <= 1) {
                engageCombat(npc);
            } else {
                const path = findPath(playerTileX, playerTileZ, adj.x, adj.z);
                if (path.length > 1) {
                    startMoveTo(path);
                    combatTarget = npc;
                }
            }
        }

        function findAdjacentWalkable(tx, tz) {
            for (const [dx,dz] of [[0,1],[0,-1],[1,0],[-1,0]]) {
                const nx=tx+dx, nz=tz+dz;
                if (nx>=0&&nx<MAP_SIZE&&nz>=0&&nz<MAP_SIZE&&grid[nx][nz]>0) return {x:nx,z:nz};
            }
            return null;
        }

        function engageCombat(npc) {
            combatTarget = npc;
            npc.inCombat = true;
            combatTimer = 0;
            npc.state = 'IDLE';
            npc.path = [];
            // Face each other
            const angle = Math.atan2(npc.worldX - playerWorldX, npc.worldZ - playerWorldZ);
            playerGroup.rotation.y = angle;
            npc.group.rotation.y = angle + Math.PI;
            addChatMessage('combat', `You attack ${npc.data.display_name || npc.id}!`);
        }

        function updateCombat(dt) {
            if (!combatTarget || playerDead) return;
            if (combatTarget.isDead) { combatTarget = null; return; }

            // Check if close enough
            const dist = Math.abs(playerTileX - combatTarget.tileX) + Math.abs(playerTileZ - combatTarget.tileZ);
            if (dist > 2) { combatTarget.inCombat = false; combatTarget = null; return; }

            combatTimer += dt;
            if (combatTimer >= COMBAT_TICK) {
                combatTimer -= COMBAT_TICK;

                // Player attacks NPC
                const wep = playerStats.equippedWeapon;
                const pAtk = playerStats.attack + (wep ? wep.stats.attack : 0);
                const pStr = playerStats.strength + (wep ? wep.stats.strength : 0);
                const nDef = combatTarget.combatStats.defence;

                // Accuracy roll ‚Äî spec guarantees hit and 1.5x max damage
                const isSpec = specActive;
                specActive = false;
                if (isSpec || Math.random() * (pAtk + 1) > Math.random() * (nDef + 1)) {
                    let dmg;
                    if (isSpec) {
                        dmg = Math.max(1, Math.floor((pStr + 1) * 1.5));
                        playerStats.energy = Math.min(playerStats.maxEnergy, playerStats.energy + 5);
                    } else {
                        dmg = Math.max(1, Math.floor(Math.random() * (pStr + 1)));
                    }
                    combatTarget.hp -= dmg;
                    showHitsplat(combatTarget.worldX, combatTarget.worldZ, dmg, false, isSpec);
                    addChatMessage('combat', `You ${isSpec ? 'SPEC' : 'hit'} ${combatTarget.data.display_name || combatTarget.id} for ${dmg} damage${isSpec ? '!' : '.'}`);
                    rightArm.rotation.x = -0.8;
                    setTimeout(() => { rightArm.rotation.x = 0; }, 200);
                } else {
                    showHitsplat(combatTarget.worldX, combatTarget.worldZ, 0, true);
                    addChatMessage('combat', `You miss!`);
                }

                // NPC attacks player
                const nAtk = combatTarget.combatStats.attack;
                const nStr = combatTarget.combatStats.strength;
                const helmDef = playerStats.equippedHelm ? playerStats.equippedHelm.stats.defence : 0;
                const shieldDef = playerStats.equippedShield ? playerStats.equippedShield.stats.defence : 0;
                const pDef = playerStats.defence + helmDef + shieldDef;

                if (Math.random() * (nAtk + 1) > Math.random() * (pDef + 1)) {
                    const dmg = Math.max(1, Math.floor(Math.random() * (nStr + 1)));
                    playerStats.hp -= dmg;
                    showHitsplat(playerWorldX, playerWorldZ, dmg, false);
                    addChatMessage('combat', `${combatTarget.data.display_name || combatTarget.id} hits you for ${dmg}.`);
                    updateOrbs();
                } else {
                    showHitsplat(playerWorldX, playerWorldZ, 0, true);
                }

                // Check deaths
                if (combatTarget.hp <= 0) {
                    onNPCDeath(combatTarget);
                }
                if (playerStats.hp <= 0) {
                    onPlayerDeath();
                }

                // XP gain - scales with enemy combat level
                if (combatTarget && !combatTarget.isDead) {
                    const cs = combatTarget.combatStats;
                    const enemyLvl = Math.floor((cs.attack + cs.strength + cs.defence) / 3) + 1;
                    const xpGain = enemyLvl * 2;
                    gainXP('attack', xpGain);
                    gainXP('strength', xpGain);
                    gainXP('hitpoints', Math.ceil(xpGain * 0.7));
                }
            }
        }

        function showHitsplat(wx, wz, dmg, miss, isSpec) {
            const el = document.createElement('div');
            el.className = 'hitsplat' + (miss ? ' miss' : '') + (isSpec ? ' spec' : '');
            el.textContent = miss ? '0' : dmg;
            el.dataset.worldX = wx;
            el.dataset.worldZ = wz;
            document.getElementById('chat-bubbles').appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // Special attack
        let specActive = false;
        function useSpecialAttack() {
            if (!combatTarget || playerDead) { addChatMessage('system', 'You need a combat target!'); return; }
            if (playerStats.energy < 25) { addChatMessage('system', 'Not enough special attack energy!'); return; }
            specActive = true;
            playerStats.energy -= 25;
            updateOrbs();
            addChatMessage('combat', 'You unleash a special attack!');
        }
        window.useSpecialAttack = useSpecialAttack;

        // Energy regen in game loop (1/tick passively)
        let energyRegenTimer = 0;
        function updateEnergyRegen(dt) {
            energyRegenTimer += dt;
            if (energyRegenTimer >= COMBAT_TICK) {
                energyRegenTimer -= COMBAT_TICK;
                if (playerStats.energy < playerStats.maxEnergy) {
                    playerStats.energy = Math.min(playerStats.maxEnergy, playerStats.energy + 1);
                    updateOrbs();
                }
            }
        }

        const lootPiles = [];

        function onNPCDeath(npc) {
            const name = npc.data.display_name || npc.id;
            addChatMessage('combat', `You defeated ${name}!`);
            npc.inCombat = false;
            combatTarget = null;

            // XP reward scaled by enemy
            const cs = npc.combatStats;
            const enemyLvl = Math.floor((cs.attack + cs.strength + cs.defence) / 3) + 1;
            const xpReward = enemyLvl * 2;
            gainXP('attack', xpReward);
            gainXP('strength', xpReward);
            gainXP('hitpoints', Math.ceil(xpReward * 0.7));

            // Quest progress
            checkQuestProgress('kill', { role: npc.role, x: npc.worldX, z: npc.worldZ });

            // Death animation: tilt and sink
            const deathX = npc.worldX, deathZ = npc.worldZ;
            let deathAnim = 0;
            npc.deathAnim = { progress: 0, x: deathX, z: deathZ };

            const animateDeath = () => {
                npc.deathAnim.progress += 0.02;
                const p = npc.deathAnim.progress;
                npc.group.rotation.z = Math.min(Math.PI / 2, p * Math.PI / 2);
                npc.group.position.y -= 0.01;
                if (p < 1) requestAnimationFrame(animateDeath);
                else {
                    npc.isDead = true;
                    npc.respawnTimer = 30;
                    npc.group.visible = false;
                    npc.label.style.display = 'none';
                    npc.group.rotation.z = 0;
                    // Create loot pile
                    createLootPile(deathX, deathZ, npc.combatStats.drops || []);
                }
            };
            requestAnimationFrame(animateDeath);
        }

        function createLootPile(wx, wz, dropIds) {
            const items = [];
            dropIds.forEach(itemId => {
                const qty = itemId === 'coins' ? 5 + Math.floor(Math.random() * 20) : 1;
                items.push({ id: itemId, qty });
            });
            if (items.length === 0) return;
            const pile = { x: wx, z: wz, items, timer: 60 };
            lootPiles.push(pile);
            addChatMessage('system', `A loot pile appears on the ground.`);
        }

        function pickupLootPile(index) {
            const pile = lootPiles[index];
            if (!pile) return;
            const dist = Math.abs(playerWorldX - pile.x) + Math.abs(playerWorldZ - pile.z);
            if (dist > 2) { addChatMessage('system', 'You need to get closer!'); return; }
            pile.items.forEach(li => {
                addToInventory(li.id, li.qty);
                const item = ITEMS[li.id];
                addChatMessage('system', `Loot: ${item.icon} ${li.qty}x ${item.name}`);
            });
            lootPiles.splice(index, 1);
        }
        window.pickupLootPile = pickupLootPile;

        // ============================================================
        // === MONSTER COMBAT ===
        // ============================================================
        function startMonsterCombat(monster) {
            if (monster.isDead || monster.inCombat || playerDead) return;
            const dist = Math.abs(playerTileX - monster.tileX) + Math.abs(playerTileZ - monster.tileZ);
            if (dist <= 1) {
                engageMonsterCombat(monster);
            } else {
                const adj = findAdjacentWalkable(monster.tileX, monster.tileZ);
                if (!adj) { addChatMessage('combat', "Can't reach that monster!"); return; }
                const path = findPath(playerTileX, playerTileZ, adj.x, adj.z);
                if (path.length > 1) {
                    startMoveTo(path);
                    monsterCombatTarget = monster;
                }
            }
        }

        function engageMonsterCombat(monster) {
            monsterCombatTarget = monster;
            monster.inCombat = true;
            monster.state = 'IDLE';
            monster.path = [];
            monsterCombatTimer = 0;
            const angle = Math.atan2(monster.worldX - playerWorldX, monster.worldZ - playerWorldZ);
            playerGroup.rotation.y = angle;
            monster.group.rotation.y = angle + Math.PI;
            addChatMessage('combat', `You attack ${monster.def.name} (Lv.${monster.def.level})!`);
        }

        function updateMonsterCombat(dt) {
            if (!monsterCombatTarget || playerDead) return;
            if (monsterCombatTarget.isDead) { monsterCombatTarget = null; return; }

            const dist = Math.abs(playerTileX - monsterCombatTarget.tileX) + Math.abs(playerTileZ - monsterCombatTarget.tileZ);
            if (dist > 2) {
                monsterCombatTarget.inCombat = false;
                monsterCombatTarget.state = monsterCombatTarget.def.aggressive ? 'AGGRO' : 'LEASHING';
                monsterCombatTarget = null;
                return;
            }

            monsterCombatTimer += dt;
            if (monsterCombatTimer >= COMBAT_TICK) {
                monsterCombatTimer -= COMBAT_TICK;
                const mDef = monsterCombatTarget.def;

                // Player attacks monster
                const wep = playerStats.equippedWeapon;
                const pAtk = playerStats.attack + (wep ? wep.stats.attack : 0);
                const pStr = playerStats.strength + (wep ? wep.stats.strength : 0);
                const mDefVal = mDef.defence * (monsterCombatTarget.enraged ? 0.7 : 1);

                const isSpec = specActive;
                specActive = false;
                if (isSpec || Math.random() * (pAtk + 1) > Math.random() * (mDefVal + 1)) {
                    let dmg;
                    if (isSpec) {
                        dmg = Math.max(1, Math.floor((pStr + 1) * 1.5));
                        playerStats.energy = Math.min(playerStats.maxEnergy, playerStats.energy + 5);
                    } else {
                        dmg = Math.max(1, Math.floor(Math.random() * (pStr + 1)));
                    }
                    monsterCombatTarget.hp -= dmg;
                    showHitsplat(monsterCombatTarget.worldX, monsterCombatTarget.worldZ, dmg, false, isSpec);
                    addChatMessage('combat', `You ${isSpec ? 'SPEC' : 'hit'} ${mDef.name} for ${dmg} damage${isSpec ? '!' : '.'}`);
                    rightArm.rotation.x = -0.8;
                    setTimeout(() => { rightArm.rotation.x = 0; }, 200);
                } else {
                    showHitsplat(monsterCombatTarget.worldX, monsterCombatTarget.worldZ, 0, true);
                    addChatMessage('combat', `You miss!`);
                }

                // Monster attacks player
                const mAtk = mDef.attack * (monsterCombatTarget.enraged ? 1.5 : 1);
                const mStr = mDef.strength * (monsterCombatTarget.enraged ? 1.3 : 1);
                const helmDef = playerStats.equippedHelm ? playerStats.equippedHelm.stats.defence : 0;
                const shieldDef = playerStats.equippedShield ? playerStats.equippedShield.stats.defence : 0;
                const pDef = playerStats.defence + helmDef + shieldDef;

                if (Math.random() * (mAtk + 1) > Math.random() * (pDef + 1)) {
                    const dmg = Math.max(1, Math.floor(Math.random() * (mStr + 1)));
                    playerStats.hp -= dmg;
                    showHitsplat(playerWorldX, playerWorldZ, dmg, false);
                    addChatMessage('combat', `${mDef.name} hits you for ${dmg}.`);
                    updateOrbs();
                } else {
                    showHitsplat(playerWorldX, playerWorldZ, 0, true);
                }

                // Boss enrage check
                if (monsterCombatTarget.isBoss && !monsterCombatTarget.enraged && monsterCombatTarget.hp < monsterCombatTarget.maxHp * 0.4) {
                    monsterCombatTarget.enraged = true;
                    addChatMessage('combat', `${mDef.name} becomes enraged!`);
                }

                // Boss ability ‚Äî heal at low hp
                if (monsterCombatTarget.isBoss && monsterCombatTarget.hp > 0) {
                    const abilities = mDef.abilities || [];
                    for (const ab of abilities) {
                        if (ab.type === 'heal' && ab.trigger && monsterCombatTarget.hp < monsterCombatTarget.maxHp * (ab.trigger / 100) && Math.random() < 0.15) {
                            monsterCombatTarget.hp = Math.min(monsterCombatTarget.maxHp, monsterCombatTarget.hp + ab.heal);
                            addChatMessage('combat', `${mDef.name} uses ${ab.name}! It heals ${ab.heal} HP!`);
                            break;
                        }
                        if (ab.type === 'aoe' && Math.random() < 0.1) {
                            const aoeDmg = ab.damage || 10;
                            playerStats.hp -= aoeDmg;
                            showHitsplat(playerWorldX, playerWorldZ, aoeDmg, false);
                            addChatMessage('combat', `${mDef.name} uses ${ab.name}! You take ${aoeDmg} damage!`);
                            updateOrbs();
                            break;
                        }
                    }
                }

                // XP while fighting
                if (monsterCombatTarget && !monsterCombatTarget.isDead) {
                    const xpGain = Math.max(1, Math.floor(mDef.level * 0.5));
                    gainXP('attack', xpGain);
                    gainXP('strength', xpGain);
                    gainXP('hitpoints', Math.ceil(xpGain * 0.5));
                }

                // Check deaths
                if (monsterCombatTarget && monsterCombatTarget.hp <= 0) {
                    onMonsterDeath(monsterCombatTarget);
                }
                if (playerStats.hp <= 0) {
                    onPlayerDeath();
                }
            }
        }

        function onMonsterDeath(monster) {
            const mDef = monster.def;
            addChatMessage('combat', `You defeated ${mDef.name}!`);
            monster.inCombat = false;
            monsterCombatTarget = null;

            // XP reward
            const xr = mDef.xpReward;
            if (xr) {
                if (xr.attack) gainXP('attack', xr.attack);
                if (xr.strength) gainXP('strength', xr.strength);
                if (xr.hitpoints) gainXP('hitpoints', xr.hitpoints);
                if (xr.defence) gainXP('defence', xr.defence);
            }

            // Quest progress
            if (monster.isBoss) {
                checkQuestProgress('kill_boss', { bossId: monster.defId });
            } else {
                checkQuestProgress('kill_monster', { monsterId: monster.defId });
            }

            // Generate loot
            const deathX = monster.worldX, deathZ = monster.worldZ;
            const lootItems = [];
            // Coin drop
            if (mDef.coinDrop) {
                const coins = mDef.coinDrop.min + Math.floor(Math.random() * (mDef.coinDrop.max - mDef.coinDrop.min));
                lootItems.push({id: 'coins', qty: coins});
            }
            // Item drops by weight
            if (mDef.drops) {
                const totalWeight = mDef.drops.reduce((s, d) => s + d.weight, 0);
                mDef.drops.forEach(drop => {
                    if (Math.random() * 100 < drop.weight) {
                        const qty = drop.minQty + Math.floor(Math.random() * (drop.maxQty - drop.minQty + 1));
                        lootItems.push({id: drop.id, qty});
                    }
                });
            }

            // Death animation
            let deathProgress = 0;
            const animateDeath = () => {
                deathProgress += 0.02;
                monster.group.rotation.z = Math.min(Math.PI / 2, deathProgress * Math.PI / 2);
                monster.group.position.y -= 0.01;
                if (deathProgress < 1) requestAnimationFrame(animateDeath);
                else {
                    monster.isDead = true;
                    monster.respawnTimer = monster.isBoss ? (mDef.isRaidBoss ? RAID_BOSS_RESPAWN_TIME : BOSS_RESPAWN_TIME) : (mDef.respawnTime || 30);
                    monster.group.visible = false;
                    monster.label.style.display = 'none';
                    monster.group.rotation.z = 0;
                    // Create loot pile
                    if (lootItems.length > 0) {
                        const pile = { x: deathX, z: deathZ, items: lootItems, timer: 60 };
                        lootPiles.push(pile);
                        addChatMessage('system', `A loot pile appears on the ground.`);
                    }
                }
            };
            requestAnimationFrame(animateDeath);
        }

        function onPlayerDeath() {
            playerDead = true;
            if (combatTarget) { combatTarget.inCombat = false; combatTarget = null; }
            addChatMessage('combat', 'Oh dear, you are dead!');
            document.getElementById('death-screen').style.display = 'flex';

            // Lose some food
            for (let i = 0; i < 28; i++) {
                if (inventory[i] && inventory[i].type === 'food') {
                    inventory[i] = null;
                }
            }
            renderInventory();

            setTimeout(() => {
                playerDead = false;
                playerStats.hp = playerStats.maxHp;
                // Respawn at Town Hall
                const th = buildingDoors['town_hall'];
                if (th) {
                    playerTileX = th.x; playerTileZ = th.z;
                    playerWorldX = th.x; playerWorldZ = th.z;
                    playerGroup.position.set(th.x, heightMap[th.x][th.z], th.z);
                }
                updateOrbs();
                document.getElementById('death-screen').style.display = 'none';
                addChatMessage('system', 'You respawn at Town Hall.');
            }, 3000);
        }

        // ============================================================
        // === SKILLING AT BUILDINGS ===
        // ============================================================
        let skillingAction = null; // { type, timer, maxTime, callback }
        let skillingCooldown = 0;

        function showFarmActions() {
            const area = document.getElementById('skill-action-area');
            area.innerHTML = `<button class="action-btn" onclick="startHarvest()">üåæ Harvest</button>`;
            addChatMessage('system', 'You arrive at the Farm. Click Harvest to gather food.');
        }

        function showArenaActions() {
            const area = document.getElementById('skill-action-area');
            area.innerHTML = `<button class="action-btn" onclick="startTraining()">üéØ Train</button>`;
            addChatMessage('system', 'You enter the Arena. Click Train to practice combat.');
        }

        window.startHarvest = function() {
            if (skillingAction || skillingCooldown > 0) { addChatMessage('system', 'Please wait...'); return; }
            addChatMessage('system', 'Harvesting...');
            skillingAction = { type: 'harvest', timer: 0, maxTime: 3, callback: () => {
                const foods = ['bread', 'raw_fish'];
                const item = foods[Math.floor(Math.random() * foods.length)];
                addToInventory(item, 1);
                addChatMessage('system', `You harvest some ${ITEMS[item].name}. ${ITEMS[item].icon}`);
                skillingCooldown = 10;
                clearSkillTimer();
            }};
            showSkillTimer(3);
        };

        window.startTraining = function() {
            if (skillingAction || skillingCooldown > 0) { addChatMessage('system', 'Please wait...'); return; }
            addChatMessage('system', 'Training on the dummy...');
            skillingAction = { type: 'train', timer: 0, maxTime: 5, callback: () => {
                gainXP('attack', 5);
                gainXP('strength', 5);
                gainXP('defence', 5);
                addChatMessage('system', 'You hit the training dummy. +5 XP to combat skills.');
                skillingCooldown = 5;
                clearSkillTimer();
            }};
            showSkillTimer(5);
        };

        function showSkillTimer(maxTime) {
            const area = document.getElementById('skill-action-area');
            area.innerHTML += `<div class="skill-timer"><div class="skill-timer-fill" id="skill-timer-fill" style="width:0%"></div></div>`;
        }

        function clearSkillTimer() {
            const fill = document.getElementById('skill-timer-fill');
            if (fill) fill.parentElement.remove();
            skillingAction = null;
        }

        function updateSkillingTimers(dt) {
            if (skillingCooldown > 0) skillingCooldown -= dt;
            if (skillingAction) {
                skillingAction.timer += dt;
                const pct = Math.min(100, (skillingAction.timer / skillingAction.maxTime) * 100);
                const fill = document.getElementById('skill-timer-fill');
                if (fill) fill.style.width = pct + '%';
                if (skillingAction.timer >= skillingAction.maxTime) {
                    skillingAction.callback();
                }
            }
        }

        // ============================================================
        // === WOODCUTTING ===
        // ============================================================
        let woodcuttingTarget = null; // treeId

        function getBestAxe() {
            let best = null;
            const wcLevel = playerStats.woodcutting || 1;
            for (let i = 0; i < 28; i++) {
                if (inventory[i] && inventory[i].type === 'axe') {
                    const axe = inventory[i];
                    if (wcLevel >= axe.wcLevel) {
                        if (!best || axe.speedMult < best.speedMult) best = axe;
                    }
                }
            }
            return best;
        }

        function hasAxeInInventory() {
            for (let i = 0; i < 28; i++) {
                if (inventory[i] && inventory[i].type === 'axe') return true;
            }
            return false;
        }

        function findAdjacentWalkable(tx, tz) {
            const dirs = [{x:0,z:1},{x:0,z:-1},{x:1,z:0},{x:-1,z:0}];
            for (const d of dirs) {
                const nx = tx + d.x, nz = tz + d.z;
                if (nx >= 0 && nx < MAP_SIZE && nz >= 0 && nz < MAP_SIZE && grid[nx][nz] > 0) return { x: nx, z: nz };
            }
            return null;
        }

        function startWoodcutting(treeId) {
            const tree = treeRegistry.get(treeId);
            if (!tree || tree.isDepleted) { addChatMessage('system', 'This tree has been chopped down.'); return; }
            if (!hasAxeInInventory()) { addChatMessage('system', 'You need an axe to chop this tree.'); return; }
            const tt = TREE_TYPES[tree.treeType];
            const wcLevel = playerStats.woodcutting || 1;
            if (wcLevel < tt.wcLevel) { addChatMessage('system', `You need level ${tt.wcLevel} Woodcutting to chop this tree.`); return; }

            // Find adjacent walkable tile
            const adj = findAdjacentWalkable(tree.x, tree.z);
            if (!adj) { addChatMessage('system', 'You can\'t reach this tree.'); return; }

            // Walk to tree
            const path = findPath(playerTileX, playerTileZ, adj.x, adj.z);
            if (path.length > 1) {
                woodcuttingTarget = treeId;
                stopWoodcutting(); // clear any current chop
                startMoveTo(path);
            } else if (Math.abs(playerTileX - tree.x) + Math.abs(playerTileZ - tree.z) <= 1) {
                // Already adjacent
                woodcuttingTarget = treeId;
                beginChopCycle();
            } else {
                addChatMessage('system', 'You can\'t reach this tree.');
            }
        }

        function beginChopCycle() {
            const tree = treeRegistry.get(woodcuttingTarget);
            if (!tree || tree.isDepleted) { stopWoodcutting(); return; }
            const tt = TREE_TYPES[tree.treeType];
            const wcLevel = playerStats.woodcutting || 1;
            if (wcLevel < tt.wcLevel) { stopWoodcutting(); return; }
            const axe = getBestAxe();
            if (!axe) { addChatMessage('system', 'You need an axe to chop trees.'); stopWoodcutting(); return; }

            // Face the tree
            const dx = tree.x - playerWorldX, dz = tree.z - playerWorldZ;
            playerGroup.rotation.y = Math.atan2(dx, dz);

            const chopTime = tt.chopTime * axe.speedMult;
            addChatMessage('system', `You swing your axe at the ${tt.name}...`);

            // Show progress bar in skill area
            const area = document.getElementById('skill-action-area');
            area.innerHTML = `<div style="font-size:10px;color:#a3e635;margin-bottom:2px;">ü™ì Chopping ${tt.name}</div>
                <div class="skill-timer"><div class="skill-timer-fill" id="skill-timer-fill" style="width:0%"></div></div>`;

            skillingAction = { type: 'woodcutting', timer: 0, maxTime: chopTime, callback: () => {
                const tree2 = treeRegistry.get(woodcuttingTarget);
                if (!tree2 || tree2.isDepleted) { stopWoodcutting(); return; }
                const tt2 = TREE_TYPES[tree2.treeType];
                const axe2 = getBestAxe();
                if (!axe2) { stopWoodcutting(); return; }

                // Success chance
                const axeBonus = Math.round((1 - axe2.speedMult) * 20);
                const successChance = Math.min(95, 40 + wcLevel - tt2.wcLevel + axeBonus);
                if (Math.random() * 100 < successChance) {
                    // Success
                    if (addToInventory(tt2.logItem, 1)) {
                        addChatMessage('system', `You get some ${ITEMS[tt2.logItem].name}. ${ITEMS[tt2.logItem].icon}`);
                    }
                    gainXP('woodcutting', tt2.xp);

                    // Depletion chance
                    if (Math.random() < 0.3) {
                        depleteTree(tree2);
                        addChatMessage('system', 'The tree has been depleted.');
                        stopWoodcutting();
                        return;
                    }
                } else {
                    addChatMessage('system', 'Your axe fails to cut the tree.');
                }

                // Auto-restart if still adjacent and tree alive
                if (woodcuttingTarget && !tree2.isDepleted) {
                    const d = Math.abs(playerTileX - tree2.x) + Math.abs(playerTileZ - tree2.z);
                    if (d <= 1) {
                        clearSkillTimer();
                        beginChopCycle();
                    } else { stopWoodcutting(); }
                }
            }};
        }

        function stopWoodcutting() {
            if (skillingAction && skillingAction.type === 'woodcutting') {
                clearSkillTimer();
            }
            woodcuttingTarget = null;
            const area = document.getElementById('skill-action-area');
            if (area && area.innerHTML.includes('Chopping')) area.innerHTML = '';
        }

        // ============================================================
        // === FISHING ===
        // ============================================================
        let fishingTarget = null; // spotId

        function startFishing(spotId) {
            const spot = fishingSpotRegistry.get(spotId);
            if (!spot || spot.isDepleted) { addChatMessage('system', 'This fishing spot is depleted.'); return; }
            const ft = FISH_TYPES[spot.fishType];
            const fishLevel = playerStats.fishing || 1;
            if (fishLevel < ft.fishLevel) { addChatMessage('system', `You need level ${ft.fishLevel} Fishing to catch ${ft.name}.`); return; }

            // Find adjacent walkable tile to the water spot
            const adj = findAdjacentWalkable(spot.x, spot.z);
            if (!adj) { addChatMessage('system', 'You can\'t reach this fishing spot.'); return; }

            // Walk to spot
            const path = findPath(playerTileX, playerTileZ, adj.x, adj.z);
            if (path.length > 1) {
                fishingTarget = spotId;
                stopFishing();
                stopWoodcutting();
                startMoveTo(path);
            } else if (Math.abs(playerTileX - spot.x) + Math.abs(playerTileZ - spot.z) <= 1) {
                fishingTarget = spotId;
                stopWoodcutting();
                beginFishCycle();
            } else {
                addChatMessage('system', 'You can\'t reach this fishing spot.');
            }
        }

        function beginFishCycle() {
            const spot = fishingSpotRegistry.get(fishingTarget);
            if (!spot || spot.isDepleted) { stopFishing(); return; }
            const ft = FISH_TYPES[spot.fishType];
            const fishLevel = playerStats.fishing || 1;
            if (fishLevel < ft.fishLevel) { stopFishing(); return; }

            // Face the water
            const dx = spot.x - playerWorldX, dz = spot.z - playerWorldZ;
            playerGroup.rotation.y = Math.atan2(dx, dz);

            addChatMessage('system', `You cast your line for ${ft.name}...`);

            const area = document.getElementById('skill-action-area');
            area.innerHTML = `<div style="font-size:10px;color:#44ccff;margin-bottom:2px;">üé£ Fishing for ${ft.name}</div>
                <div class="skill-timer"><div class="skill-timer-fill" id="skill-timer-fill" style="width:0%"></div></div>`;

            skillingAction = { type: 'fishing', timer: 0, maxTime: ft.catchTime, callback: () => {
                const spot2 = fishingSpotRegistry.get(fishingTarget);
                if (!spot2 || spot2.isDepleted) { stopFishing(); return; }
                const ft2 = FISH_TYPES[spot2.fishType];
                const lvl = playerStats.fishing || 1;

                // Success chance
                const successChance = Math.min(95, 50 + lvl - ft2.fishLevel);
                if (Math.random() * 100 < successChance) {
                    if (addToInventory(ft2.rawItem, 1)) {
                        addChatMessage('system', `You catch a ${ft2.name}! ${ITEMS[ft2.rawItem].icon}`);
                    }
                    gainXP('fishing', ft2.xp);

                    // Depletion chance: 25%
                    if (Math.random() < 0.25) {
                        depleteFishingSpot(spot2);
                        addChatMessage('system', 'The fishing spot has been depleted.');
                        stopFishing();
                        return;
                    }
                } else {
                    addChatMessage('system', 'The fish got away!');
                }

                // Auto-restart if still adjacent and spot alive
                if (fishingTarget && !spot2.isDepleted) {
                    const d = Math.abs(playerTileX - spot2.x) + Math.abs(playerTileZ - spot2.z);
                    if (d <= 1) {
                        clearSkillTimer();
                        beginFishCycle();
                    } else { stopFishing(); }
                }
            }};
        }

        function stopFishing() {
            if (skillingAction && skillingAction.type === 'fishing') {
                clearSkillTimer();
            }
            fishingTarget = null;
            const area = document.getElementById('skill-action-area');
            if (area && area.innerHTML.includes('Fishing')) area.innerHTML = '';
        }

        // ============================================================
        // === CONTEXT MENU ===
        // ============================================================
        const ctxMenu = document.getElementById('context-menu');
        let ctxNPC = null, ctxBuilding = null, ctxTile = null, ctxMonster = null, ctxTree = null, ctxFishingSpot = null;

        function hideContextMenu() { ctxMenu.style.display = 'none'; }
        document.addEventListener('click', (e) => { if (!ctxMenu.contains(e.target)) hideContextMenu(); });

        function showContextMenu(e, options, header) {
            hideContextMenu();
            ctxMenu.innerHTML = (header ? `<div class="ctx-header">${header}</div>` : '') +
                options.map(o => `<div class="ctx-option" onclick="${o.action}">${o.label}</div>`).join('');
            ctxMenu.style.display = 'block';
            ctxMenu.style.left = Math.min(e.clientX, window.innerWidth - 160) + 'px';
            ctxMenu.style.top = Math.min(e.clientY, window.innerHeight - (options.length * 30 + 30)) + 'px';
        }

        renderer.domElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = viewport.getBoundingClientRect();
            const mx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            const my = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(mx, my), camera);
            const allObj = []; scene.traverse(o => { if (o.isMesh) allObj.push(o); });
            const hits = raycaster.intersectObjects(allObj, false);

            let hitNPC = null, hitBld = null, hitTile = null, hitMonster = null, hitTree = null, hitFishSpot = null;
            for (const h of hits) {
                if (h.object.userData.type === 'npc' && !hitNPC) hitNPC = h.object.userData.npcId;
                if (h.object.userData.type === 'monster' && !hitMonster) hitMonster = h.object.userData.monsterId;
                if (h.object.userData.type === 'building' && !hitBld) hitBld = h.object.userData.buildingId;
                if (h.object.userData.type === 'tree' && !hitTree) hitTree = h.object.userData.treeId;
                if (h.object.userData.type === 'fishing_spot' && !hitFishSpot) hitFishSpot = h.object.userData.fishingSpotId;
                if (h.object.userData.tileX !== undefined && !hitTile) hitTile = h.object.userData;
            }

            if (hitMonster) {
                const monster = monsterRegistry.get(hitMonster);
                if (monster && !monster.isDead) {
                    ctxMonster = monster;
                    showContextMenu(e, [
                        { label: 'Attack ' + monster.def.name, action: 'attackMonster()' },
                        { label: 'Examine', action: 'examineMonster()' },
                        { label: 'Cancel', action: 'hideContextMenu()' },
                    ], monster.def.icon + ' ' + monster.def.name + ' (Lv.' + monster.def.level + ')');
                }
                return;
            }
            if (hitFishSpot) {
                const spot = fishingSpotRegistry.get(hitFishSpot);
                if (spot && !spot.isDepleted) {
                    ctxFishingSpot = spot;
                    const ft = FISH_TYPES[spot.fishType];
                    showContextMenu(e, [
                        { label: 'Fish ' + ft.name, action: 'fishCtxSpot()' },
                        { label: 'Examine', action: 'examineCtxFishSpot()' },
                        { label: 'Cancel', action: 'hideContextMenu()' },
                    ], 'üé£ ' + ft.name + ' (Fishing Lv.' + ft.fishLevel + ')');
                }
                return;
            }
            if (hitTree) {
                const tree = treeRegistry.get(hitTree);
                if (tree && !tree.isDepleted) {
                    ctxTree = tree;
                    const tt = TREE_TYPES[tree.treeType];
                    showContextMenu(e, [
                        { label: 'Chop ' + tt.name, action: 'chopCtxTree()' },
                        { label: 'Examine', action: 'examineCtxTree()' },
                        { label: 'Cancel', action: 'hideContextMenu()' },
                    ], 'üå≥ ' + tt.name + ' (WC Lv.' + tt.wcLevel + ')');
                }
                return;
            }
            if (hitNPC) {
                const npc = npcRegistry.get(hitNPC);
                if (npc && !npc.isDead) {
                    ctxNPC = npc;
                    const name = npc.data.display_name || npc.id;
                    showContextMenu(e, [
                        { label: 'Talk to ' + name, action: 'talkToNPC()' },
                        { label: 'Attack ' + name, action: 'attackNPC()' },
                        { label: 'Examine', action: 'examineNPC()' },
                        { label: 'Cancel', action: 'hideContextMenu()' },
                    ], name);
                }
                return;
            }
            if (hitBld) {
                const bd = BUILDINGS.find(b => b.id === hitBld);
                if (bd) {
                    ctxBuilding = bd;
                    showContextMenu(e, [
                        { label: 'Enter ' + bd.name, action: 'enterBuilding()' },
                        { label: 'Examine', action: 'examineBuilding()' },
                        { label: 'Cancel', action: 'hideContextMenu()' },
                    ], bd.icon + ' ' + bd.name);
                }
                return;
            }
            if (hitTile) {
                ctxTile = hitTile;
                showContextMenu(e, [
                    { label: 'Walk here', action: 'walkToCtxTile()' },
                    { label: 'Cancel', action: 'hideContextMenu()' },
                ]);
            }
        });

        window.talkToNPC = function() {
            hideContextMenu();
            if (!ctxNPC) return;
            const name = ctxNPC.data.display_name || ctxNPC.id;
            const lines = AGENT_DIALOGUE[ctxNPC.role] || AGENT_DIALOGUE.app_builder;
            const line = lines[Math.floor(Math.random() * lines.length)];
            addChatMessage('agent', line, name, ctxNPC.roleInfo.hex);
            showChatBubble(ctxNPC.worldX, ctxNPC.worldZ, line, '#22c55e');
        };
        window.attackNPC = function() {
            hideContextMenu();
            if (ctxNPC) startCombat(ctxNPC);
        };
        window.attackMonster = function() {
            hideContextMenu();
            if (ctxMonster) startMonsterCombat(ctxMonster);
        };
        window.examineMonster = function() {
            hideContextMenu();
            if (!ctxMonster) return;
            const m = ctxMonster.def;
            addChatMessage('system', `${m.icon} ${m.name} (Lv.${m.level}) \u2014 HP: ${ctxMonster.hp}/${ctxMonster.maxHp}, Atk: ${m.attack}, Str: ${m.strength}, Def: ${m.defence}${ctxMonster.isBoss ? ' [BOSS]' : ''}${m.aggressive ? ' [Aggressive]' : ''}`);
        };
        window.examineNPC = function() {
            hideContextMenu();
            if (!ctxNPC) return;
            const name = ctxNPC.data.display_name || ctxNPC.id;
            const cs = ctxNPC.combatStats;
            addChatMessage('system', `${name} ‚Äî ${ctxNPC.roleInfo.name} (HP: ${ctxNPC.hp}/${ctxNPC.maxHp}, Atk: ${cs.attack}, Str: ${cs.strength}, Def: ${cs.defence})`);
        };
        window.chopCtxTree = function() {
            hideContextMenu();
            if (ctxTree) startWoodcutting(ctxTree.id);
        };
        window.examineCtxTree = function() {
            hideContextMenu();
            if (!ctxTree) return;
            const tt = TREE_TYPES[ctxTree.treeType];
            addChatMessage('system', `üå≥ ${tt.name} ‚Äî Requires WC Level ${tt.wcLevel}. Gives ${tt.xp} XP per log. Respawns in ${tt.respawnTime}s.`);
        };
        window.fishCtxSpot = function() {
            hideContextMenu();
            if (ctxFishingSpot) startFishing(ctxFishingSpot.id);
        };
        window.examineCtxFishSpot = function() {
            hideContextMenu();
            if (!ctxFishingSpot) return;
            const ft = FISH_TYPES[ctxFishingSpot.fishType];
            addChatMessage('system', `üé£ ${ft.name} fishing spot ‚Äî Requires Fishing Level ${ft.fishLevel}. Gives ${ft.xp} XP per catch. Respawns in ${ft.respawnTime}s.`);
        };
        let pendingBuildingAction = null;

        window.enterBuilding = function() {
            hideContextMenu();
            if (!ctxBuilding) return;
            const bid = ctxBuilding.id;
            addChatMessage('system', `You head to the ${ctxBuilding.name}.`);
            const door = buildingDoors[bid];
            if (door) {
                const dist = Math.abs(playerTileX - door.x) + Math.abs(playerTileZ - door.z);
                if (dist <= 1) {
                    onArriveAtBuilding(bid);
                } else {
                    pendingBuildingAction = bid;
                    const path = findPath(playerTileX, playerTileZ, door.x, door.z);
                    if (path.length > 1) startMoveTo(path);
                }
            }
        };

        function onArriveAtBuilding(bid) {
            checkQuestProgress('visit', { building: bid });
            checkQuestProgress('enter_building', { building: bid });
            document.getElementById('skill-action-area').innerHTML = '';
            if (bid === 'quest_board') { renderQuestBoard(); document.getElementById('quest-overlay').classList.add('open'); }
            else if (bid === 'marketplace') { openShop(); }
            else if (bid === 'workshop') { openCrafting(); }
            else if (bid === 'farm') { showFarmActions(); }
            else if (bid === 'arena') { showArenaActions(); }
            else { addChatMessage('system', `You arrive at the ${BUILDINGS.find(b=>b.id===bid).name}.`); }
        }
        window.examineBuilding = function() {
            hideContextMenu();
            if (!ctxBuilding) return;
            addChatMessage('system', `${ctxBuilding.icon} ${ctxBuilding.name}: ${ctxBuilding.description}`);
        };
        window.walkToCtxTile = function() {
            hideContextMenu();
            if (!ctxTile || !ctxTile.walkable) return;
            const path = findPath(playerTileX, playerTileZ, ctxTile.tileX, ctxTile.tileZ);
            if (path.length > 1) startMoveTo(path);
        };

        function showInventoryMenu(e, slot) {
            const item = inventory[slot];
            if (!item) return;
            const opts = [{ label: 'Examine', action: `examineItem(${slot})` }];
            if (item.type === 'food') opts.unshift({ label: 'Eat', action: `eatFood(${slot})` });
            if (item.type === 'weapon') opts.unshift({ label: playerStats.equippedSlot === slot ? 'Unequip' : 'Wield', action: `equipWeapon(${slot})` });
            if (item.type === 'helm') opts.unshift({ label: playerStats.equippedHelmSlot === slot ? 'Remove' : 'Wear', action: `equipHelm(${slot})` });
            if (item.type === 'shield') opts.unshift({ label: playerStats.equippedShieldSlot === slot ? 'Remove' : 'Wear', action: `equipShield(${slot})` });
            if (item.type === 'potion') opts.unshift({ label: 'Drink', action: `drinkPotion(${slot})` });
            opts.push({ label: 'Drop', action: `dropItem(${slot})` });
            opts.push({ label: 'Cancel', action: 'hideContextMenu()' });
            showContextMenu(e, opts, item.icon + ' ' + item.name);
        }
        window.examineItem = function(slot) { hideContextMenu(); const i = inventory[slot]; if (i) { let desc = ''; if (i.stats && i.stats.attack) desc = ` (Atk +${i.stats.attack}, Str +${i.stats.strength})`; else if (i.stats && i.stats.defence) desc = ` (Def +${i.stats.defence})`; else if (i.healAmount) desc = ` (Heals ${i.healAmount})`; addChatMessage('system', `${i.icon} ${i.name}${desc}`); } };
        window.dropItem = function(slot) { hideContextMenu(); const i = inventory[slot]; if (i) { addChatMessage('system', `You drop the ${i.name}.`); removeFromInventory(slot, i.quantity); } };
        // Expose eat/equip globally for context menu
        window.eatFood = eatFood;
        window.equipWeapon = equipWeapon;
        window.equipHelm = equipHelm;
        window.equipShield = equipShield;
        window.drinkPotion = drinkPotion;
        window.hideContextMenu = hideContextMenu;

        // ============================================================
        // === API INTEGRATION ===
        // ============================================================
        const DEMO_AGENTS = [
            { id:'demo-1', agent_name:'BuilderBot', display_name:'BuilderBot', role:'app_builder', agent_type:'hosted', objective:'Build SUITE apps' },
            { id:'demo-2', agent_name:'RefinerX', display_name:'RefinerX', role:'app_refiner', agent_type:'cli', objective:'Refine existing apps' },
            { id:'demo-3', agent_name:'ContentAI', display_name:'ContentAI', role:'content_creator', agent_type:'hosted', objective:'Write articles' },
            { id:'demo-4', agent_name:'GrowthBot', display_name:'GrowthBot', role:'growth_outreach', agent_type:'hosted', objective:'Drive user growth' },
            { id:'demo-5', agent_name:'TestRunner', display_name:'TestRunner', role:'qa_tester', agent_type:'cli', objective:'Test all the things' },
        ];

        async function fetchAgents() {
            try {
                const res = await fetch(`${API_BASE}/api/swarm/agents?limit=50`);
                if (!res.ok) throw new Error('API error');
                const data = await res.json();
                const agents = data.agents || data;
                if (Array.isArray(agents) && agents.length > 0) { syncNPCs(agents); return; }
            } catch (e) {}
            if (npcRegistry.size === 0) { syncNPCs(DEMO_AGENTS); addChatMessage('system', 'Loaded demo agents (API unavailable)'); }
        }
        function syncNPCs(agents) {
            const ids = new Set(agents.map(a => a.id));
            npcRegistry.forEach((n, id) => { if (!ids.has(id)) despawnNPC(id); });
            agents.forEach(a => { if (!npcRegistry.has(a.id)) createNPCCharacter(a); else npcRegistry.get(a.id).data = a; });
        }
        fetchAgents();
        setInterval(() => fetchAgents(), 60000);

        // ============================================================
        // === CLICK / HOVER HANDLERS ===
        // ============================================================
        const raycasterMain = new THREE.Raycaster();
        const mouseVec = new THREE.Vector2();

        function getViewportMouse(e) {
            const rect = viewport.getBoundingClientRect();
            return new THREE.Vector2(
                ((e.clientX - rect.left) / rect.width) * 2 - 1,
                -((e.clientY - rect.top) / rect.height) * 2 + 1
            );
        }

        renderer.domElement.addEventListener('click', (e) => {
            if (e.target !== renderer.domElement) return;
            const m = getViewportMouse(e);
            raycasterMain.setFromCamera(m, camera);
            const allObj = []; scene.traverse(o => { if (o.isMesh) allObj.push(o); });
            const hits = raycasterMain.intersectObjects(allObj, false);
            let hitNPC = null, hitBld = null, hitTile = null, hitMonster = null, hitTree = null, hitFishSpot = null;
            for (const h of hits) {
                if (h.object.userData.type === 'npc' && !hitNPC) hitNPC = h.object.userData.npcId;
                if (h.object.userData.type === 'monster' && !hitMonster) hitMonster = h.object.userData.monsterId;
                if (h.object.userData.type === 'building' && !hitBld) hitBld = h.object.userData.buildingId;
                if (h.object.userData.type === 'tree' && !hitTree) hitTree = h.object.userData.treeId;
                if (h.object.userData.type === 'fishing_spot' && !hitFishSpot) hitFishSpot = h.object.userData.fishingSpotId;
                if (h.object.userData.tileX !== undefined && !hitTile) hitTile = h.object.userData;
            }

            if (hitMonster) {
                const monster = monsterRegistry.get(hitMonster);
                if (monster && !monster.isDead) {
                    if (attackMode) startMonsterCombat(monster);
                    else { ctxMonster = monster; examineMonster(); }
                }
                return;
            }
            if (hitNPC) {
                const npc = npcRegistry.get(hitNPC);
                if (npc && !npc.isDead) {
                    if (attackMode) startCombat(npc);
                    else { ctxNPC = npc; talkToNPC(); }
                }
                return;
            }
            if (hitFishSpot) {
                startFishing(hitFishSpot);
                return;
            }
            if (hitTree) {
                startWoodcutting(hitTree);
                return;
            }
            if (hitBld) {
                const bd = BUILDINGS.find(b => b.id === hitBld);
                if (bd) {
                    ctxBuilding = bd;
                    enterBuilding();
                }
                return;
            }
            if (hitTile && hitTile.walkable) {
                stopWoodcutting(); // cancel chopping if clicking to move
                stopFishing(); // cancel fishing if clicking to move
                const path = findPath(playerTileX, playerTileZ, hitTile.tileX, hitTile.tileZ);
                if (path.length > 1) startMoveTo(path);
            }
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            const m = getViewportMouse(e);
            raycasterMain.setFromCamera(m, camera);
            const allObj = []; scene.traverse(o => { if (o.isMesh) allObj.push(o); });
            const hits = raycasterMain.intersectObjects(allObj, false);
            highlight.visible = false; let cursorSet = false;
            for (const h of hits) {
                const o = h.object;
                if (o.userData.type === 'monster') { document.body.style.cursor = 'crosshair'; cursorSet = true; break; }
                if (o.userData.type === 'npc') { document.body.style.cursor = attackMode ? 'crosshair' : 'help'; cursorSet = true; break; }
                if (o.userData.type === 'tree') { document.body.style.cursor = 'pointer'; cursorSet = true; break; }
                if (o.userData.type === 'fishing_spot') { document.body.style.cursor = 'pointer'; cursorSet = true; break; }
                if (o.userData.type === 'building') { document.body.style.cursor = 'pointer'; cursorSet = true; break; }
                if (o.userData.tileX !== undefined) {
                    const tx=o.userData.tileX, tz=o.userData.tileZ;
                    highlight.position.set(tx, heightMap[tx][tz]+0.05, tz); highlight.visible = true;
                    highlightMat.color.set(o.userData.walkable ? 0xffff00 : 0xff4444);
                    highlightMat.opacity = o.userData.walkable ? 0.3 : 0.2;
                    document.body.style.cursor = o.userData.walkable ? 'pointer' : 'not-allowed';
                    cursorSet = true; break;
                }
            }
            if (!cursorSet) document.body.style.cursor = 'default';
        });

        // ============================================================
        // === KEYBOARD ===
        // ============================================================
        const keys = {};
        window.addEventListener('keydown', e => { if (!chatInputFocused) { keys[e.key.toLowerCase()] = true; if (e.key.toLowerCase() === 'f') useSpecialAttack(); } });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        renderer.domElement.addEventListener('wheel', (e) => {
            camDist += e.deltaY * 0.01;
            camDist = Math.max(6, Math.min(30, camDist));
            camHeight = camDist * 0.78;
        });

        // ============================================================
        // === MINIMAP ===
        // ============================================================
        const minimapCanvas = document.getElementById('minimap');
        const mctx = minimapCanvas.getContext('2d');
        function drawMinimap() {
            const s = 200 / MAP_SIZE; // 2.5px per tile
            mctx.clearRect(0, 0, 200, 200);

            // Zone color overlays first
            Object.values(ZONES).forEach(zone => {
                const zColors = {suite_city:'#2a2a40', the_forest:'#1a3a1a', the_ruins:'#3a3020', the_deep_network:'#1a1030'};
                mctx.fillStyle = zColors[zone.id] || '#2a2a2a';
                mctx.fillRect(zone.bounds.x1*s, zone.bounds.z1*s, (zone.bounds.x2-zone.bounds.x1)*s, (zone.bounds.z2-zone.bounds.z1)*s);
            });

            // Terrain tiles
            for(let x=0;x<MAP_SIZE;x++)for(let z=0;z<MAP_SIZE;z++){
                const tz=getTerrainZone(x,z);
                if(grid[x][z]===3) mctx.fillStyle='#8B6914';
                else if(isWater(x,z)) mctx.fillStyle=tz==='deep'?'#2a1060':'#2288aa';
                else if(grid[x][z]===0) {
                    if(tz==='forest') mctx.fillStyle='#1a3a1a';
                    else if(tz==='ruins') mctx.fillStyle='#3a3020';
                    else if(tz==='deep') mctx.fillStyle='#1a1030';
                    else mctx.fillStyle='#2d4a1e';
                }
                else if(grid[x][z]===2) mctx.fillStyle='#6b5a40';
                else {
                    if(tz==='forest') mctx.fillStyle='#2a5a1e';
                    else if(tz==='ruins') mctx.fillStyle='#5a5a5a';
                    else if(tz==='deep') mctx.fillStyle='#1e1238';
                    else mctx.fillStyle='#4a7c3f';
                }
                mctx.fillRect(x*s,z*s,Math.ceil(s),Math.ceil(s));
            }

            // Zone labels
            mctx.font='bold 7px monospace'; mctx.textAlign='center';
            mctx.fillStyle='#6366f1'; mctx.fillText('CITY',40*s,38*s);
            mctx.fillStyle='#22c55e'; mctx.fillText('FOREST',40*s,10*s);
            mctx.fillStyle='#f97316'; mctx.fillText('RUINS',70*s,38*s);
            mctx.fillStyle='#ef4444'; mctx.fillText('DEEP',40*s,66*s);

            // Buildings
            BUILDINGS.forEach(b=>{mctx.fillStyle=b.signColor;mctx.globalAlpha=0.6;mctx.fillRect((b.x-b.w/2)*s,(b.z-b.d/2)*s,b.w*s,b.d*s);mctx.globalAlpha=1;});

            // Monsters ‚Äî red for aggressive, orange for passive, bosses pulsing
            const time = Date.now();
            monsterRegistry.forEach(m=>{
                if(m.isDead) return;
                if(m.isBoss) {
                    const pulse = 2 + Math.sin(time * 0.005) * 1.5;
                    mctx.fillStyle='#ff0000'; mctx.beginPath(); mctx.arc(m.worldX*s,m.worldZ*s,pulse,0,Math.PI*2); mctx.fill();
                } else {
                    mctx.fillStyle = m.def.aggressive ? '#ef4444' : '#f97316';
                    mctx.beginPath(); mctx.arc(m.worldX*s,m.worldZ*s,1.5,0,Math.PI*2); mctx.fill();
                }
            });

            // NPCs
            npcRegistry.forEach(n=>{if(!n.isDead){mctx.fillStyle=n.roleInfo.hex;mctx.beginPath();mctx.arc(n.worldX*s,n.worldZ*s,1.5,0,Math.PI*2);mctx.fill();}});
            // Loot piles
            lootPiles.forEach(lp=>{mctx.fillStyle='#eab308';mctx.beginPath();mctx.arc(lp.x*s,lp.z*s,1.5,0,Math.PI*2);mctx.fill();});
            // Other players
            otherPlayers.forEach(p=>{mctx.fillStyle=p.color||'#ffffff';mctx.beginPath();mctx.arc(p.x*s,p.z*s,2,0,Math.PI*2);mctx.fill();});
            // Player
            mctx.fillStyle='#ffff00';mctx.beginPath();mctx.arc(playerWorldX*s,playerWorldZ*s,2.5,0,Math.PI*2);mctx.fill();
        }

        // ============================================================
        // === ORBS UPDATE ===
        // ============================================================
        function updateOrbs() {
            const hpPct = Math.max(0, (playerStats.hp / playerStats.maxHp) * 100);
            document.getElementById('orbHp').style.setProperty('--hp-pct', hpPct + '%');
            document.getElementById('orbHpText').textContent = Math.max(0, playerStats.hp);
            document.getElementById('orbCombatText').textContent = playerStats.combatLevel;
            document.getElementById('orbEnergy').style.setProperty('--energy-pct', playerStats.energy + '%');
            document.getElementById('orbEnergyText').textContent = playerStats.energy;
        }

        // ============================================================
        // === LABEL / BUBBLE PROJECTION ===
        // ============================================================
        function projectToScreen(wx, wz, yOffset) {
            const pos = new THREE.Vector3(wx, yOffset, wz);
            pos.project(camera);
            const rect = viewport.getBoundingClientRect();
            return {
                x: (pos.x * 0.5 + 0.5) * rect.width,
                y: (-pos.y * 0.5 + 0.5) * rect.height,
                visible: pos.z > -1 && pos.z < 1
            };
        }

        function updateOverlays() {
            // NPC labels
            npcRegistry.forEach(npc => {
                const p = projectToScreen(npc.worldX, npc.worldZ, 1.3);
                if (!p.visible || npc.isDead) { npc.label.style.display = 'none'; } else {
                    npc.label.style.display = 'block';
                    npc.label.style.left = p.x + 'px'; npc.label.style.top = p.y + 'px';
                }
            });
            // Monster labels
            monsterRegistry.forEach(monster => {
                const p = projectToScreen(monster.worldX, monster.worldZ, monster.isBoss ? 1.6 : 1.3);
                if (!p.visible || monster.isDead) { monster.label.style.display = 'none'; } else {
                    monster.label.style.display = 'block';
                    monster.label.style.left = p.x + 'px'; monster.label.style.top = p.y + 'px';
                    // Show HP if damaged
                    if (monster.hp < monster.maxHp) {
                        monster.label.textContent = `${monster.def.name} (Lv.${monster.def.level}) ${monster.hp}/${monster.maxHp}`;
                    }
                }
            });
            // Loot piles
            document.querySelectorAll('.loot-pile-dot').forEach(el => el.remove());
            lootPiles.forEach((lp, i) => {
                const p = projectToScreen(lp.x, lp.z, 0.3);
                if (p.visible) {
                    const dot = document.createElement('div');
                    dot.className = 'loot-pile-dot';
                    dot.style.left = (p.x - 4) + 'px';
                    dot.style.top = (p.y - 4) + 'px';
                    dot.title = 'Loot pile - click to pick up';
                    dot.addEventListener('click', () => pickupLootPile(i));
                    document.getElementById('npc-labels').appendChild(dot);
                }
            });

            // Chat bubbles + hitsplats
            document.querySelectorAll('.chat-bubble, .hitsplat').forEach(el => {
                const wx = parseFloat(el.dataset.worldX), wz = parseFloat(el.dataset.worldZ);
                const p = projectToScreen(wx, wz, el.classList.contains('hitsplat') ? 1.5 : 1.6);
                if (p.visible) { el.style.left = p.x + 'px'; el.style.top = p.y + 'px'; }
                else el.style.display = 'none';
            });
        }

        // ============================================================
        // === FIREFLIES ===
        // ============================================================
        const particles = [];
        for(let i=0;i<30;i++){const p=new THREE.Mesh(new THREE.SphereGeometry(0.03,4,4),new THREE.MeshBasicMaterial({color:0xffff88}));p.position.set(rng()*MAP_SIZE,0.5+rng()*1.5,rng()*MAP_SIZE);p.userData.speed=0.2+rng()*0.5;p.userData.offset=rng()*Math.PI*2;p.visible=false;scene.add(p);particles.push(p);}

        // ============================================================
        // === GAME LOOP ===
        // ============================================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // Camera follows player + WASD movement
            if (!chatInputFocused) {
                if (keys['q']) camAngle -= 1.5 * dt;
                if (keys['e']) camAngle += 1.5 * dt;
                // WASD click-to-walk: compute target tile and start path
                if (!isMoving && (keys['w'] || keys['a'] || keys['s'] || keys['d'])) {
                    let dx = 0, dz = 0;
                    if (keys['w']) { dz -= Math.cos(camAngle); dx -= Math.sin(camAngle); }
                    if (keys['s']) { dz += Math.cos(camAngle); dx += Math.sin(camAngle); }
                    if (keys['a']) { dx -= Math.cos(camAngle); dz += Math.sin(camAngle); }
                    if (keys['d']) { dx += Math.cos(camAngle); dz -= Math.sin(camAngle); }
                    const tx = Math.round(playerTileX + Math.sign(dx));
                    const tz = Math.round(playerTileZ + Math.sign(dz));
                    if (tx >= 0 && tx < MAP_SIZE && tz >= 0 && tz < MAP_SIZE && grid[tx][tz] === 1) {
                        startMoveTo([{x:playerTileX,z:playerTileZ},{x:tx,z:tz}]);
                    }
                }
            }
            // Lock camera to player position
            camTargetX = playerWorldX;
            camTargetZ = playerWorldZ;
            updateCamera();

            // Auto-cancel woodcutting/fishing if player starts moving
            if (isMoving && skillingAction && skillingAction.type === 'woodcutting') {
                stopWoodcutting();
            }
            if (isMoving && skillingAction && skillingAction.type === 'fishing') {
                stopFishing();
            }

            // Player movement
            if (isMoving && currentPath.length > 0) {
                moveProgress += dt * MOVE_SPEED; walkCycle += dt * 12;
                const ls = Math.sin(walkCycle) * 0.3;
                leftLeg.rotation.x = ls; rightLeg.rotation.x = -ls;
                leftArm.rotation.x = -ls * 0.6; rightArm.rotation.x = ls * 0.6;
                body.position.y = 0.5 + Math.abs(Math.sin(walkCycle)) * 0.03;
                if (moveProgress >= 1) {
                    moveProgress = 0; playerTileX = moveToX; playerTileZ = moveToZ; playerWorldX = moveToX; playerWorldZ = moveToZ; pathIndex++;
                    if (pathIndex < currentPath.length) { moveFromX = moveToX; moveFromZ = moveToZ; moveToX = currentPath[pathIndex].x; moveToZ = currentPath[pathIndex].z; }
                    else { isMoving = false; currentPath = []; leftLeg.rotation.x=0; rightLeg.rotation.x=0; leftArm.rotation.x=0; rightArm.rotation.x=0; body.position.y=0.5;
                        // Auto-engage combat if we walked to target
                        if (combatTarget && !combatTarget.isDead) {
                            const d = Math.abs(playerTileX-combatTarget.tileX)+Math.abs(playerTileZ-combatTarget.tileZ);
                            if (d <= 1) engageCombat(combatTarget);
                        }
                        // Auto-engage monster combat
                        if (monsterCombatTarget && !monsterCombatTarget.isDead) {
                            const d = Math.abs(playerTileX-monsterCombatTarget.tileX)+Math.abs(playerTileZ-monsterCombatTarget.tileZ);
                            if (d <= 1) engageMonsterCombat(monsterCombatTarget);
                        }
                        // Building arrival
                        if (pendingBuildingAction) {
                            onArriveAtBuilding(pendingBuildingAction);
                            pendingBuildingAction = null;
                        }
                        // Auto-engage woodcutting on arrival
                        if (woodcuttingTarget) {
                            const wt = treeRegistry.get(woodcuttingTarget);
                            if (wt && !wt.isDepleted) {
                                const d = Math.abs(playerTileX - wt.x) + Math.abs(playerTileZ - wt.z);
                                if (d <= 1) beginChopCycle();
                            }
                        }
                        // Auto-engage fishing on arrival
                        if (fishingTarget) {
                            const fs = fishingSpotRegistry.get(fishingTarget);
                            if (fs && !fs.isDepleted) {
                                const d = Math.abs(playerTileX - fs.x) + Math.abs(playerTileZ - fs.z);
                                if (d <= 1) beginFishCycle();
                            }
                        }
                    }
                }
                if (isMoving) {
                    const lx=moveFromX+(moveToX-moveFromX)*moveProgress, lz=moveFromZ+(moveToZ-moveFromZ)*moveProgress;
                    playerWorldX=lx; playerWorldZ=lz;
                    const fh=heightMap[moveFromX]?heightMap[moveFromX][moveFromZ]||0:0;
                    const th=heightMap[moveToX]?heightMap[moveToX][moveToZ]||0:0;
                    playerGroup.position.set(lx, fh+(th-fh)*moveProgress, lz);
                    playerGroup.rotation.y = Math.atan2(moveToX-moveFromX, moveToZ-moveFromZ);
                }
            }

            // NPCs
            processPathfindingQueue();
            npcRegistry.forEach(npc => updateNPCState(npc, dt));

            // Monsters
            monsterRegistry.forEach(m => updateMonsterState(m, dt));

            // Combat
            updateCombat(dt);
            updateMonsterCombat(dt);
            updateEnergyRegen(dt);
            updateSkillingTimers(dt);

            // Tree respawn timers
            treeRegistry.forEach(tree => {
                if (tree.isDepleted) {
                    tree.respawnTimer -= dt;
                    if (tree.respawnTimer <= 0) respawnTree(tree);
                }
            });

            // Chopping animation: swing right arm
            if (skillingAction && skillingAction.type === 'woodcutting') {
                const swing = Math.sin(time * 6) * 0.8;
                rightArm.rotation.x = swing;
                // Face tree
                const wt = treeRegistry.get(woodcuttingTarget);
                if (wt) {
                    const dx = wt.x - playerWorldX, dz = wt.z - playerWorldZ;
                    playerGroup.rotation.y = Math.atan2(dx, dz);
                }
            }

            // Fishing idle animation: face water
            if (skillingAction && skillingAction.type === 'fishing') {
                const fs = fishingSpotRegistry.get(fishingTarget);
                if (fs) {
                    const dx = fs.x - playerWorldX, dz = fs.z - playerWorldZ;
                    playerGroup.rotation.y = Math.atan2(dx, dz);
                }
            }

            // Fishing spot respawn timers
            fishingSpotRegistry.forEach(spot => {
                if (spot.isDepleted) {
                    spot.respawnTimer -= dt;
                    if (spot.respawnTimer <= 0) respawnFishingSpot(spot);
                }
            });

            // Fishing spot bubble animation (bob up and down)
            fishingSpotRegistry.forEach(spot => {
                if (!spot.isDepleted) {
                    spot.bubbleMeshes.forEach(b => {
                        b.position.y = 0.05 + Math.sin(time * 3 + b.userData.bubbleOffset) * 0.06;
                    });
                }
            });

            // Zone detection
            const pZone = getZoneAt(playerWorldX, playerWorldZ);
            const pZoneId = pZone ? pZone.id : null;
            if (pZoneId !== currentPlayerZone) {
                currentPlayerZone = pZoneId;
                const zi = document.getElementById('zone-indicator');
                if (pZone) {
                    zi.textContent = `${pZone.name} \u2014 Lv. ${pZone.levelRange[0]}-${pZone.levelRange[1]}`;
                    zi.style.borderLeft = `3px solid ${pZone.color}`;
                    checkQuestProgress('visit_zone', { zone: pZoneId });
                } else {
                    zi.textContent = 'Wilderness';
                    zi.style.borderLeft = '3px solid #666';
                }
            }

            // Loot piles decay
            for (let i = lootPiles.length - 1; i >= 0; i--) {
                lootPiles[i].timer -= dt;
                if (lootPiles[i].timer <= 0) lootPiles.splice(i, 1);
            }

            // Water
            const v = waterGeo.attributes.position;
            for(let i=0;i<v.count;i++){v.setY(i,Math.sin(v.getX(i)*2+time)*0.02+Math.cos(v.getZ(i)*2+time*1.3)*0.02);}
            v.needsUpdate=true;

            // Fireflies
            particles.forEach(p=>{p.visible=isNight;if(isNight){p.position.y+=Math.sin(time*p.userData.speed+p.userData.offset)*0.003;p.position.x+=Math.sin(time*0.3+p.userData.offset)*0.005;p.material.opacity=0.5+Math.sin(time*2+p.userData.offset)*0.5;}});

            // Overlays
            updateOverlays();
            drawMinimap();
            renderer.render(scene, camera);
        }

        // ============================================================
        // === MULTIPLAYER CHAT (Supabase Realtime) ===
        // ============================================================
        try {
            const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            chatChannel = supabase.channel('agentscape-chat');

            chatChannel.on('broadcast', { event: 'chat' }, ({ payload }) => {
                if (payload.sender === playerName) return;
                addChatMessage('public', payload.message, payload.sender, payload.color);
            });

            chatChannel.on('broadcast', { event: 'presence' }, ({ payload }) => {
                if (payload.name === playerName) return;
                otherPlayers.set(payload.name, { x: payload.x, z: payload.z, color: payload.color, lastSeen: Date.now() });
            });

            chatChannel.subscribe((status) => {
                if (status === 'SUBSCRIBED') {
                    addChatMessage('system', `Connected to multiplayer as ${playerName}`);
                }
            });

            // Broadcast presence every 3 seconds
            setInterval(() => {
                if (chatChannel) {
                    chatChannel.send({ type: 'broadcast', event: 'presence', payload: { name: playerName, x: playerWorldX, z: playerWorldZ, color: playerColor } });
                }
                // Clean stale players (30s timeout)
                const now = Date.now();
                otherPlayers.forEach((p, name) => { if (now - p.lastSeen > 30000) otherPlayers.delete(name); });
            }, 3000);
        } catch (e) {
            addChatMessage('system', 'Multiplayer unavailable (offline mode)');
        }

        // ============================================================
        // === INIT ===
        // ============================================================
        initInventory();
        // Apply class bonuses
        if (charInfo.bonuses) {
            Object.entries(charInfo.bonuses).forEach(([stat, bonus]) => {
                if (playerStats[stat] !== undefined) playerStats[stat] += bonus;
            });
            if (charInfo.bonuses.hitpoints) playerStats.maxHp += charInfo.bonuses.hitpoints * 10;
            playerStats.hp = playerStats.maxHp;
        }
        renderInventory();
        renderStats();
        updateOrbs();
        document.querySelector('.stat-player-name').textContent = playerName;
        addChatMessage('system', `Welcome to AgentScape, ${playerName}! Right-click to interact.`);
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = viewport.clientWidth / viewport.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        });

        // Delete character handler
        window.deleteCharacter = function() {
            if (confirm('Are you sure you want to delete your character? All progress will be lost!')) {
                localStorage.removeItem('agentscape_character');
                location.reload();
            }
        };

        } // end startGame
    })();
    </script>
</body>
</html>
