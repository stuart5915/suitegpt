<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgentScape | SUITE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }

        #ui {
            position: fixed; top: 16px; left: 16px; z-index: 10;
            background: rgba(0,0,0,0.7); border: 1px solid rgba(99,102,241,0.3);
            border-radius: 8px; padding: 12px 16px; color: #ccc; font-size: 12px;
            line-height: 1.6; pointer-events: none;
        }
        #ui h3 { color: #6366f1; margin-bottom: 6px; font-size: 14px; }
        #ui kbd {
            background: rgba(99,102,241,0.2); border: 1px solid rgba(99,102,241,0.4);
            border-radius: 3px; padding: 1px 5px; font-size: 11px; color: #a5b4fc;
        }

        /* Coords + Activity Log */
        #activity-area {
            position: fixed; bottom: 16px; left: 16px; z-index: 10;
            width: 320px;
        }
        #coords {
            background: rgba(0,0,0,0.7); border: 1px solid rgba(99,102,241,0.3);
            border-radius: 8px 8px 0 0; padding: 6px 14px; color: #a5b4fc; font-size: 12px;
            font-family: 'Courier New', monospace; border-bottom: none;
        }
        #activity-log {
            background: rgba(0,0,0,0.75); border: 1px solid rgba(99,102,241,0.3);
            border-radius: 0 0 8px 8px; padding: 8px 12px;
            max-height: 180px; overflow-y: auto; font-size: 11px; line-height: 1.5;
            color: #9ca3af;
        }
        #activity-log::-webkit-scrollbar { width: 4px; }
        #activity-log::-webkit-scrollbar-thumb { background: rgba(99,102,241,0.3); border-radius: 2px; }
        .log-entry { padding: 1px 0; }

        /* Minimap */
        #minimap {
            position: fixed; bottom: 16px; right: 16px; z-index: 10;
            border: 2px solid rgba(99,102,241,0.4); border-radius: 6px;
            background: rgba(0,0,0,0.5);
        }

        /* Day/Night button */
        #daynight {
            position: fixed; top: 16px; right: 16px; z-index: 10;
            background: rgba(0,0,0,0.7); border: 1px solid rgba(99,102,241,0.3);
            border-radius: 8px; padding: 8px 14px; color: #ccc; font-size: 12px;
            cursor: pointer; pointer-events: all;
        }
        #daynight:hover { border-color: #6366f1; color: #fff; }

        /* NPC Labels */
        .npc-label {
            position: absolute; z-index: 15; pointer-events: none;
            font-family: 'Courier New', monospace; font-size: 10px; font-weight: bold;
            color: #fff; text-shadow: 0 0 4px rgba(0,0,0,0.9), 0 1px 2px rgba(0,0,0,0.8);
            white-space: nowrap; transform: translate(-50%, -100%);
            padding: 1px 6px; border-radius: 3px;
            background: rgba(0,0,0,0.5);
        }

        /* Right-side Interaction Panel */
        #interact-panel {
            position: fixed; top: 0; right: -340px; z-index: 20;
            width: 320px; height: 100vh; background: rgba(10,10,15,0.95);
            border-left: 1px solid rgba(99,102,241,0.3);
            transition: right 0.3s ease; padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow-y: auto; color: #ccc;
        }
        #interact-panel.open { right: 0; }
        #interact-panel::-webkit-scrollbar { width: 4px; }
        #interact-panel::-webkit-scrollbar-thumb { background: rgba(99,102,241,0.3); border-radius: 2px; }

        .panel-header {
            padding: 20px; border-bottom: 1px solid rgba(99,102,241,0.2);
            display: flex; align-items: center; gap: 12px;
        }
        .panel-header .panel-icon {
            width: 48px; height: 48px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; flex-shrink: 0;
        }
        .panel-header h2 { font-size: 16px; color: #fff; margin: 0; }
        .panel-header p { font-size: 12px; color: #9ca3af; margin: 2px 0 0; }
        .panel-close {
            position: absolute; top: 14px; right: 14px;
            background: none; border: none; color: #6b7280; font-size: 20px;
            cursor: pointer; width: 28px; height: 28px; display: flex;
            align-items: center; justify-content: center; border-radius: 4px;
        }
        .panel-close:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .panel-section { padding: 16px 20px; border-bottom: 1px solid rgba(99,102,241,0.1); }
        .panel-section h3 { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #6366f1; margin-bottom: 8px; }
        .panel-section p { font-size: 13px; line-height: 1.5; color: #d1d5db; }

        .role-badge {
            display: inline-block; padding: 2px 8px; border-radius: 10px;
            font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .stat-row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 13px; }
        .stat-row .label { color: #9ca3af; }
        .stat-row .value { color: #e5e7eb; font-weight: 600; }

        .visitor-item {
            display: flex; align-items: center; gap: 8px; padding: 6px 0;
            font-size: 12px;
        }
        .visitor-dot {
            width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
        }

        .proposal-item {
            padding: 10px 12px; background: rgba(99,102,241,0.08);
            border-radius: 8px; margin-bottom: 8px; border: 1px solid rgba(99,102,241,0.15);
        }
        .proposal-item h4 { font-size: 13px; color: #e5e7eb; margin-bottom: 4px; }
        .proposal-item p { font-size: 11px; color: #9ca3af; }
        .proposal-status {
            display: inline-block; padding: 1px 6px; border-radius: 8px;
            font-size: 10px; font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h3>AgentScape</h3>
        <kbd>WASD</kbd> Pan camera<br>
        <kbd>Q</kbd><kbd>E</kbd> Rotate camera<br>
        <kbd>Click</kbd> Move / Interact<br>
        <kbd>Scroll</kbd> Zoom in/out
    </div>

    <div id="activity-area">
        <div id="coords">Tile: 15, 15</div>
        <div id="activity-log"></div>
    </div>

    <canvas id="minimap" width="150" height="150"></canvas>
    <div id="daynight">‚òÄÔ∏è Day</div>

    <!-- NPC label container -->
    <div id="npc-labels"></div>

    <!-- Interaction Panel -->
    <div id="interact-panel">
        <button class="panel-close" onclick="closePanel()">&times;</button>
        <div id="panel-content"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    (function() {
        // ============================================================
        // === CONFIG ===
        // ============================================================
        const MAP_SIZE = 30;
        const TILE_SIZE = 1;
        const WATER_LEVEL = -0.15;
        const MOVE_SPEED = 4;
        const NPC_MOVE_SPEED = 2.5;
        const API_BASE = 'https://suitegpt.app';
        const SUPABASE_URL = 'https://kyojtmbjsfkfrdvulbyg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt5b2p0bWJqc2ZrZnJkdnVsYnlnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5MTk1MTksImV4cCI6MjA1MDQ5NTUxOX0.JDUpMbOFIqkexJrSHPAzcmFpMOCbMnMxJE-IuZ8OLFY';

        const ROLE_COLORS = {
            app_builder:     { hex: '#6366f1', int: 0x6366f1, name: 'Builder' },
            app_refiner:     { hex: '#f97316', int: 0xf97316, name: 'Refiner' },
            content_creator: { hex: '#22c55e', int: 0x22c55e, name: 'Creator' },
            growth_outreach: { hex: '#ec4899', int: 0xec4899, name: 'Growth' },
            qa_tester:       { hex: '#eab308', int: 0xeab308, name: 'Tester' },
        };

        // ============================================================
        // === BUILDINGS CONFIG ===
        // ============================================================
        const BUILDINGS = [
            {
                id: 'quest_board', name: 'Quest Board', icon: 'üìã',
                x: 15, z: 13, w: 1, d: 1, h: 1.2,
                wallColor: 0x8B7355, roofColor: 0x6366f1, signColor: '#6366f1',
                doorSide: 'south',
                description: 'View active proposals and bounties from the swarm.',
                type: 'pedestal'
            },
            {
                id: 'workshop', name: 'Workshop', icon: 'üî®',
                x: 20, z: 10, w: 3, d: 2, h: 1.5,
                wallColor: 0xD2B48C, roofColor: 0x6366f1, signColor: '#6366f1',
                doorSide: 'south',
                description: 'Where builders create and refine SUITE apps.'
            },
            {
                id: 'marketplace', name: 'Marketplace', icon: 'üè™',
                x: 10, z: 12, w: 2.5, d: 2, h: 1.3,
                wallColor: 0xBDB76B, roofColor: 0xf97316, signColor: '#f97316',
                doorSide: 'south',
                description: 'The Grand Exchange ‚Äî coming soon.'
            },
            {
                id: 'farm', name: 'Farm', icon: 'üåæ',
                x: 24, z: 16, w: 2, d: 3, h: 1.0,
                wallColor: 0x8FBC8F, roofColor: 0x22c55e, signColor: '#22c55e',
                doorSide: 'west',
                description: 'Yield farming ‚Äî stake and earn. Coming soon.'
            },
            {
                id: 'arena', name: 'Arena', icon: '‚öîÔ∏è',
                x: 12, z: 26, w: 3, d: 3, h: 1.6,
                wallColor: 0xCD853F, roofColor: 0xef4444, signColor: '#ef4444',
                doorSide: 'north',
                description: 'PvP agent dueling arena ‚Äî coming soon.'
            },
            {
                id: 'town_hall', name: 'Town Hall', icon: 'üèõÔ∏è',
                x: 18, z: 6, w: 2.5, d: 2, h: 1.8,
                wallColor: 0xE8DCC8, roofColor: 0x8b5cf6, signColor: '#8b5cf6',
                doorSide: 'south',
                description: 'Governance and escalation center for the swarm.'
            }
        ];

        // Building door tiles (walkable entrance)
        const buildingDoors = {};

        // Role-based building weights for NPC targeting
        const ROLE_BUILDING_WEIGHTS = {
            app_builder:     { workshop: 50, quest_board: 20, town_hall: 15, marketplace: 10, farm: 3, arena: 2 },
            app_refiner:     { workshop: 40, quest_board: 25, town_hall: 15, marketplace: 10, farm: 5, arena: 5 },
            content_creator: { quest_board: 30, marketplace: 25, town_hall: 20, workshop: 15, farm: 5, arena: 5 },
            growth_outreach: { marketplace: 40, quest_board: 25, town_hall: 15, workshop: 10, farm: 5, arena: 5 },
            qa_tester:       { workshop: 35, quest_board: 30, arena: 15, town_hall: 10, marketplace: 5, farm: 5 },
        };

        // ============================================================
        // === SCENE SETUP ===
        // ============================================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.025);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Camera
        let camTargetX = 15, camTargetZ = 15;
        let camAngle = Math.PI / 4;
        let camDist = 18;
        let camHeight = 14;

        function updateCamera() {
            camera.position.set(
                camTargetX + Math.sin(camAngle) * camDist,
                camHeight,
                camTargetZ + Math.cos(camAngle) * camDist
            );
            camera.lookAt(camTargetX, 0, camTargetZ);
        }
        updateCamera();

        // ============================================================
        // === LIGHTING ===
        // ============================================================
        const ambientLight = new THREE.AmbientLight(0x6688aa, 0.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffeedd, 0.9);
        sunLight.position.set(10, 20, 10);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 60;
        sunLight.shadow.camera.left = -20;
        sunLight.shadow.camera.right = 20;
        sunLight.shadow.camera.top = 20;
        sunLight.shadow.camera.bottom = -20;
        scene.add(sunLight);

        const hemiLight = new THREE.HemisphereLight(0x88aacc, 0x445522, 0.3);
        scene.add(hemiLight);

        // ============================================================
        // === DAY/NIGHT ===
        // ============================================================
        let isNight = false;
        const dayNightBtn = document.getElementById('daynight');
        dayNightBtn.addEventListener('click', () => {
            isNight = !isNight;
            if (isNight) {
                scene.background.set(0x0a0a1a);
                scene.fog.color.set(0x0a0a1a);
                ambientLight.intensity = 0.15;
                sunLight.intensity = 0.1;
                sunLight.color.set(0x4466aa);
                hemiLight.intensity = 0.05;
                dayNightBtn.textContent = 'üåô Night';
            } else {
                scene.background.set(0x87CEEB);
                scene.fog.color.set(0x87CEEB);
                ambientLight.intensity = 0.5;
                sunLight.intensity = 0.9;
                sunLight.color.set(0xffeedd);
                hemiLight.intensity = 0.3;
                dayNightBtn.textContent = '‚òÄÔ∏è Day';
            }
        });

        // ============================================================
        // === TERRAIN DATA ===
        // ============================================================
        const grid = [];
        const heightMap = [];

        function seededRandom(seed) {
            let s = seed;
            return function() {
                s = (s * 16807 + 0) % 2147483647;
                return (s - 1) / 2147483646;
            };
        }
        const rng = seededRandom(42);

        function simpleNoise(x, z) {
            return Math.sin(x * 0.3) * Math.cos(z * 0.4) * 0.3 +
                   Math.sin(x * 0.7 + 1) * Math.cos(z * 0.5 + 2) * 0.15;
        }

        // Water zones
        function isWater(x, z) {
            const d1 = Math.sqrt((x - 6) ** 2 + (z - 6) ** 2);
            if (d1 < 3.5) return true;
            const riverZ = 20 + Math.sin(x * 0.4) * 2;
            if (Math.abs(z - riverZ) < 1.5 && x > 5 && x < 28) return true;
            return false;
        }

        // Bridge check ‚Äî tiles near x=14-16 across river are bridged
        function isBridge(x, z) {
            const riverZ = 20 + Math.sin(x * 0.4) * 2;
            if (Math.abs(z - riverZ) < 1.5 && x >= 14 && x <= 16) return true;
            return false;
        }

        // Check if tile is inside a building zone
        function isInBuildingZone(x, z) {
            for (const b of BUILDINGS) {
                const hw = b.w / 2, hd = b.d / 2;
                if (x >= b.x - hw - 0.5 && x <= b.x + hw + 0.5 &&
                    z >= b.z - hd - 0.5 && z <= b.z + hd + 0.5) {
                    return true;
                }
            }
            return false;
        }

        // Build grid
        for (let x = 0; x < MAP_SIZE; x++) {
            grid[x] = [];
            heightMap[x] = [];
            for (let z = 0; z < MAP_SIZE; z++) {
                const water = isWater(x, z);
                const bridge = isBridge(x, z);
                if (bridge) {
                    grid[x][z] = 3; // bridge tile
                    heightMap[x][z] = 0.05;
                } else if (water) {
                    grid[x][z] = 0;
                    heightMap[x][z] = WATER_LEVEL;
                } else {
                    const h = simpleNoise(x, z) * 0.2;
                    grid[x][z] = 1;
                    heightMap[x][z] = h;
                }
            }
        }

        // ============================================================
        // === TERRAIN MESH ===
        // ============================================================
        const grassColors = [0x4a7c3f, 0x528745, 0x5d9248, 0x4b8040, 0x3f7035];
        const dirtColors = [0x8B7355, 0x7a6548, 0x6d5b40];
        const waterColor = 0x2288aa;
        const sandColor = 0xc2b280;
        const bridgeColor = 0x8B6914;

        const tileMeshes = [];

        for (let x = 0; x < MAP_SIZE; x++) {
            tileMeshes[x] = [];
            for (let z = 0; z < MAP_SIZE; z++) {
                const h = heightMap[x][z];
                let color;

                if (grid[x][z] === 3) {
                    // Bridge
                    color = bridgeColor;
                } else if (isWater(x, z)) {
                    color = waterColor;
                } else {
                    let nearWater = false;
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            const nx = x + dx, nz = z + dz;
                            if (nx >= 0 && nx < MAP_SIZE && nz >= 0 && nz < MAP_SIZE && isWater(nx, nz) && !isBridge(nx, nz)) {
                                nearWater = true;
                            }
                        }
                    }
                    if (nearWater) {
                        color = sandColor;
                    } else {
                        const pathZ = 15 + Math.sin(x * 0.3) * 1.5;
                        if (Math.abs(z - pathZ) < 0.8 && x > 3 && x < 27) {
                            color = dirtColors[Math.floor(rng() * dirtColors.length)];
                            grid[x][z] = 2; // path
                        } else {
                            color = grassColors[Math.floor(rng() * grassColors.length)];
                        }
                    }
                }

                const geo = new THREE.BoxGeometry(TILE_SIZE, grid[x][z] === 3 ? 0.15 : 0.3, TILE_SIZE);
                const mat = new THREE.MeshLambertMaterial({ color: color });
                const tile = new THREE.Mesh(geo, mat);
                tile.position.set(x, h - 0.15, z);
                tile.receiveShadow = true;
                tile.userData = { tileX: x, tileZ: z, walkable: grid[x][z] > 0, type: 'tile' };
                scene.add(tile);
                tileMeshes[x][z] = tile;
            }
        }

        // Bridge railings
        for (let x = 14; x <= 16; x++) {
            for (const side of [-1, 1]) {
                const riverZ = 20 + Math.sin(x * 0.4) * 2;
                const rz = Math.round(riverZ + side * 1.3);
                if (rz >= 0 && rz < MAP_SIZE) {
                    const railGeo = new THREE.BoxGeometry(0.08, 0.4, 0.08);
                    const railMat = new THREE.MeshLambertMaterial({ color: 0x5a3a1a });
                    const rail = new THREE.Mesh(railGeo, railMat);
                    rail.position.set(x, 0.25, rz);
                    rail.castShadow = true;
                    scene.add(rail);
                }
            }
        }

        // ============================================================
        // === WATER SURFACE ===
        // ============================================================
        const waterGeo = new THREE.PlaneGeometry(30, 30, 30, 30);
        const waterMat = new THREE.MeshLambertMaterial({
            color: 0x2288aa, transparent: true, opacity: 0.6
        });
        const waterMesh = new THREE.Mesh(waterGeo, waterMat);
        waterMesh.rotation.x = -Math.PI / 2;
        waterMesh.position.set(14.5, WATER_LEVEL + 0.05, 14.5);
        scene.add(waterMesh);

        // ============================================================
        // === TREES (avoid building zones) ===
        // ============================================================
        const treePositions = [];
        for (let i = 0; i < 40; i++) {
            const x = Math.floor(rng() * MAP_SIZE);
            const z = Math.floor(rng() * MAP_SIZE);
            if (grid[x][z] > 0 && !isWater(x, z) && !isInBuildingZone(x, z)) {
                if (grid[x][z] === 2 || grid[x][z] === 3) continue;
                if (Math.abs(x - 15) < 3 && Math.abs(z - 15) < 3) continue;
                treePositions.push({ x, z });
                grid[x][z] = 0;
            }
        }

        function createTree(x, z, variant) {
            const group = new THREE.Group();
            const h = heightMap[x][z];
            const trunkH = 0.6 + rng() * 0.4;
            const trunkGeo = new THREE.CylinderGeometry(0.08, 0.12, trunkH, 5);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x6B4226 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = trunkH / 2;
            trunk.castShadow = true;
            group.add(trunk);

            if (variant === 0) {
                const sizes = [0.5, 0.4, 0.28];
                const greens = [0x2d5a1e, 0x3a6e28, 0x468032];
                sizes.forEach((s, i) => {
                    const coneGeo = new THREE.ConeGeometry(s, 0.5, 5);
                    const coneMat = new THREE.MeshLambertMaterial({ color: greens[i] });
                    const cone = new THREE.Mesh(coneGeo, coneMat);
                    cone.position.y = trunkH + 0.15 + i * 0.35;
                    cone.castShadow = true;
                    group.add(cone);
                });
            } else if (variant === 1) {
                const leafGeo = new THREE.DodecahedronGeometry(0.45, 0);
                const leafMat = new THREE.MeshLambertMaterial({ color: 0x3a8030 });
                const leaves = new THREE.Mesh(leafGeo, leafMat);
                leaves.position.y = trunkH + 0.35;
                leaves.castShadow = true;
                group.add(leaves);
            } else {
                const bushGeo = new THREE.IcosahedronGeometry(0.35, 0);
                const bushMat = new THREE.MeshLambertMaterial({ color: 0x2a6a20 });
                const bush = new THREE.Mesh(bushGeo, bushMat);
                bush.position.y = trunkH + 0.2;
                bush.castShadow = true;
                group.add(bush);
            }

            group.position.set(x, h, z);
            scene.add(group);
        }

        treePositions.forEach(p => createTree(p.x, p.z, Math.floor(rng() * 3)));

        // ============================================================
        // === ROCKS (avoid building zones) ===
        // ============================================================
        for (let i = 0; i < 15; i++) {
            const x = Math.floor(rng() * MAP_SIZE);
            const z = Math.floor(rng() * MAP_SIZE);
            if (grid[x][z] > 0 && !isWater(x, z) && !isInBuildingZone(x, z)) {
                const rockGeo = new THREE.DodecahedronGeometry(0.15 + rng() * 0.15, 0);
                const rockMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const rock = new THREE.Mesh(rockGeo, rockMat);
                rock.position.set(x + rng() * 0.3, heightMap[x][z] + 0.1, z + rng() * 0.3);
                rock.rotation.set(rng(), rng(), rng());
                rock.castShadow = true;
                scene.add(rock);
            }
        }

        // ============================================================
        // === FLOWERS (avoid building zones) ===
        // ============================================================
        for (let i = 0; i < 25; i++) {
            const x = Math.floor(rng() * MAP_SIZE);
            const z = Math.floor(rng() * MAP_SIZE);
            if (grid[x][z] > 0 && !isWater(x, z) && !isInBuildingZone(x, z)) {
                const flowerColors = [0xff6b9d, 0xffd93d, 0xff8a5c, 0xc084fc, 0xfb7185];
                const fGeo = new THREE.SphereGeometry(0.06, 4, 4);
                const fMat = new THREE.MeshLambertMaterial({ color: flowerColors[Math.floor(rng() * flowerColors.length)] });
                const flower = new THREE.Mesh(fGeo, fMat);
                flower.position.set(x + rng() * 0.6 - 0.3, heightMap[x][z] + 0.15, z + rng() * 0.6 - 0.3);
                scene.add(flower);
            }
        }

        // ============================================================
        // === NAMED BUILDINGS ===
        // ============================================================
        const buildingMeshes = []; // { mesh, data } for raycasting

        function createNamedBuilding(bData) {
            const group = new THREE.Group();
            const baseH = heightMap[Math.min(Math.floor(bData.x), MAP_SIZE-1)][Math.min(Math.floor(bData.z), MAP_SIZE-1)] || 0;

            if (bData.type === 'pedestal') {
                // Quest Board ‚Äî special pedestal with sign
                const baseGeo = new THREE.CylinderGeometry(0.4, 0.5, 0.6, 6);
                const baseMat = new THREE.MeshLambertMaterial({ color: bData.wallColor });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 0.3;
                base.castShadow = true;
                group.add(base);

                // Board on top
                const boardGeo = new THREE.BoxGeometry(0.7, 0.5, 0.08);
                const boardMat = new THREE.MeshLambertMaterial({ color: 0x5a3a1a });
                const board = new THREE.Mesh(boardGeo, boardMat);
                board.position.y = 0.85;
                board.castShadow = true;
                group.add(board);

                // Pin marks on board
                const pinColors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44];
                pinColors.forEach((c, i) => {
                    const pinGeo = new THREE.SphereGeometry(0.04, 4, 4);
                    const pinMat = new THREE.MeshBasicMaterial({ color: c });
                    const pin = new THREE.Mesh(pinGeo, pinMat);
                    pin.position.set(-0.2 + (i % 2) * 0.4, 0.75 + Math.floor(i / 2) * 0.2, 0.05);
                    group.add(pin);
                });

                // Only block the center tile
                const cx = Math.floor(bData.x);
                const cz = Math.floor(bData.z);
                if (cx >= 0 && cx < MAP_SIZE && cz >= 0 && cz < MAP_SIZE) {
                    grid[cx][cz] = 0;
                }

                // Door tile (walkable approach from south)
                buildingDoors[bData.id] = { x: cx, z: cz + 1 };

            } else {
                // Standard building
                const wallGeo = new THREE.BoxGeometry(bData.w, bData.h, bData.d);
                const wallMat = new THREE.MeshLambertMaterial({ color: bData.wallColor });
                const walls = new THREE.Mesh(wallGeo, wallMat);
                walls.position.y = bData.h / 2;
                walls.castShadow = true;
                walls.receiveShadow = true;
                group.add(walls);

                // Roof
                const roofGeo = new THREE.ConeGeometry(Math.max(bData.w, bData.d) * 0.75, bData.h * 0.5, 4);
                const roofMat = new THREE.MeshLambertMaterial({ color: bData.roofColor });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = bData.h + bData.h * 0.2;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                group.add(roof);

                // Door
                let doorPos, doorRot;
                const doorGeo = new THREE.BoxGeometry(0.3, 0.5, 0.05);
                const doorMat = new THREE.MeshLambertMaterial({ color: 0x5a3a1a });
                const door = new THREE.Mesh(doorGeo, doorMat);

                switch (bData.doorSide) {
                    case 'south': door.position.set(0, 0.25, bData.d / 2 + 0.02); break;
                    case 'north': door.position.set(0, 0.25, -bData.d / 2 - 0.02); break;
                    case 'west': door.position.set(-bData.w / 2 - 0.02, 0.25, 0); door.rotation.y = Math.PI / 2; break;
                    case 'east': door.position.set(bData.w / 2 + 0.02, 0.25, 0); door.rotation.y = Math.PI / 2; break;
                }
                group.add(door);

                // Block tiles under building
                const hw = Math.ceil(bData.w / 2);
                const hd = Math.ceil(bData.d / 2);
                for (let bx = Math.floor(bData.x) - hw; bx <= Math.floor(bData.x) + hw; bx++) {
                    for (let bz = Math.floor(bData.z) - hd; bz <= Math.floor(bData.z) + hd; bz++) {
                        if (bx >= 0 && bx < MAP_SIZE && bz >= 0 && bz < MAP_SIZE) {
                            grid[bx][bz] = 0;
                        }
                    }
                }

                // Set door tile walkable
                let doorTile;
                switch (bData.doorSide) {
                    case 'south': doorTile = { x: Math.floor(bData.x), z: Math.floor(bData.z) + hd + 1 }; break;
                    case 'north': doorTile = { x: Math.floor(bData.x), z: Math.floor(bData.z) - hd - 1 }; break;
                    case 'west':  doorTile = { x: Math.floor(bData.x) - hw - 1, z: Math.floor(bData.z) }; break;
                    case 'east':  doorTile = { x: Math.floor(bData.x) + hw + 1, z: Math.floor(bData.z) }; break;
                }
                if (doorTile && doorTile.x >= 0 && doorTile.x < MAP_SIZE && doorTile.z >= 0 && doorTile.z < MAP_SIZE) {
                    grid[doorTile.x][doorTile.z] = 1;
                    buildingDoors[bData.id] = doorTile;
                }
            }

            group.position.set(bData.x, baseH, bData.z);

            // Make the group raycastable by adding userData to children
            group.traverse(child => {
                if (child.isMesh) {
                    child.userData.buildingId = bData.id;
                    child.userData.type = 'building';
                }
            });

            scene.add(group);
            buildingMeshes.push({ group, data: bData });

            return group;
        }

        BUILDINGS.forEach(b => createNamedBuilding(b));

        // ============================================================
        // === PLAYER CHARACTER ===
        // ============================================================
        const playerGroup = new THREE.Group();

        const bodyGeo = new THREE.BoxGeometry(0.3, 0.5, 0.2);
        const bodyMat = new THREE.MeshLambertMaterial({ color: 0x3355aa });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.5;
        body.castShadow = true;
        playerGroup.add(body);

        const headGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        const headMat = new THREE.MeshLambertMaterial({ color: 0xffcc99 });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 0.9;
        head.castShadow = true;
        playerGroup.add(head);

        const legGeo = new THREE.BoxGeometry(0.1, 0.3, 0.15);
        const legMat = new THREE.MeshLambertMaterial({ color: 0x554433 });
        const leftLeg = new THREE.Mesh(legGeo, legMat);
        leftLeg.position.set(-0.08, 0.15, 0);
        playerGroup.add(leftLeg);
        const rightLeg = new THREE.Mesh(legGeo, legMat);
        rightLeg.position.set(0.08, 0.15, 0);
        playerGroup.add(rightLeg);

        const armGeo = new THREE.BoxGeometry(0.08, 0.35, 0.1);
        const armMat = new THREE.MeshLambertMaterial({ color: 0x3355aa });
        const leftArm = new THREE.Mesh(armGeo, armMat);
        leftArm.position.set(-0.22, 0.5, 0);
        playerGroup.add(leftArm);
        const rightArm = new THREE.Mesh(armGeo, armMat);
        rightArm.position.set(0.22, 0.5, 0);
        playerGroup.add(rightArm);

        const shadowGeo = new THREE.CircleGeometry(0.2, 8);
        const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.2 });
        const playerShadow = new THREE.Mesh(shadowGeo, shadowMat);
        playerShadow.rotation.x = -Math.PI / 2;
        playerShadow.position.y = 0.02;
        playerGroup.add(playerShadow);

        let playerTileX = 15, playerTileZ = 15;
        let playerWorldX = 15, playerWorldZ = 15;
        playerGroup.position.set(15, heightMap[15][15], 15);
        scene.add(playerGroup);

        // ============================================================
        // === TILE HIGHLIGHT ===
        // ============================================================
        const highlightGeo = new THREE.BoxGeometry(TILE_SIZE, 0.02, TILE_SIZE);
        const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.3 });
        const highlight = new THREE.Mesh(highlightGeo, highlightMat);
        highlight.visible = false;
        scene.add(highlight);

        // ============================================================
        // === A* PATHFINDING ===
        // ============================================================
        function findPath(sx, sz, ex, ez) {
            if (ex < 0 || ex >= MAP_SIZE || ez < 0 || ez >= MAP_SIZE) return [];
            if (grid[ex][ez] === 0) return [];

            const open = [];
            const closed = new Set();
            const cameFrom = {};

            function key(x, z) { return x + ',' + z; }
            function heuristic(x, z) { return Math.abs(x - ex) + Math.abs(z - ez); }

            open.push({ x: sx, z: sz, g: 0, f: heuristic(sx, sz) });

            while (open.length > 0) {
                open.sort((a, b) => a.f - b.f);
                const current = open.shift();
                const ck = key(current.x, current.z);

                if (current.x === ex && current.z === ez) {
                    const path = [];
                    let k = ck;
                    while (k) {
                        const [px, pz] = k.split(',').map(Number);
                        path.unshift({ x: px, z: pz });
                        k = cameFrom[k];
                    }
                    return path;
                }

                closed.add(ck);

                const neighbors = [
                    { x: current.x + 1, z: current.z },
                    { x: current.x - 1, z: current.z },
                    { x: current.x, z: current.z + 1 },
                    { x: current.x, z: current.z - 1 },
                ];

                for (const n of neighbors) {
                    if (n.x < 0 || n.x >= MAP_SIZE || n.z < 0 || n.z >= MAP_SIZE) continue;
                    if (grid[n.x][n.z] === 0) continue;
                    const nk = key(n.x, n.z);
                    if (closed.has(nk)) continue;

                    const g = current.g + 1;
                    const existing = open.find(o => key(o.x, o.z) === nk);
                    if (existing && g >= existing.g) continue;

                    cameFrom[nk] = ck;
                    if (existing) {
                        existing.g = g;
                        existing.f = g + heuristic(n.x, n.z);
                    } else {
                        open.push({ x: n.x, z: n.z, g: g, f: g + heuristic(n.x, n.z) });
                    }
                }
            }
            return [];
        }

        // ============================================================
        // === PLAYER MOVEMENT ===
        // ============================================================
        let currentPath = [];
        let pathIndex = 0;
        let isMoving = false;
        let moveProgress = 0;
        let moveFromX, moveFromZ, moveToX, moveToZ;
        let walkCycle = 0;

        function startMoveTo(path) {
            if (path.length < 2) return;
            currentPath = path;
            pathIndex = 1;
            isMoving = true;
            moveProgress = 0;
            moveFromX = currentPath[0].x;
            moveFromZ = currentPath[0].z;
            moveToX = currentPath[1].x;
            moveToZ = currentPath[1].z;
        }

        // ============================================================
        // === NPC CHARACTER FACTORY ===
        // ============================================================
        const npcRegistry = new Map(); // id -> { group, data, state, ... }
        const npcLabelContainer = document.getElementById('npc-labels');
        let pathfindingQueue = [];

        function createNPCCharacter(agentData) {
            const role = agentData.role || 'app_builder';
            const roleInfo = ROLE_COLORS[role] || ROLE_COLORS.app_builder;
            const scale = 0.85;

            const group = new THREE.Group();
            group.scale.set(scale, scale, scale);

            // Body
            const bGeo = new THREE.BoxGeometry(0.3, 0.5, 0.2);
            const bMat = new THREE.MeshLambertMaterial({ color: roleInfo.int });
            const npcBody = new THREE.Mesh(bGeo, bMat);
            npcBody.position.y = 0.5;
            npcBody.castShadow = true;
            group.add(npcBody);

            // Head
            const hGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
            const hMat = new THREE.MeshLambertMaterial({ color: 0xffcc99 });
            const npcHead = new THREE.Mesh(hGeo, hMat);
            npcHead.position.y = 0.9;
            npcHead.castShadow = true;
            group.add(npcHead);

            // Legs
            const lGeo = new THREE.BoxGeometry(0.1, 0.3, 0.15);
            const lMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const npcLL = new THREE.Mesh(lGeo, lMat);
            npcLL.position.set(-0.08, 0.15, 0);
            group.add(npcLL);
            const npcRL = new THREE.Mesh(lGeo, lMat);
            npcRL.position.set(0.08, 0.15, 0);
            group.add(npcRL);

            // Arms
            const aGeo = new THREE.BoxGeometry(0.08, 0.35, 0.1);
            const aMat = new THREE.MeshLambertMaterial({ color: roleInfo.int });
            const npcLA = new THREE.Mesh(aGeo, aMat);
            npcLA.position.set(-0.22, 0.5, 0);
            group.add(npcLA);
            const npcRA = new THREE.Mesh(aGeo, aMat);
            npcRA.position.set(0.22, 0.5, 0);
            group.add(npcRA);

            // Shadow
            const sGeo = new THREE.CircleGeometry(0.18, 8);
            const sMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.15 });
            const npcShadow = new THREE.Mesh(sGeo, sMat);
            npcShadow.rotation.x = -Math.PI / 2;
            npcShadow.position.y = 0.02;
            group.add(npcShadow);

            // Make raycastable
            group.traverse(child => {
                if (child.isMesh) {
                    child.userData.npcId = agentData.id;
                    child.userData.type = 'npc';
                }
            });

            // Starting position ‚Äî random walkable tile
            let startX, startZ;
            for (let attempts = 0; attempts < 50; attempts++) {
                startX = Math.floor(Math.random() * MAP_SIZE);
                startZ = Math.floor(Math.random() * MAP_SIZE);
                if (grid[startX][startZ] > 0) break;
            }

            group.position.set(startX, heightMap[startX][startZ], startZ);
            scene.add(group);

            // HTML label
            const label = document.createElement('div');
            label.className = 'npc-label';
            label.textContent = agentData.display_name || agentData.agent_name || agentData.id;
            label.style.borderBottom = `2px solid ${roleInfo.hex}`;
            npcLabelContainer.appendChild(label);

            const npc = {
                id: agentData.id,
                group: group,
                data: agentData,
                role: role,
                roleInfo: roleInfo,
                label: label,
                // Body parts for animation
                body: npcBody, leftLeg: npcLL, rightLeg: npcRL, leftArm: npcLA, rightArm: npcRA,
                // Position
                tileX: startX, tileZ: startZ,
                worldX: startX, worldZ: startZ,
                // State machine
                state: 'IDLE',
                stateTimer: 3 + Math.random() * 5,
                targetBuilding: null,
                path: [],
                pathIndex: 0,
                moveProgress: 0,
                moveFromX: 0, moveFromZ: 0, moveToX: 0, moveToZ: 0,
                walkCycle: Math.random() * Math.PI * 2,
                workTimer: 0,
            };

            npcRegistry.set(agentData.id, npc);
            return npc;
        }

        function despawnNPC(id) {
            const npc = npcRegistry.get(id);
            if (!npc) return;
            scene.remove(npc.group);
            npc.label.remove();
            npcRegistry.delete(id);
        }

        // ============================================================
        // === NPC BEHAVIOR AI ===
        // ============================================================
        function chooseTargetBuilding(npc) {
            const weights = ROLE_BUILDING_WEIGHTS[npc.role] || ROLE_BUILDING_WEIGHTS.app_builder;
            const entries = Object.entries(weights);
            const total = entries.reduce((s, [, w]) => s + w, 0);
            let r = Math.random() * total;
            for (const [buildingId, weight] of entries) {
                r -= weight;
                if (r <= 0) return buildingId;
            }
            return entries[0][0];
        }

        function updateNPCState(npc, dt) {
            switch (npc.state) {
                case 'IDLE':
                    npc.stateTimer -= dt;
                    // Breathing animation
                    npc.body.position.y = 0.5 + Math.sin(Date.now() * 0.003 + npc.walkCycle) * 0.01;
                    if (npc.stateTimer <= 0) {
                        npc.state = 'CHOOSING';
                    }
                    break;

                case 'CHOOSING': {
                    const targetId = chooseTargetBuilding(npc);
                    npc.targetBuilding = targetId;
                    const door = buildingDoors[targetId];
                    if (door) {
                        // Queue pathfinding
                        pathfindingQueue.push({ npc, targetX: door.x, targetZ: door.z });
                    }
                    npc.state = 'WAITING_PATH';
                    npc.stateTimer = 10; // timeout
                    break;
                }

                case 'WAITING_PATH':
                    npc.stateTimer -= dt;
                    if (npc.path.length > 1) {
                        npc.state = 'WALKING';
                        npc.pathIndex = 1;
                        npc.moveProgress = 0;
                        npc.moveFromX = npc.path[0].x;
                        npc.moveFromZ = npc.path[0].z;
                        npc.moveToX = npc.path[1].x;
                        npc.moveToZ = npc.path[1].z;

                        const bData = BUILDINGS.find(b => b.id === npc.targetBuilding);
                        const name = npc.data.display_name || npc.data.agent_name || npc.id;
                        addLogEntry(name, npc.roleInfo.hex, `is heading to the ${bData ? bData.name : 'unknown'}`);
                    } else if (npc.stateTimer <= 0) {
                        npc.state = 'IDLE';
                        npc.stateTimer = 3 + Math.random() * 5;
                    }
                    break;

                case 'WALKING':
                    npc.moveProgress += dt * NPC_MOVE_SPEED;
                    npc.walkCycle += dt * 10;

                    // Walking animation
                    const legSwing = Math.sin(npc.walkCycle) * 0.3;
                    npc.leftLeg.rotation.x = legSwing;
                    npc.rightLeg.rotation.x = -legSwing;
                    npc.leftArm.rotation.x = -legSwing * 0.6;
                    npc.rightArm.rotation.x = legSwing * 0.6;
                    npc.body.position.y = 0.5 + Math.abs(Math.sin(npc.walkCycle)) * 0.03;

                    if (npc.moveProgress >= 1) {
                        npc.moveProgress = 0;
                        npc.tileX = npc.moveToX;
                        npc.tileZ = npc.moveToZ;
                        npc.worldX = npc.moveToX;
                        npc.worldZ = npc.moveToZ;
                        npc.pathIndex++;

                        if (npc.pathIndex < npc.path.length) {
                            npc.moveFromX = npc.moveToX;
                            npc.moveFromZ = npc.moveToZ;
                            npc.moveToX = npc.path[npc.pathIndex].x;
                            npc.moveToZ = npc.path[npc.pathIndex].z;
                        } else {
                            // Arrived
                            npc.state = 'WORKING';
                            npc.workTimer = 5 + Math.random() * 10;
                            npc.path = [];

                            // Reset pose
                            npc.leftLeg.rotation.x = 0;
                            npc.rightLeg.rotation.x = 0;
                            npc.leftArm.rotation.x = 0;
                            npc.rightArm.rotation.x = 0;
                            npc.body.position.y = 0.5;

                            // Face the building
                            const bData = BUILDINGS.find(b => b.id === npc.targetBuilding);
                            if (bData) {
                                const angle = Math.atan2(bData.x - npc.tileX, bData.z - npc.tileZ);
                                npc.group.rotation.y = angle;
                            }

                            const name = npc.data.display_name || npc.data.agent_name || npc.id;
                            addLogEntry(name, npc.roleInfo.hex, `is working at the ${bData ? bData.name : 'unknown'}`);
                        }
                    }

                    if (npc.state === 'WALKING') {
                        const lx = npc.moveFromX + (npc.moveToX - npc.moveFromX) * npc.moveProgress;
                        const lz = npc.moveFromZ + (npc.moveToZ - npc.moveFromZ) * npc.moveProgress;
                        npc.worldX = lx;
                        npc.worldZ = lz;

                        const fromH = heightMap[npc.moveFromX] ? heightMap[npc.moveFromX][npc.moveFromZ] || 0 : 0;
                        const toH = heightMap[npc.moveToX] ? heightMap[npc.moveToX][npc.moveToZ] || 0 : 0;
                        const lerpH = fromH + (toH - fromH) * npc.moveProgress;

                        npc.group.position.set(lx, lerpH, lz);

                        const angle = Math.atan2(npc.moveToX - npc.moveFromX, npc.moveToZ - npc.moveFromZ);
                        npc.group.rotation.y = angle;
                    }
                    break;

                case 'WORKING':
                    npc.workTimer -= dt;
                    // Subtle work animation
                    npc.rightArm.rotation.x = Math.sin(Date.now() * 0.005) * 0.2;
                    npc.body.position.y = 0.5 + Math.sin(Date.now() * 0.004) * 0.008;

                    if (npc.workTimer <= 0) {
                        npc.state = 'IDLE';
                        npc.stateTimer = 3 + Math.random() * 5;
                        npc.rightArm.rotation.x = 0;
                    }
                    break;
            }
        }

        // Process pathfinding queue (max 2 per frame)
        function processPathfindingQueue() {
            let processed = 0;
            while (pathfindingQueue.length > 0 && processed < 2) {
                const req = pathfindingQueue.shift();
                const npc = req.npc;
                const path = findPath(npc.tileX, npc.tileZ, req.targetX, req.targetZ);
                npc.path = path;
                processed++;
            }
        }

        // ============================================================
        // === ACTIVITY LOG ===
        // ============================================================
        const logEl = document.getElementById('activity-log');
        let logEntries = [];

        function addLogEntry(agentName, color, action) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span style="color:${color};font-weight:bold">${agentName}</span> ${action}`;
            logEl.appendChild(entry);
            logEntries.push(entry);

            // Max 20 entries
            while (logEntries.length > 20) {
                const old = logEntries.shift();
                old.remove();
            }

            logEl.scrollTop = logEl.scrollHeight;
        }

        // ============================================================
        // === INTERACTION PANEL ===
        // ============================================================
        const interactPanel = document.getElementById('interact-panel');
        const panelContent = document.getElementById('panel-content');
        let panelOpen = false;
        let selectedNPC = null;
        let selectedBuilding = null;

        window.closePanel = function() {
            interactPanel.classList.remove('open');
            panelOpen = false;
            selectedNPC = null;
            selectedBuilding = null;
        };

        function openBuildingPanel(bData) {
            selectedBuilding = bData;
            selectedNPC = null;

            // Find visitors (NPCs working at this building)
            const visitors = [];
            npcRegistry.forEach(npc => {
                if (npc.targetBuilding === bData.id && (npc.state === 'WORKING' || npc.state === 'WALKING')) {
                    visitors.push(npc);
                }
            });

            let visitorsHTML = '';
            if (visitors.length > 0) {
                visitorsHTML = visitors.map(v => {
                    const name = v.data.display_name || v.data.agent_name || v.id;
                    return `<div class="visitor-item">
                        <div class="visitor-dot" style="background:${v.roleInfo.hex}"></div>
                        <span>${name}</span>
                        <span style="color:#6b7280;margin-left:auto;font-size:10px">${v.roleInfo.name}</span>
                    </div>`;
                }).join('');
            } else {
                visitorsHTML = '<p style="color:#6b7280;font-size:12px">No visitors right now</p>';
            }

            let extraHTML = '';
            if (bData.id === 'quest_board') {
                extraHTML = `<div class="panel-section"><h3>Recent Proposals</h3><div id="proposals-list"><p style="color:#6b7280;font-size:12px">Loading...</p></div></div>`;
                fetchProposals();
            }

            panelContent.innerHTML = `
                <div class="panel-header">
                    <div class="panel-icon" style="background:${bData.signColor}22;border:1px solid ${bData.signColor}44;font-size:28px">${bData.icon}</div>
                    <div>
                        <h2>${bData.name}</h2>
                        <p>${bData.description}</p>
                    </div>
                </div>
                <div class="panel-section">
                    <h3>Visitors (${visitors.length})</h3>
                    ${visitorsHTML}
                </div>
                ${extraHTML}
            `;

            interactPanel.classList.add('open');
            panelOpen = true;
        }

        function openNPCPanel(npc) {
            selectedNPC = npc;
            selectedBuilding = null;

            const name = npc.data.display_name || npc.data.agent_name || npc.id;
            const roleInfo = npc.roleInfo;
            const status = npc.state === 'WORKING' ? 'Working' : npc.state === 'WALKING' ? 'Walking' : 'Idle';
            const targetBData = npc.targetBuilding ? BUILDINGS.find(b => b.id === npc.targetBuilding) : null;

            panelContent.innerHTML = `
                <div class="panel-header">
                    <div class="panel-icon" style="background:${roleInfo.hex}22;border:1px solid ${roleInfo.hex}44;font-size:28px">ü§ñ</div>
                    <div>
                        <h2>${name}</h2>
                        <p><span class="role-badge" style="background:${roleInfo.hex}22;color:${roleInfo.hex};border:1px solid ${roleInfo.hex}44">${roleInfo.name}</span></p>
                    </div>
                </div>
                <div class="panel-section">
                    <h3>Status</h3>
                    <div class="stat-row"><span class="label">State</span><span class="value">${status}</span></div>
                    ${targetBData ? `<div class="stat-row"><span class="label">Location</span><span class="value">${targetBData.name}</span></div>` : ''}
                    <div class="stat-row"><span class="label">Position</span><span class="value">(${npc.tileX}, ${npc.tileZ})</span></div>
                </div>
                <div class="panel-section">
                    <h3>Agent Details</h3>
                    <div class="stat-row"><span class="label">Type</span><span class="value">${npc.data.agent_type || 'unknown'}</span></div>
                    <div class="stat-row"><span class="label">Role</span><span class="value">${npc.role}</span></div>
                    ${npc.data.objective ? `<div class="stat-row"><span class="label">Objective</span><span class="value" style="max-width:180px;text-align:right">${npc.data.objective}</span></div>` : ''}
                    ${npc.data.proposals_count !== undefined ? `<div class="stat-row"><span class="label">Proposals</span><span class="value">${npc.data.proposals_count}</span></div>` : ''}
                    ${npc.data.credits_earned !== undefined ? `<div class="stat-row"><span class="label">Credits</span><span class="value">${npc.data.credits_earned}</span></div>` : ''}
                </div>
            `;

            interactPanel.classList.add('open');
            panelOpen = true;
        }

        // ============================================================
        // === API INTEGRATION ===
        // ============================================================
        let lastAgentFetch = 0;
        let proposalsCache = null;
        let proposalsCacheTime = 0;

        const DEMO_AGENTS = [
            { id: 'demo-1', agent_name: 'BuilderBot', display_name: 'BuilderBot', role: 'app_builder', agent_type: 'hosted', objective: 'Build SUITE apps' },
            { id: 'demo-2', agent_name: 'RefinerX', display_name: 'RefinerX', role: 'app_refiner', agent_type: 'cli', objective: 'Refine existing apps' },
            { id: 'demo-3', agent_name: 'ContentAI', display_name: 'ContentAI', role: 'content_creator', agent_type: 'hosted', objective: 'Write articles' },
            { id: 'demo-4', agent_name: 'GrowthBot', display_name: 'GrowthBot', role: 'growth_outreach', agent_type: 'hosted', objective: 'Drive user growth' },
            { id: 'demo-5', agent_name: 'TestRunner', display_name: 'TestRunner', role: 'qa_tester', agent_type: 'cli', objective: 'Test all the things' },
        ];

        async function fetchAgents() {
            try {
                const res = await fetch(`${API_BASE}/api/swarm/agents?limit=50`);
                if (!res.ok) throw new Error('API error');
                const data = await res.json();
                const agents = data.agents || data;
                if (Array.isArray(agents) && agents.length > 0) {
                    syncNPCs(agents);
                    return;
                }
            } catch (e) {
                // Fallback to demo
            }
            // Use demo agents if API fails or returns nothing
            if (npcRegistry.size === 0) {
                syncNPCs(DEMO_AGENTS);
                addLogEntry('System', '#6366f1', 'loaded demo agents (API unavailable)');
            }
        }

        function syncNPCs(agents) {
            const agentIds = new Set(agents.map(a => a.id));

            // Despawn removed agents
            npcRegistry.forEach((npc, id) => {
                if (!agentIds.has(id)) despawnNPC(id);
            });

            // Spawn/update
            agents.forEach(agent => {
                if (!npcRegistry.has(agent.id)) {
                    createNPCCharacter(agent);
                } else {
                    // Update data
                    const npc = npcRegistry.get(agent.id);
                    npc.data = agent;
                }
            });
        }

        async function fetchProposals() {
            const now = Date.now();
            if (proposalsCache && (now - proposalsCacheTime) < 120000) {
                renderProposals(proposalsCache);
                return;
            }

            try {
                const res = await fetch(
                    `${SUPABASE_URL}/rest/v1/factory_proposals?select=id,title,description,status,created_at&order=created_at.desc&limit=5`,
                    { headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': `Bearer ${SUPABASE_ANON_KEY}` } }
                );
                if (!res.ok) throw new Error('Supabase error');
                const data = await res.json();
                proposalsCache = data;
                proposalsCacheTime = now;
                renderProposals(data);
            } catch (e) {
                const listEl = document.getElementById('proposals-list');
                if (listEl) listEl.innerHTML = '<p style="color:#6b7280;font-size:12px">Could not load proposals</p>';
            }
        }

        function renderProposals(proposals) {
            const listEl = document.getElementById('proposals-list');
            if (!listEl) return;
            if (!proposals || proposals.length === 0) {
                listEl.innerHTML = '<p style="color:#6b7280;font-size:12px">No proposals yet</p>';
                return;
            }
            listEl.innerHTML = proposals.map(p => {
                const statusColor = p.status === 'approved' ? '#22c55e' : p.status === 'pending' ? '#eab308' : '#6b7280';
                return `<div class="proposal-item">
                    <h4>${p.title || 'Untitled'}</h4>
                    <p>${(p.description || '').substring(0, 80)}${(p.description || '').length > 80 ? '...' : ''}</p>
                    <span class="proposal-status" style="background:${statusColor}22;color:${statusColor}">${p.status || 'unknown'}</span>
                </div>`;
            }).join('');
        }

        // Initial fetch
        fetchAgents();

        // Poll every 60s
        setInterval(() => fetchAgents(), 60000);

        // ============================================================
        // === CLICK INTERACTION (NPC > Building > Tile) ===
        // ============================================================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('click', (e) => {
            // Don't interact if clicking on UI
            if (e.target !== renderer.domElement) return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const allObjects = [];
            scene.traverse(obj => { if (obj.isMesh) allObjects.push(obj); });
            const intersects = raycaster.intersectObjects(allObjects, false);

            // Priority: NPC > Building > Tile
            let hitNPC = null, hitBuilding = null, hitTile = null;

            for (const hit of intersects) {
                const obj = hit.object;
                if (obj.userData.type === 'npc' && !hitNPC) {
                    hitNPC = obj.userData.npcId;
                }
                if (obj.userData.type === 'building' && !hitBuilding) {
                    hitBuilding = obj.userData.buildingId;
                }
                if (obj.userData.type === 'tile' && !hitTile) {
                    hitTile = obj.userData;
                }
            }

            if (hitNPC) {
                const npc = npcRegistry.get(hitNPC);
                if (npc) openNPCPanel(npc);
                return;
            }

            if (hitBuilding) {
                const bData = BUILDINGS.find(b => b.id === hitBuilding);
                if (bData) openBuildingPanel(bData);
                return;
            }

            if (hitTile && hitTile.walkable) {
                // Close panel if open
                if (panelOpen) closePanel();
                const path = findPath(playerTileX, playerTileZ, hitTile.tileX, hitTile.tileZ);
                if (path.length > 1) {
                    startMoveTo(path);
                }
            }
        });

        // ============================================================
        // === HOVER HIGHLIGHT + CURSOR ===
        // ============================================================
        renderer.domElement.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const allObjects = [];
            scene.traverse(obj => { if (obj.isMesh) allObjects.push(obj); });
            const intersects = raycaster.intersectObjects(allObjects, false);

            highlight.visible = false;
            let cursorSet = false;

            for (const hit of intersects) {
                const obj = hit.object;
                if (obj.userData.type === 'npc') {
                    document.body.style.cursor = 'help';
                    cursorSet = true;
                    break;
                }
                if (obj.userData.type === 'building') {
                    document.body.style.cursor = 'pointer';
                    cursorSet = true;
                    break;
                }
                if (obj.userData.tileX !== undefined) {
                    const tx = obj.userData.tileX, tz = obj.userData.tileZ;
                    highlight.position.set(tx, heightMap[tx][tz] + 0.05, tz);
                    highlight.visible = true;
                    highlightMat.color.set(obj.userData.walkable ? 0xffff00 : 0xff4444);
                    highlightMat.opacity = obj.userData.walkable ? 0.3 : 0.2;
                    document.body.style.cursor = obj.userData.walkable ? 'pointer' : 'not-allowed';
                    cursorSet = true;
                    break;
                }
            }

            if (!cursorSet) document.body.style.cursor = 'default';
        });

        // Click outside panel to close
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (panelOpen) {
                // If not clicking on panel area, close it
                const panelRect = interactPanel.getBoundingClientRect();
                if (e.clientX < panelRect.left) {
                    // Don't close on same click that opens ‚Äî handled by click handler
                }
            }
        });

        // ============================================================
        // === KEYBOARD INPUT ===
        // ============================================================
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'Escape' && panelOpen) closePanel();
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // ============================================================
        // === SCROLL ZOOM ===
        // ============================================================
        renderer.domElement.addEventListener('wheel', (e) => {
            camDist += e.deltaY * 0.01;
            camDist = Math.max(6, Math.min(30, camDist));
            camHeight = camDist * 0.78;
        });

        // ============================================================
        // === MINIMAP ===
        // ============================================================
        const minimapCanvas = document.getElementById('minimap');
        const mctx = minimapCanvas.getContext('2d');

        function drawMinimap() {
            const s = 150 / MAP_SIZE;
            mctx.clearRect(0, 0, 150, 150);

            // Terrain
            for (let x = 0; x < MAP_SIZE; x++) {
                for (let z = 0; z < MAP_SIZE; z++) {
                    if (grid[x][z] === 3) {
                        mctx.fillStyle = '#8B6914';
                    } else if (isWater(x, z)) {
                        mctx.fillStyle = '#2288aa';
                    } else if (grid[x][z] === 0) {
                        mctx.fillStyle = '#2d4a1e';
                    } else if (grid[x][z] === 2) {
                        mctx.fillStyle = '#8B7355';
                    } else {
                        mctx.fillStyle = '#4a7c3f';
                    }
                    mctx.fillRect(x * s, z * s, s + 0.5, s + 0.5);
                }
            }

            // Buildings
            BUILDINGS.forEach(b => {
                mctx.fillStyle = b.signColor;
                mctx.globalAlpha = 0.6;
                const bx = (b.x - b.w / 2) * s;
                const bz = (b.z - b.d / 2) * s;
                mctx.fillRect(bx, bz, b.w * s, b.d * s);
                mctx.globalAlpha = 1;
            });

            // NPC dots
            npcRegistry.forEach(npc => {
                mctx.fillStyle = npc.roleInfo.hex;
                mctx.beginPath();
                mctx.arc(npc.worldX * s, npc.worldZ * s, 2, 0, Math.PI * 2);
                mctx.fill();
            });

            // Player dot
            mctx.fillStyle = '#ffff00';
            mctx.beginPath();
            mctx.arc(playerWorldX * s, playerWorldZ * s, 3, 0, Math.PI * 2);
            mctx.fill();

            // Path preview
            if (currentPath.length > 0) {
                mctx.strokeStyle = 'rgba(255,255,0,0.4)';
                mctx.lineWidth = 1;
                mctx.beginPath();
                mctx.moveTo(currentPath[0].x * s, currentPath[0].z * s);
                for (let i = 1; i < currentPath.length; i++) {
                    mctx.lineTo(currentPath[i].x * s, currentPath[i].z * s);
                }
                mctx.stroke();
            }
        }

        // ============================================================
        // === PATH MARKERS ===
        // ============================================================
        const pathMarkers = [];
        function showPathMarkers(path) {
            clearPathMarkers();
            for (let i = 1; i < path.length; i++) {
                const markerGeo = new THREE.RingGeometry(0.15, 0.2, 6);
                const markerMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
                const marker = new THREE.Mesh(markerGeo, markerMat);
                marker.rotation.x = -Math.PI / 2;
                marker.position.set(path[i].x, heightMap[path[i].x][path[i].z] + 0.06, path[i].z);
                scene.add(marker);
                pathMarkers.push(marker);
            }
        }
        function clearPathMarkers() {
            pathMarkers.forEach(m => scene.remove(m));
            pathMarkers.length = 0;
        }

        // ============================================================
        // === FIREFLIES ===
        // ============================================================
        const particles = [];
        for (let i = 0; i < 30; i++) {
            const pGeo = new THREE.SphereGeometry(0.03, 4, 4);
            const pMat = new THREE.MeshBasicMaterial({ color: 0xffff88 });
            const p = new THREE.Mesh(pGeo, pMat);
            p.position.set(rng() * MAP_SIZE, 0.5 + rng() * 1.5, rng() * MAP_SIZE);
            p.userData.speed = 0.2 + rng() * 0.5;
            p.userData.offset = rng() * Math.PI * 2;
            p.visible = false;
            scene.add(p);
            particles.push(p);
        }

        // ============================================================
        // === NPC LABEL PROJECTION ===
        // ============================================================
        function updateNPCLabels() {
            npcRegistry.forEach(npc => {
                const worldPos = new THREE.Vector3(npc.worldX, 1.3, npc.worldZ);
                worldPos.project(camera);

                const x = (worldPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-worldPos.y * 0.5 + 0.5) * window.innerHeight;

                // Hide if behind camera or too far
                if (worldPos.z > 1 || worldPos.z < -1) {
                    npc.label.style.display = 'none';
                } else {
                    npc.label.style.display = 'block';
                    npc.label.style.left = x + 'px';
                    npc.label.style.top = y + 'px';
                }
            });
        }

        // ============================================================
        // === GAME LOOP ===
        // ============================================================
        const clock = new THREE.Clock();
        const coordsEl = document.getElementById('coords');

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // Camera controls
            const panSpeed = 10 * dt;
            if (keys['w']) { camTargetZ -= panSpeed * Math.cos(camAngle); camTargetX -= panSpeed * Math.sin(camAngle); }
            if (keys['s']) { camTargetZ += panSpeed * Math.cos(camAngle); camTargetX += panSpeed * Math.sin(camAngle); }
            if (keys['a']) { camTargetX -= panSpeed * Math.cos(camAngle); camTargetZ += panSpeed * Math.sin(camAngle); }
            if (keys['d']) { camTargetX += panSpeed * Math.cos(camAngle); camTargetZ -= panSpeed * Math.sin(camAngle); }
            if (keys['q']) camAngle -= 1.5 * dt;
            if (keys['e']) camAngle += 1.5 * dt;

            camTargetX = Math.max(-5, Math.min(MAP_SIZE + 5, camTargetX));
            camTargetZ = Math.max(-5, Math.min(MAP_SIZE + 5, camTargetZ));
            updateCamera();

            // === Player movement ===
            if (isMoving && currentPath.length > 0) {
                moveProgress += dt * MOVE_SPEED;
                walkCycle += dt * 12;

                const legSwing = Math.sin(walkCycle) * 0.3;
                leftLeg.rotation.x = legSwing;
                rightLeg.rotation.x = -legSwing;
                leftArm.rotation.x = -legSwing * 0.6;
                rightArm.rotation.x = legSwing * 0.6;
                body.position.y = 0.5 + Math.abs(Math.sin(walkCycle)) * 0.03;

                if (moveProgress >= 1) {
                    moveProgress = 0;
                    playerTileX = moveToX;
                    playerTileZ = moveToZ;
                    playerWorldX = moveToX;
                    playerWorldZ = moveToZ;
                    pathIndex++;

                    if (pathIndex < currentPath.length) {
                        moveFromX = moveToX;
                        moveFromZ = moveToZ;
                        moveToX = currentPath[pathIndex].x;
                        moveToZ = currentPath[pathIndex].z;
                    } else {
                        isMoving = false;
                        currentPath = [];
                        clearPathMarkers();
                        leftLeg.rotation.x = 0;
                        rightLeg.rotation.x = 0;
                        leftArm.rotation.x = 0;
                        rightArm.rotation.x = 0;
                        body.position.y = 0.5;
                    }
                }

                if (isMoving) {
                    const lerpX = moveFromX + (moveToX - moveFromX) * moveProgress;
                    const lerpZ = moveFromZ + (moveToZ - moveFromZ) * moveProgress;
                    playerWorldX = lerpX;
                    playerWorldZ = lerpZ;

                    const fromH = heightMap[moveFromX] ? heightMap[moveFromX][moveFromZ] || 0 : 0;
                    const toH = heightMap[moveToX] ? heightMap[moveToX][moveToZ] || 0 : 0;
                    const lerpH = fromH + (toH - fromH) * moveProgress;

                    playerGroup.position.set(lerpX, lerpH, lerpZ);

                    const angle = Math.atan2(moveToX - moveFromX, moveToZ - moveFromZ);
                    playerGroup.rotation.y = angle;
                }
            }

            // === NPC updates ===
            processPathfindingQueue();
            npcRegistry.forEach(npc => updateNPCState(npc, dt));
            updateNPCLabels();

            // === Update coords ===
            coordsEl.textContent = `Tile: ${playerTileX}, ${playerTileZ}`;

            // === Water animation ===
            const verts = waterGeo.attributes.position;
            for (let i = 0; i < verts.count; i++) {
                const x = verts.getX(i);
                const z = verts.getZ(i);
                verts.setY(i, Math.sin(x * 2 + time) * 0.02 + Math.cos(z * 2 + time * 1.3) * 0.02);
            }
            verts.needsUpdate = true;

            // === Fireflies ===
            particles.forEach(p => {
                p.visible = isNight;
                if (isNight) {
                    p.position.y += Math.sin(time * p.userData.speed + p.userData.offset) * 0.003;
                    p.position.x += Math.sin(time * 0.3 + p.userData.offset) * 0.005;
                    p.material.opacity = 0.5 + Math.sin(time * 2 + p.userData.offset) * 0.5;
                }
            });

            // === Path markers ===
            if (isMoving && pathMarkers.length === 0 && currentPath.length > 2) {
                showPathMarkers(currentPath);
            }

            drawMinimap();
            renderer.render(scene, camera);
        }

        animate();

        // Initial log
        addLogEntry('System', '#6366f1', 'Welcome to AgentScape!');

        // ============================================================
        // === RESIZE ===
        // ============================================================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    })();
    </script>
</body>
</html>
