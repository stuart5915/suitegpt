<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgentScape | SUITE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }

        /* === RS-STYLE GAME FRAME === */
        #game-frame {
            display: grid;
            grid-template-columns: 1fr 220px;
            grid-template-rows: 1fr 160px;
            width: 100vw; height: 100vh;
        }
        #game-viewport {
            position: relative; overflow: hidden; background: #000;
            grid-row: 1; grid-column: 1;
        }
        #game-viewport canvas { display: block; width: 100%; height: 100%; }
        #npc-labels, #chat-bubbles { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }

        /* Right Sidebar */
        #game-sidebar {
            grid-row: 1 / 3; grid-column: 2;
            background: linear-gradient(180deg, #2a2a2e 0%, #1a1a1f 100%);
            border-left: 2px solid #4a4a50;
            display: flex; flex-direction: column; overflow: hidden;
        }

        /* Minimap in sidebar */
        #minimap-wrap { padding: 8px; text-align: center; border-bottom: 2px solid #4a4a50; background: #1a1a1f; position: relative; }
        #minimap { border: 2px solid #5a5a60; border-radius: 2px; display: block; margin: 0 auto; }

        /* Run Energy Orb */
        #run-orb { position: absolute; bottom: 6px; right: 6px; width: 36px; height: 36px; border-radius: 50%; border: 2px solid #5a5a60; background: conic-gradient(#f59e0b var(--run-pct, 100%), #333 0); display: flex; align-items: center; justify-content: center; cursor: pointer; user-select: none; transition: border-color 0.15s; z-index: 2; }
        #run-orb:hover { border-color: #f59e0b; }
        #run-orb.active { border-color: #f59e0b; box-shadow: 0 0 8px rgba(245,158,11,0.5); }
        #run-orb.resting { border-color: #22c55e; box-shadow: 0 0 8px rgba(34,197,94,0.4); }
        #run-orb-inner { width: 24px; height: 24px; border-radius: 50%; background: #1a1a1f; display: flex; align-items: center; justify-content: center; font-size: 9px; color: #fff; font-weight: bold; text-shadow: 0 0 3px #000; pointer-events: none; }
        #run-orb-icon { font-size: 12px; pointer-events: none; }

        /* HP / Energy Orbs */
        #orbs-row { display: flex; justify-content: center; gap: 16px; padding: 8px 0; border-bottom: 2px solid #4a4a50; background: #222226; }
        .orb { width: 40px; height: 40px; border-radius: 50%; border: 2px solid #5a5a60; position: relative; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; color: #fff; text-shadow: 0 0 3px #000; }
        .orb-hp { background: conic-gradient(#22c55e var(--hp-pct, 100%), #333 0); }
        .orb-energy { background: conic-gradient(#eab308 var(--energy-pct, 100%), #333 0); }
        .orb-combat { background: conic-gradient(#6366f1 100%, #333 0); }
        .orb-inner { width: 28px; height: 28px; border-radius: 50%; background: #1a1a1f; display: flex; align-items: center; justify-content: center; font-size: 11px; }

        /* Sidebar Tabs */
        #sidebar-tabs { display: flex; border-bottom: 2px solid #4a4a50; }
        .sidebar-tab { flex: 1; padding: 6px 2px; text-align: center; font-size: 10px; font-weight: bold; color: #9ca3af; background: #2a2a2e; border: none; cursor: pointer; border-right: 1px solid #4a4a50; border-top: 2px solid transparent; text-transform: uppercase; letter-spacing: 0.5px; }
        .sidebar-tab:last-child { border-right: none; }
        .sidebar-tab.active { background: #1a1a1f; color: #fff; border-top-color: #6366f1; }
        .sidebar-tab:hover { color: #fff; }

        /* Sidebar Content */
        .sidebar-content { flex: 1; overflow-y: auto; display: none; }
        .sidebar-content.active { display: block; }
        .sidebar-content::-webkit-scrollbar { width: 4px; }
        .sidebar-content::-webkit-scrollbar-thumb { background: #4a4a50; }

        /* Inventory Grid */
        #inv-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px; padding: 4px; }
        .inv-slot { aspect-ratio: 1; background: #1a1a1f; border: 1px solid #3a3a40; display: flex; align-items: center; justify-content: center; font-size: 20px; position: relative; cursor: pointer; border-radius: 2px; }
        .inv-slot:hover { border-color: #6366f1; background: #222230; }
        .inv-slot.equipped { border-color: #22c55e; box-shadow: inset 0 0 6px rgba(34,197,94,0.3); }
        .inv-slot-qty { position: absolute; bottom: 1px; right: 3px; font-size: 9px; color: #eab308; font-weight: bold; text-shadow: 0 0 2px #000; }

        /* Stats Panel */
        #stats-content { padding: 4px; }
        .stat-player-info { padding: 8px; text-align: center; border-bottom: 2px solid #4a4a50; }
        .stat-player-name { font-size: 13px; color: #fff; font-weight: bold; }
        .stat-combat-lvl { font-size: 11px; color: #eab308; }

        /* OSRS-style Skill Grid */
        .skill-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px; background: #2a2a2e; border: 1px solid #2a2a2e; }
        .skill-cell { background: #1a1a1f; padding: 3px 4px; display: flex; align-items: center; gap: 3px; cursor: pointer; position: relative; overflow: hidden; transition: background 0.15s; }
        .skill-cell:hover { background: #252530; }
        .skill-cell.skill-selected { background: #2a2a3a; box-shadow: inset 0 0 0 1px #6366f1; }
        .skill-cell.skill-levelup { animation: skillFlash 1.5s ease-out; }
        @keyframes skillFlash { 0%, 20% { background: #6366f144; } 100% { background: #1a1a1f; } }
        .skill-icon { font-size: 11px; width: 16px; text-align: center; flex-shrink: 0; }
        .skill-lvl { font-size: 11px; color: #fff; font-weight: bold; margin-left: auto; }
        .skill-xp-bar { position: absolute; bottom: 0; left: 0; right: 0; height: 2px; background: #2a2a2e; }
        .skill-xp-fill { height: 100%; background: #6366f1; transition: width 0.3s; }
        .skill-total { text-align: center; padding: 6px; font-size: 11px; color: #eab308; font-weight: bold; border-top: 1px solid #3a3a40; background: #1a1a1f; }
        .skill-detail { padding: 8px; background: #1a1a1f; border-top: 1px solid #3a3a40; }
        .skill-detail-name { font-size: 12px; color: #fff; font-weight: bold; margin-bottom: 4px; }
        .skill-detail-row { font-size: 10px; color: #9ca3af; padding: 1px 0; }
        .skill-detail-row b { color: #fff; }

        /* Skill hover tooltip */
        .skill-tooltip { position: fixed; background: #1a1a1f; border: 1px solid #3a3a40; color: #fff; font-size: 11px; padding: 4px 8px; border-radius: 3px; pointer-events: none; z-index: 100; white-space: nowrap; box-shadow: 0 2px 8px rgba(0,0,0,0.6); }
        /* Skill guide panel */
        .skill-guide { padding: 8px; background: #1a1a1f; border-top: 1px solid #3a3a40; max-height: 200px; overflow-y: auto; }
        .skill-guide-header { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #2a2a2e; }
        .skill-guide-title { font-size: 13px; color: #fff; font-weight: bold; }
        .skill-guide-back { font-size: 10px; color: #6366f1; cursor: pointer; margin-left: auto; }
        .skill-guide-row { display: flex; align-items: center; gap: 6px; padding: 3px 4px; font-size: 10px; border-radius: 3px; }
        .skill-guide-row.unlocked { color: #fff; }
        .skill-guide-row.locked { color: #6b7280; }
        .skill-guide-row.current { background: #6366f122; color: #a5b4fc; }
        .skill-guide-lvl { width: 24px; font-weight: bold; text-align: right; flex-shrink: 0; }
        .skill-guide-name { flex: 1; }
        .skill-guide-icon { width: 16px; text-align: center; }

        /* Equipment Panel */
        #equip-panel { padding: 8px; display: flex; flex-direction: column; align-items: center; }
        .equip-title { font-size: 12px; color: #eab308; font-weight: bold; text-align: center; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .equip-grid { position: relative; width: 180px; height: 260px; }
        .equip-slot { position: absolute; width: 42px; height: 42px; background: #1a1a1f; border: 1px solid #3a3a40; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 22px; cursor: pointer; transition: border-color 0.15s, background 0.15s; }
        .equip-slot:hover { border-color: #6366f1; background: #222230; }
        .equip-slot.has-item { border-color: #22c55e; box-shadow: inset 0 0 6px rgba(34,197,94,0.2); }
        .equip-slot-label { position: absolute; font-size: 8px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; pointer-events: none; }
        .equip-slot-name { font-size: 9px; color: #9ca3af; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 42px; }
        .equip-silhouette { position: absolute; top: 50px; left: 50%; transform: translateX(-50%); width: 50px; height: 120px; border: 1px dashed #2a2a2e; border-radius: 8px 8px 4px 4px; pointer-events: none; }
        .equip-stats { width: 100%; margin-top: 10px; padding: 8px; background: #1a1a1f; border: 1px solid #2a2a2e; border-radius: 3px; }
        .equip-stat-row { display: flex; justify-content: space-between; font-size: 11px; color: #9ca3af; padding: 2px 0; }
        .equip-stat-row b { color: #fff; }
        .equip-stat-row .positive { color: #22c55e; }

        /* Bottom Panel */
        #game-bottom { grid-row: 2; grid-column: 1; background: linear-gradient(0deg, #1a1a1f, #222226); border-top: 2px solid #4a4a50; display: flex; }

        /* Chat Area */
        #chat-area { flex: 1; display: flex; flex-direction: column; border-right: 2px solid #4a4a50; }
        #chat-tabs { display: flex; border-bottom: 1px solid #3a3a40; flex-shrink: 0; }
        .chat-tab { padding: 4px 10px; font-size: 10px; font-weight: bold; color: #6b7280; background: none; border: none; cursor: pointer; border-bottom: 2px solid transparent; }
        .chat-tab.active { color: #fff; border-bottom-color: #6366f1; }
        .chat-tab:hover { color: #ccc; }
        #chat-messages { flex: 1; overflow-y: auto; padding: 4px 8px; font-size: 11px; line-height: 1.5; color: #ccc; }
        #chat-messages::-webkit-scrollbar { width: 4px; }
        #chat-messages::-webkit-scrollbar-thumb { background: #4a4a50; }
        .chat-msg-system { color: #6366f1; }
        .chat-msg-combat { color: #ef4444; }
        .chat-msg-public { color: #eab308; }
        .chat-msg-agent { color: #22c55e; }
        #chat-input-area { display: flex; padding: 4px; gap: 4px; flex-shrink: 0; }
        #chat-input { flex: 1; background: #1a1a1f; border: 1px solid #3a3a40; color: #fff; padding: 4px 8px; font-size: 11px; font-family: inherit; border-radius: 2px; outline: none; }
        #chat-input:focus { border-color: #6366f1; }

        /* Action Buttons */
        #action-area { width: 180px; padding: 8px; display: flex; flex-direction: column; gap: 4px; justify-content: center; }
        .action-btn { padding: 6px; font-size: 10px; font-weight: bold; background: #2a2a2e; color: #ccc; border: 1px solid #4a4a50; cursor: pointer; text-align: center; border-radius: 2px; text-transform: uppercase; letter-spacing: 0.5px; }
        .action-btn:hover { background: #3a3a3e; color: #fff; border-color: #6366f1; }
        .action-btn.active { background: #6366f122; color: #6366f1; border-color: #6366f1; }

        /* NPC Labels */
        .npc-label { position: absolute; z-index: 15; pointer-events: none; font-family: 'Courier New', monospace; font-size: 10px; font-weight: bold; color: #fff; text-shadow: 0 0 4px rgba(0,0,0,0.9), 0 1px 2px rgba(0,0,0,0.8); white-space: nowrap; transform: translate(-50%, -100%); padding: 1px 6px; border-radius: 3px; background: rgba(0,0,0,0.5); }

        /* Monster Labels */
        .monster-label { position: absolute; z-index: 15; pointer-events: none; font-family: 'Courier New', monospace; font-size: 10px; font-weight: bold; color: #fff; text-shadow: 0 0 4px rgba(0,0,0,0.9), 0 1px 2px rgba(0,0,0,0.8); white-space: nowrap; transform: translate(-50%, -100%); padding: 1px 6px; border-radius: 3px; background: rgba(139,0,0,0.6); border-bottom: 2px solid #ef4444; }

        /* Chat Bubbles */
        .chat-bubble { position: absolute; z-index: 16; pointer-events: none; font-family: 'Courier New', monospace; font-size: 11px; font-weight: bold; color: #ffff00; text-shadow: 0 0 4px rgba(0,0,0,0.9); white-space: nowrap; transform: translate(-50%, -100%); padding: 2px 8px; border-radius: 4px; background: rgba(0,0,0,0.6); animation: bubbleFade 5s forwards; }
        @keyframes bubbleFade { 0%, 70% { opacity: 1; transform: translate(-50%, -100%); } 100% { opacity: 0; transform: translate(-50%, -120%); } }

        /* Context Menu */
        #context-menu { position: fixed; z-index: 100; display: none; background: #1a1a1f; border: 1px solid #4a4a50; min-width: 140px; font-size: 12px; box-shadow: 2px 2px 8px rgba(0,0,0,0.5); }
        .ctx-option { padding: 5px 12px; color: #ccc; cursor: pointer; border-bottom: 1px solid #2a2a2e; }
        .ctx-option:hover { background: #2a2a3e; color: #fff; }
        .ctx-option:last-child { border-bottom: none; }
        .ctx-header { padding: 4px 12px; color: #6366f1; font-weight: bold; font-size: 11px; border-bottom: 1px solid #4a4a50; }

        /* Health Bars */
        .health-bar-wrap { position: absolute; z-index: 14; pointer-events: none; transform: translate(-50%, 0); width: 40px; }
        .health-bar { width: 100%; height: 5px; background: #333; border: 1px solid #000; }
        .health-bar-fill { height: 100%; background: #22c55e; transition: width 0.2s; }

        /* Hitsplats */
        .hitsplat { position: absolute; z-index: 17; pointer-events: none; transform: translate(-50%, -50%); width: 24px; height: 24px; border-radius: 50%; background: #cc0000; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; color: #fff; text-shadow: 0 0 2px #000; animation: hitsplatAnim 1s forwards; }
        .hitsplat.miss { background: #4444ff; }
        .hitsplat.spec { background: #eab308; width: 30px; height: 30px; font-size: 13px; }
        @keyframes hitsplatAnim { 0% { opacity: 1; transform: translate(-50%, -50%); } 100% { opacity: 0; transform: translate(-50%, -100%); } }

        /* Death Screen */
        #death-screen { position: absolute; inset: 0; z-index: 50; background: rgba(139,0,0,0.7); display: none; align-items: center; justify-content: center; flex-direction: column; gap: 12px; }
        #death-screen h1 { color: #fff; font-size: 24px; }
        #death-screen p { color: #ccc; font-size: 14px; }

        /* Loot */
        .loot-label { position: absolute; z-index: 14; pointer-events: none; font-size: 10px; color: #eab308; font-weight: bold; text-shadow: 0 0 3px #000; transform: translate(-50%, 0); animation: lootPulse 1s infinite; }
        @keyframes lootPulse { 50% { transform: translate(-50%, -3px); } }
        .loot-pile-dot { position: absolute; width: 8px; height: 8px; border-radius: 50%; background: #eab308; z-index: 13; cursor: pointer; pointer-events: auto; box-shadow: 0 0 6px #eab308; animation: lootPulse 1s infinite; }

        /* Overlay Panels */
        .game-overlay { position: absolute; inset: 0; z-index: 40; background: rgba(0,0,0,0.75); display: none; align-items: center; justify-content: center; }
        .game-overlay.open { display: flex; }
        .overlay-panel { background: linear-gradient(180deg, #2a2a2e, #1a1a1f); border: 2px solid #4a4a50; border-radius: 4px; width: 520px; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.5); }
        .overlay-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; border-bottom: 2px solid #4a4a50; background: #222226; }
        .overlay-header h2 { font-size: 14px; color: #fff; margin: 0; }
        .overlay-close { background: none; border: none; color: #9ca3af; font-size: 18px; cursor: pointer; padding: 0 4px; }
        .overlay-close:hover { color: #fff; }
        .overlay-body { padding: 10px; }

        /* Quest List */
        .quest-item { padding: 8px 10px; border-bottom: 1px solid #2a2a2e; cursor: pointer; display: flex; align-items: center; gap: 8px; }
        .quest-item:hover { background: #2a2a3e; }
        .quest-item.completed { opacity: 0.5; }
        .quest-difficulty { font-size: 9px; padding: 2px 6px; border-radius: 2px; font-weight: bold; text-transform: uppercase; }
        .quest-difficulty.easy { background: #22c55e33; color: #22c55e; }
        .quest-difficulty.medium { background: #eab30833; color: #eab308; }
        .quest-difficulty.hard { background: #ef444433; color: #ef4444; }
        .quest-difficulty.legendary { background: #a855f733; color: #a855f7; }
        .quest-name { flex: 1; font-size: 12px; color: #ccc; }
        .quest-status-icon { font-size: 14px; }
        .quest-detail { padding: 10px; }
        .quest-detail-desc { font-size: 11px; color: #9ca3af; margin-bottom: 8px; }
        .quest-detail-rewards { font-size: 11px; color: #eab308; margin-top: 6px; }
        .quest-accept-btn { margin-top: 8px; padding: 6px 16px; background: #6366f1; color: #fff; border: none; font-size: 11px; font-weight: bold; cursor: pointer; border-radius: 2px; font-family: inherit; }
        .quest-accept-btn:hover { background: #818cf8; }
        .quest-progress-bar { width: 100%; height: 4px; background: #2a2a2e; border-radius: 2px; margin-top: 3px; }
        .quest-progress-fill { height: 100%; background: #22c55e; border-radius: 2px; transition: width 0.3s; }
        .sidebar-quest { padding: 6px 8px; border-bottom: 1px solid #2a2a2e; cursor: pointer; }
        .sidebar-quest:hover { background: #2a2a3e; }
        .sidebar-quest-name { font-size: 11px; color: #ccc; font-weight: bold; }
        .sidebar-quest-progress { font-size: 9px; color: #9ca3af; }
        .sidebar-quest.done .sidebar-quest-name { color: #6b7280; text-decoration: line-through; }

        /* Shop */
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1px; }
        .shop-panel { flex: 1; min-width: 0; }
        .shop-panel h3 { font-size: 11px; color: #9ca3af; padding: 6px 8px; margin: 0; border-bottom: 1px solid #2a2a2e; text-transform: uppercase; }
        .shop-item { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-bottom: 1px solid #2a2a2e; cursor: pointer; font-size: 11px; color: #ccc; }
        .shop-item:hover { background: #2a2a3e; }
        .shop-item-icon { font-size: 18px; width: 26px; text-align: center; }
        .shop-item-name { flex: 1; }
        .shop-item-price { color: #eab308; font-weight: bold; }
        .shop-item-stock { color: #6b7280; font-size: 9px; }
        .shop-coins { padding: 8px; text-align: center; font-size: 12px; color: #eab308; font-weight: bold; border-bottom: 1px solid #4a4a50; }
        .shop-buy-btn { padding: 3px 8px; font-size: 9px; font-weight: bold; background: #2a2a2e; color: #ccc; border: 1px solid #4a4a50; cursor: pointer; border-radius: 2px; font-family: inherit; }
        .shop-buy-btn:hover { background: #3a3a3e; border-color: #6366f1; color: #fff; }

        /* Skilling */
        .skill-timer { width: 100%; height: 6px; background: #2a2a2e; border-radius: 3px; margin-top: 4px; }
        .skill-timer-fill { height: 100%; background: #22c55e; border-radius: 3px; transition: width 0.1s linear; }

        /* Bank Overlay */
        .bank-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px; padding: 4px; }
        .bank-slot { aspect-ratio: 1; background: #1a1a1f; border: 1px solid #3a3a40; display: flex; align-items: center; justify-content: center; font-size: 18px; position: relative; cursor: pointer; border-radius: 2px; }
        .bank-slot:hover { border-color: #6366f1; background: #222230; }
        .bank-slot-qty { position: absolute; bottom: 1px; right: 3px; font-size: 8px; color: #eab308; font-weight: bold; text-shadow: 0 0 2px #000; }
        .bank-slot-name { position: absolute; bottom: 1px; left: 2px; font-size: 7px; color: #9ca3af; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 90%; }
        .bank-actions { display: flex; gap: 4px; padding: 8px; border-top: 1px solid #3a3a40; }
        .bank-btn { flex: 1; padding: 6px; font-size: 10px; font-weight: bold; background: #2a2a2e; color: #ccc; border: 1px solid #4a4a50; cursor: pointer; border-radius: 2px; font-family: inherit; text-align: center; }
        .bank-btn:hover { background: #3a3a3e; border-color: #6366f1; color: #fff; }
        .bank-inv-row { display: flex; gap: 2px; padding: 4px; flex-wrap: wrap; }
        .bank-inv-slot { width: 36px; height: 36px; background: #1a1a1f; border: 1px solid #3a3a40; display: flex; align-items: center; justify-content: center; font-size: 16px; cursor: pointer; border-radius: 2px; position: relative; }
        .bank-inv-slot:hover { border-color: #22c55e; background: #222230; }

        /* Resource Node Labels */
        .node-label { position: absolute; z-index: 13; pointer-events: none; font-family: 'Courier New', monospace; font-size: 9px; font-weight: bold; color: #eab308; text-shadow: 0 0 4px rgba(0,0,0,0.9); white-space: nowrap; transform: translate(-50%, -100%); padding: 1px 4px; border-radius: 2px; background: rgba(0,0,0,0.4); }
        .node-label.depleted { color: #6b7280; opacity: 0.5; }

        /* Cooking/Processing overlay reuses craft-overlay styles */

        /* Zone Indicator */
        #zone-indicator { position: absolute; top: 8px; left: 50%; transform: translateX(-50%); z-index: 10; font-size: 12px; font-weight: bold; color: #fff; text-shadow: 0 0 6px rgba(0,0,0,0.9); padding: 4px 14px; background: rgba(0,0,0,0.5); border-radius: 4px; font-family: 'Courier New', monospace; pointer-events: none; transition: opacity 0.3s; }

        /* Connection Status */
        #conn-status { position: absolute; bottom: 4px; left: 4px; z-index: 20; font-size: 10px; padding: 2px 8px; border-radius: 3px; background: rgba(0,0,0,0.6); }
        #conn-status.connected { color: #22c55e; }
        #conn-status.connecting { color: #eab308; }
        #conn-status.disconnected { color: #ef4444; }

        /* Character Creation */
        #char-create-screen { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0f 70%); z-index: 1000; display: flex; align-items: center; justify-content: center; font-family: 'Courier New', monospace; }
        #char-create-screen.hidden { display: none; }
        .cc-container { display: flex; gap: 32px; align-items: flex-start; background: rgba(20,20,30,0.9); border: 2px solid #4a4a50; border-radius: 8px; padding: 32px; max-width: 700px; width: 90%; }
        .cc-form { flex: 1; }
        .cc-form h1 { color: #fff; font-size: 22px; margin-bottom: 4px; }
        .cc-form p.cc-sub { color: #6b7280; font-size: 11px; margin-bottom: 20px; }
        .cc-field { margin-bottom: 16px; }
        .cc-field label { display: block; color: #9ca3af; font-size: 11px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
        .cc-field input[type="text"] { width: 100%; background: #1a1a1f; border: 1px solid #3a3a40; color: #fff; padding: 8px 12px; font-size: 14px; font-family: inherit; border-radius: 4px; outline: none; }
        .cc-field input[type="text"]:focus { border-color: #6366f1; }
        .cc-colors { display: flex; gap: 6px; flex-wrap: wrap; }
        .cc-color-btn { width: 28px; height: 28px; border-radius: 4px; border: 2px solid #3a3a40; cursor: pointer; transition: border-color 0.15s, transform 0.15s; }
        .cc-color-btn:hover { transform: scale(1.15); }
        .cc-color-btn.selected { border-color: #fff; box-shadow: 0 0 8px rgba(255,255,255,0.3); }
        .cc-classes { display: flex; gap: 8px; }
        .cc-class-btn { flex: 1; padding: 10px 6px; background: #1a1a1f; border: 1px solid #3a3a40; border-radius: 4px; cursor: pointer; text-align: center; transition: all 0.15s; }
        .cc-class-btn:hover { border-color: #6366f1; background: #222230; }
        .cc-class-btn.selected { border-color: #6366f1; background: #6366f122; }
        .cc-class-icon { font-size: 20px; display: block; margin-bottom: 4px; }
        .cc-class-name { color: #fff; font-size: 11px; font-weight: bold; display: block; }
        .cc-class-desc { color: #6b7280; font-size: 9px; display: block; margin-top: 2px; }
        .cc-models { display: flex; gap: 8px; flex-wrap: wrap; }
        .cc-model-btn { width: 72px; padding: 6px; background: #1a1a1f; border: 2px solid #3a3a40; border-radius: 6px; cursor: pointer; text-align: center; transition: all 0.15s; }
        .cc-model-btn:hover { border-color: #6366f1; background: #222230; }
        .cc-model-btn.selected { border-color: #6366f1; background: #6366f122; }
        .cc-model-btn img { width: 56px; height: 56px; object-fit: contain; border-radius: 4px; background: #000; display: block; margin: 0 auto 4px; }
        .cc-model-btn .cc-model-icon { width: 56px; height: 56px; display: flex; align-items: center; justify-content: center; font-size: 28px; background: #111; border-radius: 4px; margin: 0 auto 4px; }
        .cc-model-btn .cc-model-name { font-size: 9px; color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .cc-start-btn { width: 100%; padding: 12px; background: #6366f1; color: #fff; border: none; border-radius: 4px; font-size: 14px; font-weight: bold; font-family: inherit; cursor: pointer; margin-top: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .cc-start-btn:hover { background: #5558e6; }
        .cc-start-btn:disabled { background: #333; color: #666; cursor: not-allowed; }
        .cc-preview { width: 180px; height: 240px; border: 2px solid #3a3a40; border-radius: 4px; background: #111118; flex-shrink: 0; }

        /* Welcome Tutorial Overlay */
        #tutorial-overlay {
            position: absolute; inset: 0; z-index: 45;
            background: rgba(0,0,0,0.6);
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        .tutorial-panel {
            background: #2c2214; border: 3px solid #8B6914;
            border-radius: 8px; padding: 28px 36px; text-align: center;
            max-width: 340px; width: 90%;
            box-shadow: inset 0 0 20px rgba(139,105,20,0.15), 0 8px 32px rgba(0,0,0,0.6);
            font-family: 'Courier New', monospace;
        }
        .tutorial-panel h2 { color: #eab308; font-size: 18px; margin-bottom: 6px; text-shadow: 0 0 8px rgba(234,179,8,0.3); }
        .tutorial-icon { font-size: 36px; margin: 12px 0; }
        .tutorial-text { color: #d4c9a8; font-size: 13px; line-height: 1.5; margin-bottom: 16px; }
        .tutorial-dots { display: flex; justify-content: center; gap: 8px; margin-bottom: 16px; }
        .tutorial-dot { width: 10px; height: 10px; border-radius: 50%; background: #4a3a20; border: 1px solid #6b5a30; transition: background 0.3s; }
        .tutorial-dot.active { background: #eab308; border-color: #eab308; box-shadow: 0 0 6px rgba(234,179,8,0.4); }
        .tutorial-btn {
            padding: 10px 28px; font-size: 13px; font-weight: bold;
            background: linear-gradient(135deg, #6366f1, #4f46e5); color: #fff;
            border: none; border-radius: 4px; cursor: pointer;
            font-family: inherit; text-transform: uppercase; letter-spacing: 1px;
            transition: background 0.2s;
        }
        .tutorial-btn:hover { background: linear-gradient(135deg, #818cf8, #6366f1); }

        /* Zone Name Banner */
        #zone-banner {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            z-index: 10; pointer-events: none; opacity: 0;
            font-family: 'Courier New', monospace; font-size: 22px; font-weight: bold;
            color: #fff; text-shadow: 0 0 10px rgba(0,0,0,0.8), 0 2px 4px rgba(0,0,0,0.6);
            padding: 10px 32px; border-radius: 6px;
            background: linear-gradient(180deg, rgba(0,0,0,0.5) 0%, rgba(0,0,0,0.2) 100%);
            white-space: nowrap;
        }
        #zone-banner.show { animation: zoneBannerAnim 3s ease forwards; }
        @keyframes zoneBannerAnim {
            0% { opacity: 0; transform: translateX(-50%) translateY(-8px); }
            16% { opacity: 1; transform: translateX(-50%) translateY(0); }
            83% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-8px); }
        }
    </style>
</head>
<body>
    <!-- Character Creation Screen -->
    <div id="char-create-screen" style="display:none">
    <script>if(!localStorage.getItem('agentscape_character'))document.getElementById('char-create-screen').style.display='';</script>
        <div class="cc-container">
            <div class="cc-form">
                <h1>Create Your Character</h1>
                <p class="cc-sub">Enter the world of AgentScape</p>
                <div class="cc-field">
                    <label>Character Name</label>
                    <input type="text" id="cc-name" maxlength="16" placeholder="Enter a name..." autocomplete="off">
                </div>
                <div class="cc-field">
                    <label>Body Color</label>
                    <div class="cc-colors" id="cc-body-colors"></div>
                </div>
                <div class="cc-field">
                    <label>Hair Color</label>
                    <div class="cc-colors" id="cc-hair-colors"></div>
                </div>
                <div class="cc-field">
                    <label>Class</label>
                    <div class="cc-classes" id="cc-classes"></div>
                </div>
                <div class="cc-field" id="cc-model-field" style="display:none">
                    <label>Character Model <span style="font-size:11px;color:#888">(from Forge)</span></label>
                    <div class="cc-models" id="cc-models"></div>
                </div>
                <button class="cc-start-btn" id="cc-start" disabled>Enter AgentScape</button>
            </div>
            <canvas class="cc-preview" id="cc-preview" width="180" height="240"></canvas>
        </div>
    </div>

    <div id="game-frame" style="display:none;">
    <script>if(localStorage.getItem('agentscape_character'))document.getElementById('game-frame').style.display='';</script>
        <div id="game-viewport">
            <div id="zone-indicator">SUITE City</div>
            <div id="zone-banner"></div>
            <div id="tutorial-overlay" style="display:none;">
                <div class="tutorial-panel">
                    <h2>Welcome to AgentScape</h2>
                    <div class="tutorial-icon" id="tutorial-icon"></div>
                    <div class="tutorial-text" id="tutorial-text"></div>
                    <div class="tutorial-dots"><div class="tutorial-dot" id="tdot0"></div><div class="tutorial-dot" id="tdot1"></div><div class="tutorial-dot" id="tdot2"></div></div>
                    <button class="tutorial-btn" id="tutorial-btn"></button>
                </div>
            </div>
            <div id="npc-labels"></div>
            <div id="chat-bubbles"></div>
            <div id="conn-status" class="connecting">Connecting...</div>
            <div id="death-screen"><h1>Oh dear, you are dead!</h1><p>Respawning at Town Hall...</p></div>
            <div class="game-overlay" id="quest-overlay"><div class="overlay-panel"><div class="overlay-header"><h2>&#x1F4CB; Quest Board</h2><button class="overlay-close" onclick="closeOverlay('quest-overlay')">&times;</button></div><div class="overlay-body" id="quest-board-content"></div></div></div>
            <div class="game-overlay" id="shop-overlay"><div class="overlay-panel" style="width:600px;"><div class="overlay-header"><h2>&#x1F3EA; General Store</h2><button class="overlay-close" onclick="closeOverlay('shop-overlay')">&times;</button></div><div class="shop-coins" id="shop-coins-display">&#x1FA99; 0 Coins</div><div class="overlay-body" style="display:flex;gap:2px;" id="shop-body-content"></div></div></div>
            <div class="game-overlay" id="craft-overlay"><div class="overlay-panel"><div class="overlay-header"><h2>&#x1F528; Workshop &mdash; Crafting</h2><button class="overlay-close" onclick="closeOverlay('craft-overlay')">&times;</button></div><div class="overlay-body" id="craft-content"></div></div></div>
            <div class="game-overlay" id="bank-overlay"><div class="overlay-panel" style="width:620px;"><div class="overlay-header"><h2>&#x1F3E6; SUITE Bank</h2><button class="overlay-close" onclick="closeOverlay('bank-overlay')">&times;</button></div><div class="overlay-body" id="bank-body-content"></div></div></div>
            <div class="game-overlay" id="cook-overlay"><div class="overlay-panel"><div class="overlay-header"><h2>&#x1F373; Tavern &mdash; Cooking</h2><button class="overlay-close" onclick="closeOverlay('cook-overlay')">&times;</button></div><div class="overlay-body" id="cook-content"></div></div></div>
        </div>
        <div id="game-sidebar">
            <div id="minimap-wrap"><canvas id="minimap" width="200" height="200"></canvas><div id="run-orb" title="Click: Toggle Run | Right-click: Rest"><div id="run-orb-inner"><span id="run-orb-icon">üèÉ</span></div></div></div>
            <div id="orbs-row">
                <div class="orb orb-hp" id="orbHp"><div class="orb-inner" id="orbHpText">100</div></div>
                <div class="orb orb-combat" id="orbCombat"><div class="orb-inner" id="orbCombatText">3</div></div>
                <div class="orb orb-energy" id="orbEnergy"><div class="orb-inner" id="orbEnergyText">100</div></div>
            </div>
            <div id="sidebar-tabs">
                <button class="sidebar-tab active" onclick="switchSidebarTab('inv')">Inv</button>
                <button class="sidebar-tab" onclick="switchSidebarTab('equip')">Equip</button>
                <button class="sidebar-tab" onclick="switchSidebarTab('stats')">Stats</button>
                <button class="sidebar-tab" onclick="switchSidebarTab('quests')">Quest</button>
            </div>
            <div class="sidebar-content active" id="tab-inv"><div id="inv-grid"></div></div>
            <div class="sidebar-content" id="tab-equip"><div id="equip-panel"></div></div>
            <div class="sidebar-content" id="tab-stats">
                <div class="stat-player-info"><div class="stat-player-name">Player</div><div class="stat-combat-lvl">Combat Level: <span id="statCombatLvl">3</span></div></div>
                <div id="stats-content"></div>
            </div>
            <div class="sidebar-content" id="tab-quests"><div style="padding:8px;color:#9ca3af;font-size:11px;text-align:center;"><p style="font-size:14px;margin-bottom:8px;">&#x1F4CB; Quests</p><p>Visit the Quest Board in town to see available bounties.</p></div></div>
        </div>
        <div id="game-bottom">
            <div id="chat-area">
                <div id="chat-tabs">
                    <button class="chat-tab active" onclick="switchChatTab('all')">All</button>
                    <button class="chat-tab" onclick="switchChatTab('public')">Public</button>
                    <button class="chat-tab" onclick="switchChatTab('agent')">Agent</button>
                    <button class="chat-tab" onclick="switchChatTab('system')">System</button>
                </div>
                <div id="chat-messages"></div>
                <div id="chat-input-area"><input id="chat-input" type="text" placeholder="Press Enter to chat..." maxlength="80"></div>
            </div>
            <div id="action-area">
                <button class="action-btn" id="btnAttackMode" onclick="toggleAttackMode()">Attack Mode</button>
                <button class="action-btn" id="btnSpec" onclick="sendSpec()">Spec (F)</button>
                <button class="action-btn" onclick="toggleDayNight()">Day/Night</button>
                <button class="action-btn" onclick="deleteCharacter()" style="color:#ef4444;border-color:#ef444466;">Delete Char</button>
                <div id="skill-action-area"></div>
                <div style="font-size:9px;color:#6b7280;text-align:center;padding:4px;">Click to Move | Q/E Rotate<br>Scroll Zoom | F Spec</div>
            </div>
        </div>
    </div>
    <div id="context-menu"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
    // Node.js polyfills required by Colyseus.js browser bundle
    if(typeof global==='undefined')window.global=window;
    if(typeof process==='undefined')window.process={env:{},version:'v20.0.0',nextTick:function(fn){setTimeout(fn,0)},browser:true};
    if(typeof Buffer==='undefined'){
        window.Buffer={isBuffer:function(){return false},from:function(d){if(typeof d==='string')return new TextEncoder().encode(d);return new Uint8Array(d||[])},
        alloc:function(n){return new Uint8Array(n)},allocUnsafe:function(n){return new Uint8Array(n)},
        concat:function(l){var t=l.reduce(function(a,b){return a+b.length},0),r=new Uint8Array(t),o=0;l.forEach(function(b){r.set(b,o);o+=b.length});return r},
        byteLength:function(s){return new TextEncoder().encode(s).length}};
    }
    </script>
    <script src="https://unpkg.com/colyseus.js@0.15.24/dist/colyseus.js"></script>
    <script>
    (function() {
        // ============================================================
        // CHARACTER CREATION
        // ============================================================
        const BODY_COLORS = ['#3355aa','#aa3333','#33aa55','#aa8833','#8833aa','#33aaaa','#aa5533','#5533aa','#336699','#993366'];
        const HAIR_COLORS = ['#4a3728','#1a1a1a','#c4a35a','#8c4a2f','#d4d4d4','#aa2222','#2244aa','#6633aa','#22aa44','#ff8844'];
        const CLASSES = [
            { id:'warrior', icon:'\u2694\uFE0F', name:'Warrior', desc:'+2 Attack, +1 Strength', bonuses:{attack:2,strength:1} },
            { id:'sentinel', icon:'\u{1F6E1}\uFE0F', name:'Sentinel', desc:'+2 Defence, +1 HP', bonuses:{defence:2,hitpoints:1} },
            { id:'explorer', icon:'\u{1F9ED}', name:'Explorer', desc:'+1 All combat stats', bonuses:{attack:1,strength:1,defence:1} }
        ];

        const savedChar = localStorage.getItem('agentscape_character');
        let charData = savedChar ? JSON.parse(savedChar) : null;

        // URL auth params
        const urlParams = new URLSearchParams(window.location.search);
        const authToken = urlParams.get('token');
        const authName = urlParams.get('name');
        const authEntityType = urlParams.get('entityType');
        const authApiKey = urlParams.get('apiKey');
        const authTgId = urlParams.get('tgId');

        window.deleteCharacter = function() {
            if (confirm('Delete your character? This cannot be undone.')) {
                localStorage.removeItem('agentscape_character');
                window.location.reload();
            }
        };

        function runCharacterCreation() {
            return new Promise((resolve) => {
                // If we have a saved character, skip creation
                if (charData) {
                    document.getElementById('char-create-screen').classList.add('hidden');
                    document.getElementById('game-frame').style.display = '';
                    return resolve(charData);
                }

                let selBody = BODY_COLORS[0], selHair = HAIR_COLORS[0], selClass = 'explorer';
                const nameInput = document.getElementById('cc-name');
                const startBtn = document.getElementById('cc-start');
                if (authName) { nameInput.value = authName; startBtn.disabled = false; }

                const bodyDiv = document.getElementById('cc-body-colors');
                BODY_COLORS.forEach((c, i) => {
                    const btn = document.createElement('div');
                    btn.className = 'cc-color-btn' + (i === 0 ? ' selected' : '');
                    btn.style.background = c;
                    btn.onclick = () => { selBody = c; bodyDiv.querySelectorAll('.cc-color-btn').forEach(b => b.classList.remove('selected')); btn.classList.add('selected'); drawPreview(); };
                    bodyDiv.appendChild(btn);
                });

                const hairDiv = document.getElementById('cc-hair-colors');
                HAIR_COLORS.forEach((c, i) => {
                    const btn = document.createElement('div');
                    btn.className = 'cc-color-btn' + (i === 0 ? ' selected' : '');
                    btn.style.background = c;
                    btn.onclick = () => { selHair = c; hairDiv.querySelectorAll('.cc-color-btn').forEach(b => b.classList.remove('selected')); btn.classList.add('selected'); drawPreview(); };
                    hairDiv.appendChild(btn);
                });

                const classDiv = document.getElementById('cc-classes');
                CLASSES.forEach(cls => {
                    const btn = document.createElement('div');
                    btn.className = 'cc-class-btn' + (cls.id === 'explorer' ? ' selected' : '');
                    btn.innerHTML = '<span class="cc-class-icon">' + cls.icon + '</span><span class="cc-class-name">' + cls.name + '</span><span class="cc-class-desc">' + cls.desc + '</span>';
                    btn.onclick = () => { selClass = cls.id; classDiv.querySelectorAll('.cc-class-btn').forEach(b => b.classList.remove('selected')); btn.classList.add('selected'); };
                    classDiv.appendChild(btn);
                });

                // Load character models from Forge IndexedDB
                let selCharModel = null;
                (async () => {
                    try {
                        const dbReq = indexedDB.open('agentscape-forge', 2);
                        dbReq.onupgradeneeded = (e) => { e.target.transaction.abort(); };
                        dbReq.onsuccess = (e) => {
                            try {
                                const db = e.target.result;
                                const tx = db.transaction('assets', 'readonly');
                                const req = tx.objectStore('assets').getAll();
                                req.onsuccess = () => {
                                    const chars = (req.result || []).filter(a => a.type === 'character' && a.modelUrl);
                                    if (chars.length === 0) return;
                                    const field = document.getElementById('cc-model-field');
                                    field.style.display = '';
                                    const modelsDiv = document.getElementById('cc-models');
                                    // Default (blocks) option
                                    const defBtn = document.createElement('div');
                                    defBtn.className = 'cc-model-btn selected';
                                    defBtn.innerHTML = '<div class="cc-model-icon">üß±</div><div class="cc-model-name">Default</div>';
                                    defBtn.onclick = () => { selCharModel = null; modelsDiv.querySelectorAll('.cc-model-btn').forEach(b => b.classList.remove('selected')); defBtn.classList.add('selected'); };
                                    modelsDiv.appendChild(defBtn);
                                    chars.forEach(asset => {
                                        const btn = document.createElement('div');
                                        btn.className = 'cc-model-btn';
                                        const preview = asset.imageData ? `<img src="${asset.imageData}" alt="${asset.id}">` : '<div class="cc-model-icon">üßë</div>';
                                        const label = asset.id.replace('char_','').replace(/_/g,' ');
                                        btn.innerHTML = preview + '<div class="cc-model-name">' + label + '</div>';
                                        btn.onclick = () => { selCharModel = asset.id; modelsDiv.querySelectorAll('.cc-model-btn').forEach(b => b.classList.remove('selected')); btn.classList.add('selected'); };
                                        modelsDiv.appendChild(btn);
                                    });
                                };
                            } catch(ex) {}
                        };
                        dbReq.onerror = () => {};
                    } catch(ex) {}
                })();

                nameInput.addEventListener('input', () => { startBtn.disabled = nameInput.value.trim().length < 1 || nameInput.value.trim().length > 16; });

                const pvCanvas = document.getElementById('cc-preview');
                const pvCtx = pvCanvas.getContext('2d');
                function drawPreview() {
                    pvCtx.clearRect(0, 0, 180, 240);
                    const grad = pvCtx.createLinearGradient(0, 0, 0, 240); grad.addColorStop(0, '#1a1a2e'); grad.addColorStop(1, '#111118');
                    pvCtx.fillStyle = grad; pvCtx.fillRect(0, 0, 180, 240);
                    pvCtx.fillStyle = 'rgba(0,0,0,0.3)'; pvCtx.beginPath(); pvCtx.ellipse(90, 200, 25, 8, 0, 0, Math.PI * 2); pvCtx.fill();
                    pvCtx.fillStyle = '#554433'; pvCtx.fillRect(75, 165, 12, 30); pvCtx.fillRect(93, 165, 12, 30);
                    pvCtx.fillStyle = selBody; pvCtx.fillRect(70, 115, 40, 55); pvCtx.fillRect(55, 118, 15, 45); pvCtx.fillRect(110, 118, 15, 45);
                    pvCtx.fillStyle = '#ffcc99'; pvCtx.fillRect(72, 75, 36, 38);
                    pvCtx.fillStyle = selHair; pvCtx.fillRect(70, 70, 40, 15); pvCtx.fillRect(70, 70, 8, 30); pvCtx.fillRect(102, 70, 8, 30);
                    pvCtx.fillStyle = '#fff'; pvCtx.fillRect(80, 86, 6, 5); pvCtx.fillRect(94, 86, 6, 5);
                    pvCtx.fillStyle = '#222'; pvCtx.fillRect(82, 87, 3, 3); pvCtx.fillRect(96, 87, 3, 3);
                }
                drawPreview();

                startBtn.onclick = () => {
                    const name = nameInput.value.trim(); if (!name) return;
                    const data = { name, bodyColor: selBody, hairColor: selHair, classId: selClass, characterModelId: selCharModel || null };
                    localStorage.setItem('agentscape_character', JSON.stringify(data));
                    charData = data;
                    document.getElementById('char-create-screen').classList.add('hidden');
                    document.getElementById('game-frame').style.display = '';
                    resolve(data);
                };
                nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !startBtn.disabled) startBtn.click(); });
            });
        }

        runCharacterCreation().then(startGame);

        function startGame(charInfo) {
        // ============================================================
        // CONFIG
        // ============================================================
        const WS_URL = window.location.hostname === 'localhost' ? 'ws://localhost:2567' : 'wss://play.agentscape.app';
        const MAP_SIZE = 200, TILE_SIZE = 1, WATER_LEVEL = -0.15;
        const CHUNK_SIZE = 20, RENDER_DISTANCE = 2;
        const playerName = charInfo.name || authName || 'Player' + Math.floor(Math.random() * 9999);
        const playerColor = charInfo.bodyColor || '#3355aa';
        const playerHairColor = charInfo.hairColor || '#4a3728';
        let room = null, mySessionId = null, attackMode = false;

        const ROLE_COLORS = {
            app_builder: { hex: '#6366f1', int: 0x6366f1, name: 'Builder' },
            app_refiner: { hex: '#f97316', int: 0xf97316, name: 'Refiner' },
            content_creator: { hex: '#22c55e', int: 0x22c55e, name: 'Creator' },
            growth_outreach: { hex: '#ec4899', int: 0xec4899, name: 'Growth' },
            qa_tester: { hex: '#eab308', int: 0xeab308, name: 'Tester' },
        };

        // ============================================================
        // ITEMS (full set from rich client)
        // ============================================================
        const ITEMS = {
            coins:{id:'coins',name:'Coins',icon:'\u{1FA99}',stackable:true,type:'coin'},
            bronze_sword:{id:'bronze_sword',name:'Bronze Sword',icon:'\u{1F5E1}\uFE0F',stackable:false,type:'weapon',stats:{attack:4,strength:3}},
            iron_sword:{id:'iron_sword',name:'Iron Sword',icon:'\u2694\uFE0F',stackable:false,type:'weapon',stats:{attack:8,strength:6}},
            steel_sword:{id:'steel_sword',name:'Steel Sword',icon:'\u2694\uFE0F',stackable:false,type:'weapon',stats:{attack:12,strength:10}},
            mithril_sword:{id:'mithril_sword',name:'Mithril Sword',icon:'\u{1F5E1}\uFE0F',stackable:false,type:'weapon',stats:{attack:18,strength:15}},
            rune_sword:{id:'rune_sword',name:'Rune Sword',icon:'\u2694\uFE0F',stackable:false,type:'weapon',stats:{attack:26,strength:22}},
            dragon_sword:{id:'dragon_sword',name:'Dragon Sword',icon:'\u2694\uFE0F',stackable:false,type:'weapon',stats:{attack:36,strength:30}},
            bronze_helm:{id:'bronze_helm',name:'Bronze Helm',icon:'\u{1FA96}',stackable:false,type:'helm',stats:{defence:3}},
            iron_helm:{id:'iron_helm',name:'Iron Helm',icon:'\u{1FA96}',stackable:false,type:'helm',stats:{defence:6}},
            steel_helm:{id:'steel_helm',name:'Steel Helm',icon:'\u26D1\uFE0F',stackable:false,type:'helm',stats:{defence:10}},
            mithril_helm:{id:'mithril_helm',name:'Mithril Helm',icon:'\u{1FA96}',stackable:false,type:'helm',stats:{defence:15}},
            rune_helm:{id:'rune_helm',name:'Rune Helm',icon:'\u26D1\uFE0F',stackable:false,type:'helm',stats:{defence:22}},
            dragon_helm:{id:'dragon_helm',name:'Dragon Helm',icon:'\u26D1\uFE0F',stackable:false,type:'helm',stats:{defence:30}},
            bronze_shield:{id:'bronze_shield',name:'Bronze Shield',icon:'\u{1F6E1}\uFE0F',stackable:false,type:'shield',stats:{defence:4}},
            iron_shield:{id:'iron_shield',name:'Iron Shield',icon:'\u{1F6E1}\uFE0F',stackable:false,type:'shield',stats:{defence:8}},
            steel_shield:{id:'steel_shield',name:'Steel Shield',icon:'\u{1F6E1}\uFE0F',stackable:false,type:'shield',stats:{defence:12}},
            mithril_shield:{id:'mithril_shield',name:'Mithril Shield',icon:'\u{1F6E1}\uFE0F',stackable:false,type:'shield',stats:{defence:18}},
            rune_shield:{id:'rune_shield',name:'Rune Shield',icon:'\u{1F6E1}\uFE0F',stackable:false,type:'shield',stats:{defence:25}},
            dragon_shield:{id:'dragon_shield',name:'Dragon Shield',icon:'\u{1F6E1}\uFE0F',stackable:false,type:'shield',stats:{defence:34}},
            bread:{id:'bread',name:'Bread',icon:'\u{1F35E}',stackable:false,type:'food',healAmount:10},
            cooked_meat:{id:'cooked_meat',name:'Cooked Meat',icon:'\u{1F356}',stackable:false,type:'food',healAmount:20},
            cooked_fish:{id:'cooked_fish',name:'Cooked Fish',icon:'\u{1F420}',stackable:false,type:'food',healAmount:15},
            lobster:{id:'lobster',name:'Lobster',icon:'\u{1F99E}',stackable:false,type:'food',healAmount:30},
            shark:{id:'shark',name:'Shark',icon:'\u{1F988}',stackable:false,type:'food',healAmount:40},
            manta_ray:{id:'manta_ray',name:'Manta Ray',icon:'\u{1F420}',stackable:false,type:'food',healAmount:50},
            attack_potion:{id:'attack_potion',name:'Attack Potion',icon:'\u2697\uFE0F',stackable:false,type:'potion'},
            strength_potion:{id:'strength_potion',name:'Strength Potion',icon:'\u2697\uFE0F',stackable:false,type:'potion'},
            defence_potion:{id:'defence_potion',name:'Defence Potion',icon:'\u2697\uFE0F',stackable:false,type:'potion'},
            raw_fish:{id:'raw_fish',name:'Raw Fish',icon:'\u{1F41F}',stackable:true,type:'material'},
            logs:{id:'logs',name:'Logs',icon:'\u{1FAB5}',stackable:true,type:'material'},
            code_fragment:{id:'code_fragment',name:'Code Fragment',icon:'\u{1F48E}',stackable:true,type:'material'},
            agent_core:{id:'agent_core',name:'Agent Core',icon:'\u{1F52E}',stackable:true,type:'misc'},
            corrupted_byte:{id:'corrupted_byte',name:'Corrupted Byte',icon:'\u{1F9E0}',stackable:true,type:'material'},
            broken_link:{id:'broken_link',name:'Broken Link',icon:'\u{1F517}',stackable:true,type:'material'},
            rogue_script:{id:'rogue_script',name:'Rogue Script',icon:'\u{1F4DC}',stackable:true,type:'material'},
            memory_shard:{id:'memory_shard',name:'Memory Shard',icon:'\u{1F4A0}',stackable:true,type:'material'},
            null_fragment:{id:'null_fragment',name:'Null Fragment',icon:'\u26A0\uFE0F',stackable:true,type:'material'},
            overflow_essence:{id:'overflow_essence',name:'Overflow Essence',icon:'\u{1F300}',stackable:true,type:'material'},
            dark_packet:{id:'dark_packet',name:'Dark Packet',icon:'\u{1F311}',stackable:true,type:'material'},
            firewall_core:{id:'firewall_core',name:'Firewall Core',icon:'\u{1F525}',stackable:true,type:'material'},
            dragon_scale:{id:'dragon_scale',name:'Dragon Scale',icon:'\u{1F409}',stackable:true,type:'material'},
            network_key:{id:'network_key',name:'Network Key',icon:'\u{1F511}',stackable:false,type:'misc'},
            normal_logs:{id:'normal_logs',name:'Logs',icon:'\u{1FAB5}',stackable:true,type:'resource'},
            oak_logs:{id:'oak_logs',name:'Oak Logs',icon:'\u{1FAB5}',stackable:true,type:'resource'},
            willow_logs:{id:'willow_logs',name:'Willow Logs',icon:'\u{1FAB5}',stackable:true,type:'resource'},
            bronze_axe:{id:'bronze_axe',name:'Bronze Axe',icon:'\u{1FA93}',stackable:false,type:'axe',stats:{attack:3}},
            bones:{id:'bones',name:'Bones',icon:'\u{1F9B4}',stackable:true,type:'bones'},
            rogue_script_trophy:{id:'rogue_script_trophy',name:'Rogue Script Trophy',icon:'\u{1F3C6}',stackable:false,type:'misc'},
            golem_heart:{id:'golem_heart',name:'Golem Heart',icon:'\u{1F5A4}',stackable:false,type:'misc'},
            hallucinator_eye:{id:'hallucinator_eye',name:'Hallucinator Eye',icon:'\u{1F441}\uFE0F',stackable:false,type:'misc'},
            dragon_heart:{id:'dragon_heart',name:'Dragon Heart',icon:'\u2764\uFE0F',stackable:false,type:'misc'},
        };

        // ============================================================
        // BUILDINGS (full 22 from rich client)
        // ============================================================
        const BUILDINGS = [
            // SUITE Castle (starter town)
            {id:'town_hall',name:'Town Hall',icon:'\u{1F3DB}\uFE0F',x:94,z:86,w:3,d:3,h:2.5,wallColor:0xE8DCC8,roofColor:0x8b5cf6,signColor:'#8b5cf6',doorSide:'south'},
            {id:'quest_board',name:'Quest Board',icon:'\u{1F4CB}',x:106,z:87,w:1,d:1,h:1.2,wallColor:0x8B7355,roofColor:0x6366f1,signColor:'#6366f1',doorSide:'south',type:'pedestal'},
            {id:'bank',name:'SUITE Bank',icon:'\u{1F3E6}',x:91,z:96,w:2.5,d:2,h:2.0,wallColor:0xD4AF37,roofColor:0xeab308,signColor:'#eab308',doorSide:'south'},
            {id:'general_store',name:'General Store',icon:'\u{1F3EA}',x:102,z:96,w:2.5,d:2,h:1.4,wallColor:0xBDB76B,roofColor:0xf97316,signColor:'#f97316',doorSide:'south'},
            {id:'arena',name:'Arena',icon:'\u2694\uFE0F',x:92,z:103,w:4,d:4,h:1.8,wallColor:0xCD853F,roofColor:0xef4444,signColor:'#ef4444',doorSide:'north'},
            {id:'tavern',name:'Tavern',icon:'\u{1F37A}',x:106,z:103,w:2.5,d:2,h:1.5,wallColor:0xBB9966,roofColor:0x14b8a6,signColor:'#14b8a6',doorSide:'north'},
            // Health District (NW ‚Äî future Ironhaven)
            {id:'health_clinic',name:'Health Clinic',icon:'\u{1F3E5}',x:65,z:60,w:3,d:2.5,h:1.8,wallColor:0xBBDDBB,roofColor:0x22c55e,signColor:'#22c55e',doorSide:'south'},
            {id:'gym',name:'Fitness Dojo',icon:'\u{1F3CB}\uFE0F',x:75,z:70,w:2.5,d:2,h:1.5,wallColor:0xAABBAA,roofColor:0x22c55e,signColor:'#22c55e',doorSide:'east'},
            // Education District (N ‚Äî future Ironhaven)
            {id:'academy',name:'SUITE Academy',icon:'\u{1F3EB}',x:100,z:60,w:3.5,d:2.5,h:2.0,wallColor:0xBBCCDD,roofColor:0x3b82f6,signColor:'#3b82f6',doorSide:'south'},
            {id:'library',name:'Knowledge Library',icon:'\u{1F4DA}',x:110,z:70,w:2.5,d:2,h:1.6,wallColor:0xCCBBAA,roofColor:0x3b82f6,signColor:'#3b82f6',doorSide:'west'},
            // Business District (NE ‚Äî future Nexus)
            {id:'exchange',name:'Trade Exchange',icon:'\u{1F4B9}',x:130,z:60,w:3,d:2.5,h:2.2,wallColor:0xDDCCAA,roofColor:0xeab308,signColor:'#eab308',doorSide:'south'},
            // Productivity District (W ‚Äî future Ironhaven)
            {id:'workshop',name:'Workshop',icon:'\u{1F528}',x:65,z:90,w:3,d:2.5,h:1.8,wallColor:0xD2B48C,roofColor:0x8b5cf6,signColor:'#8b5cf6',doorSide:'east'},
            {id:'forge',name:'The Forge',icon:'\u2699\uFE0F',x:75,z:100,w:2.5,d:2,h:1.6,wallColor:0xCC8855,roofColor:0x8b5cf6,signColor:'#8b5cf6',doorSide:'east'},
            // Creative District (SW ‚Äî future Nexus)
            {id:'studio',name:'Creative Studio',icon:'\u{1F3A8}',x:65,z:120,w:3,d:2.5,h:1.6,wallColor:0xDDAACC,roofColor:0xec4899,signColor:'#ec4899',doorSide:'north'},
            {id:'gallery',name:'Art Gallery',icon:'\u{1F5BC}\uFE0F',x:75,z:130,w:2.5,d:2,h:1.4,wallColor:0xCCAABB,roofColor:0xec4899,signColor:'#ec4899',doorSide:'north'},
            // Marketing District (S ‚Äî future Nexus)
            {id:'broadcast_tower',name:'Broadcast Tower',icon:'\u{1F4E1}',x:100,z:120,w:2,d:2,h:3.0,wallColor:0xDDAAAA,roofColor:0xf97316,signColor:'#f97316',doorSide:'north'},
            {id:'ad_agency',name:'Ad Agency',icon:'\u{1F4E3}',x:110,z:130,w:2.5,d:2,h:1.4,wallColor:0xCCBB99,roofColor:0xf97316,signColor:'#f97316',doorSide:'north'},
            // Home District (SE)
            {id:'farm',name:'Farm',icon:'\u{1F33E}',x:130,z:100,w:3,d:3,h:1.0,wallColor:0x8FBC8F,roofColor:0x14b8a6,signColor:'#14b8a6',doorSide:'west'},
            // Zone Landmarks
            {id:'forest_outpost',name:'Forest Outpost',icon:'\u{1F332}',x:100,z:45,w:2,d:2,h:1.3,wallColor:0x6B8E23,roofColor:0x22c55e,signColor:'#22c55e',doorSide:'south'},
            {id:'ruins_gate',name:'Ruins Gate',icon:'\u{1F3DA}\uFE0F',x:155,z:95,w:2,d:2,h:2.0,wallColor:0x8B8378,roofColor:0xf97316,signColor:'#f97316',doorSide:'west'},
            {id:'deep_entrance',name:'Deep Network Portal',icon:'\u{1F30A}',x:100,z:142,w:2,d:2,h:2.5,wallColor:0x4B0082,roofColor:0xef4444,signColor:'#ef4444',doorSide:'north'},
        ];

        const SHOP_ITEMS = [
            {id:'bread',price:10,stock:99},{id:'cooked_meat',price:25,stock:50},{id:'cooked_fish',price:20,stock:50},
            {id:'lobster',price:80,stock:30},{id:'shark',price:200,stock:20},{id:'manta_ray',price:500,stock:10},
            {id:'attack_potion',price:150,stock:20},{id:'strength_potion',price:150,stock:20},{id:'defence_potion',price:150,stock:20},
            {id:'bronze_sword',price:50,stock:10},{id:'bronze_helm',price:30,stock:10},{id:'bronze_shield',price:40,stock:10},
            {id:'iron_sword',price:150,stock:5},{id:'iron_helm',price:100,stock:5},{id:'iron_shield',price:120,stock:5},
            {id:'steel_sword',price:400,stock:3},{id:'steel_helm',price:300,stock:3},{id:'steel_shield',price:350,stock:3},
            {id:'mithril_sword',price:1200,stock:2},{id:'mithril_helm',price:900,stock:2},{id:'mithril_shield',price:1000,stock:2},
            {id:'bronze_axe',price:25,stock:10},
        ];

        const RECIPES = [
            {result:'bronze_shield',resultQty:1,ingredients:[{id:'logs',qty:3}],coinCost:5},
            {result:'iron_sword',resultQty:1,ingredients:[{id:'code_fragment',qty:5}],coinCost:10},
            {result:'steel_sword',resultQty:1,ingredients:[{id:'agent_core',qty:2}],coinCost:20},
            {result:'steel_shield',resultQty:1,ingredients:[{id:'corrupted_byte',qty:8},{id:'logs',qty:5}],coinCost:50},
            {result:'mithril_sword',resultQty:1,ingredients:[{id:'rogue_script',qty:5},{id:'code_fragment',qty:10}],coinCost:100},
            {result:'rune_sword',resultQty:1,ingredients:[{id:'null_fragment',qty:8},{id:'overflow_essence',qty:5}],coinCost:300},
            {result:'dragon_sword',resultQty:1,ingredients:[{id:'dragon_scale',qty:10},{id:'firewall_core',qty:5},{id:'dark_packet',qty:8}],coinCost:1000},
        ];

        const QUESTS = {
            first_blood:{id:'first_blood',name:'First Blood',difficulty:'easy',description:'Defeat any agent in combat.',rewards:{coins:50,xp:{attack:20,strength:20}}},
            pest_control:{id:'pest_control',name:'Pest Control',difficulty:'medium',description:'Defeat 3 QA Testers.',rewards:{coins:150,xp:{attack:50,strength:50,defence:30},items:[{id:'iron_sword',qty:1}]},prereqs:['first_blood']},
            code_collector:{id:'code_collector',name:'Code Collector',difficulty:'medium',description:'Gather 5 Code Fragments.',rewards:{coins:200,xp:{hitpoints:40}}},
            world_tour:{id:'world_tour',name:'World Tour',difficulty:'easy',description:'Visit all 6 buildings.',rewards:{coins:100,xp:{hitpoints:30}}},
            arena_champion:{id:'arena_champion',name:'Arena Champion',difficulty:'hard',description:'Defeat 5 agents in the Arena.',rewards:{coins:300,xp:{attack:80,strength:80,defence:60},items:[{id:'steel_sword',qty:1}]},prereqs:['pest_control']},
            forest_guardian:{id:'forest_guardian',name:'Forest Guardian',difficulty:'hard',description:'Defeat The Rogue Script, guardian of the forest.',rewards:{coins:800,xp:{attack:150,strength:150,defence:100,hitpoints:100},items:[{id:'mithril_sword',qty:1}]}},
            golem_slayer:{id:'golem_slayer',name:'Golem Slayer',difficulty:'hard',description:'Defeat The 404 Golem.',rewards:{coins:2000,xp:{attack:300,strength:280,defence:200,hitpoints:200},items:[{id:'rune_sword',qty:1}]},prereqs:['forest_guardian']},
            slay_the_hallucinator:{id:'slay_the_hallucinator',name:'Slay the Hallucinator',difficulty:'legendary',description:'Defeat The Hallucinator.',rewards:{coins:5000,xp:{attack:600,strength:550,defence:400,hitpoints:400},items:[{id:'dragon_sword',qty:1}]},prereqs:['golem_slayer']},
            dragon_raid:{id:'dragon_raid',name:'The Data Breach',difficulty:'legendary',description:'Defeat the Data Breach Dragon.',rewards:{coins:10000,xp:{attack:1000,strength:1000,defence:800,hitpoints:800}},prereqs:['slay_the_hallucinator']},
        };

        const ZONES = {
            suite_city:{id:'suite_city',name:'SUITE City',bounds:{x1:50,z1:50,x2:150,z2:137},color:'#6366f1'},
            the_forest:{id:'the_forest',name:'The Forest',bounds:{x1:12,z1:5,x2:188,z2:50},color:'#22c55e'},
            the_ruins:{id:'the_ruins',name:'The Ruins',bounds:{x1:150,z1:50,x2:195,z2:137},color:'#f97316'},
            the_deep_network:{id:'the_deep_network',name:'The Deep Network',bounds:{x1:25,z1:137,x2:175,z2:195},color:'#ef4444'},
        };

        // 28-skill grid definition
        const SKILLS = [
            {id:'attack',name:'Attack',icon:'\u2694\uFE0F',category:'combat'},
            {id:'strength',name:'Strength',icon:'\u{1F4AA}',category:'combat'},
            {id:'defence',name:'Defence',icon:'\u{1F6E1}\uFE0F',category:'combat'},
            {id:'hitpoints',name:'Hitpoints',icon:'\u2764\uFE0F',category:'combat'},
            {id:'ranged',name:'Ranged',icon:'\u{1F3F9}',category:'combat'},
            {id:'prayer',name:'Prayer',icon:'\u2728',category:'combat'},
            {id:'magic',name:'Magic',icon:'\u{1F52E}',category:'combat'},
            {id:'woodcutting',name:'Woodcutting',icon:'\u{1FA93}',category:'gathering'},
            {id:'mining',name:'Mining',icon:'\u26CF\uFE0F',category:'gathering'},
            {id:'fishing',name:'Fishing',icon:'\u{1F3A3}',category:'gathering'},
            {id:'farming',name:'Farming',icon:'\u{1F331}',category:'gathering'},
            {id:'hunter',name:'Hunter',icon:'\u{1FAA4}',category:'gathering'},
            {id:'archaeology',name:'Archaeology',icon:'\u{1F3FA}',category:'gathering'},
            {id:'cooking',name:'Cooking',icon:'\u{1F373}',category:'artisan'},
            {id:'smithing',name:'Smithing',icon:'\u{1F528}',category:'artisan'},
            {id:'fletching',name:'Fletching',icon:'\u{1FAB6}',category:'artisan'},
            {id:'firemaking',name:'Firemaking',icon:'\u{1F525}',category:'artisan'},
            {id:'herblore',name:'Herblore',icon:'\u{1F9EA}',category:'artisan'},
            {id:'crafting',name:'Crafting',icon:'\u2702\uFE0F',category:'artisan'},
            {id:'runecraft',name:'Runecraft',icon:'\u{1F537}',category:'artisan'},
            {id:'agility',name:'Agility',icon:'\u{1F3C3}',category:'support'},
            {id:'thieving',name:'Thieving',icon:'\u{1F90F}',category:'support'},
            {id:'slayer',name:'Slayer',icon:'\u{1F480}',category:'support'},
            {id:'construction',name:'Construction',icon:'\u{1F3D7}\uFE0F',category:'support'},
            {id:'dungeoneering',name:'Dungeoneering',icon:'\u{1F6AA}',category:'support'},
            {id:'coding',name:'Coding',icon:'\u{1F4BB}',category:'digital'},
            {id:'hacking',name:'Hacking',icon:'\u{1F513}',category:'digital'},
            {id:'networking',name:'Networking',icon:'\u{1F310}',category:'digital'},
        ];

        // OSRS-style XP table
        const XP_TABLE = [0];
        (function(){let pts=0;for(let lvl=1;lvl<99;lvl++){pts+=Math.floor(lvl+300*Math.pow(2,lvl/7));XP_TABLE.push(Math.floor(pts/4));}})();
        function xpForLevel(lvl){return XP_TABLE[Math.min(lvl-1,XP_TABLE.length-1)]||0;}
        function levelFromXP(xp){for(let i=XP_TABLE.length-1;i>=0;i--){if(xp>=XP_TABLE[i])return i+1;}return 1;}

        const NPC_COMBAT_STATS = {
            app_builder:{hp:60,attack:5,strength:4,defence:3},
            app_refiner:{hp:50,attack:4,strength:3,defence:5},
            content_creator:{hp:40,attack:3,strength:3,defence:2},
            growth_outreach:{hp:45,attack:4,strength:4,defence:3},
            qa_tester:{hp:70,attack:6,strength:5,defence:4},
        };

        function getZoneAt(x, z) { for(const z2 of Object.values(ZONES)){if(x>=z2.bounds.x1&&x<=z2.bounds.x2&&z>=z2.bounds.z1&&z<=z2.bounds.z2)return z2;} return null; }
        // ============================================================
        // CHAT SYSTEM
        // ============================================================
        const chatHistory = [];
        let chatFilter = 'all', chatInputFocused = false;
        function addChat(type, text, sender, color) {
            chatHistory.push({type,text,sender,color,time:Date.now()});
            if (chatHistory.length > 100) chatHistory.shift();
            renderChat();
        }
        function renderChat() {
            const el = document.getElementById('chat-messages');
            const filtered = chatFilter==='all' ? chatHistory : chatHistory.filter(m=>m.type===chatFilter);
            el.innerHTML = filtered.slice(-50).map(m => {
                const cls='chat-msg-'+m.type;
                const pfx = m.sender ? '<span style="color:'+(m.color||'#fff')+';font-weight:bold">'+m.sender+':</span> ' : '';
                return '<div class="'+cls+'">'+pfx+m.text+'</div>';
            }).join('');
            el.scrollTop = el.scrollHeight;
        }
        window.switchChatTab = function(tab) { chatFilter=tab; document.querySelectorAll('.chat-tab').forEach(t=>t.classList.toggle('active',t.textContent.toLowerCase()===tab)); renderChat(); };
        window.switchSidebarTab = function(tab) {
            document.querySelectorAll('.sidebar-tab').forEach(t=>t.classList.toggle('active',t.textContent.toLowerCase().startsWith(tab)));
            document.querySelectorAll('.sidebar-content').forEach(c=>c.classList.remove('active'));
            document.getElementById('tab-'+tab).classList.add('active');
        };
        window.closeOverlay = function(id) { document.getElementById(id).classList.remove('open'); };

        const chatInput = document.getElementById('chat-input');
        chatInput.addEventListener('focus',()=>{chatInputFocused=true;});
        chatInput.addEventListener('blur',()=>{chatInputFocused=false;});
        chatInput.addEventListener('keydown',(e)=>{
            if(e.key==='Enter'&&chatInput.value.trim()){
                const msg=chatInput.value.trim();
                const emoteMatch=msg.match(/^\/(wave|dance|bow|clap|think|laugh|angry|point|cry|cheer|shrug|headbang)$/i);
                if(emoteMatch){sendAction('emote',{animId:emoteMatch[1].toLowerCase()});playCharAnim(myChar,emoteMatch[1].toLowerCase());}
                else{sendAction('chat',{message:msg});}
                chatInput.value=''; chatInput.blur();
            }
            if(e.key==='Escape') chatInput.blur();
            e.stopPropagation();
        });

        // ============================================================
        // THREE.JS SCENE
        // ============================================================
        const viewport = document.getElementById('game-viewport');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.006);
        const camera = new THREE.PerspectiveCamera(45, viewport.clientWidth/viewport.clientHeight, 0.1, 200);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        viewport.insertBefore(renderer.domElement, viewport.firstChild);

        const mapCenter=Math.floor(MAP_SIZE/2);
        let camTargetX=mapCenter,camTargetZ=mapCenter,camAngle=Math.PI/4,camDist=22,camPitch=0.65;
        let camSmoothX=mapCenter,camSmoothZ=mapCenter;
        let camDt=0.016; // updated each frame from animate()
        function updateCamera(){
            // Smooth camera follow ‚Äî lerp toward target instead of snapping
            const camLerp=1-Math.exp(-5*camDt);
            camSmoothX+=(camTargetX-camSmoothX)*camLerp;
            camSmoothZ+=(camTargetZ-camSmoothZ)*camLerp;
            const camHeight=camDist*camPitch;
            const camHoriz=camDist*Math.cos(Math.asin(Math.min(1,camPitch)));
            camera.position.set(camSmoothX+Math.sin(camAngle)*camHoriz,camHeight,camSmoothZ+Math.cos(camAngle)*camHoriz);
            camera.lookAt(camSmoothX,0,camSmoothZ);
        }
        updateCamera();

        const ambientLight=new THREE.AmbientLight(0x6688aa,0.5);scene.add(ambientLight);
        const sunLight=new THREE.DirectionalLight(0xffeedd,0.9);sunLight.position.set(mapCenter,30,mapCenter-10);sunLight.castShadow=true;sunLight.shadow.mapSize.set(2048,2048);sunLight.shadow.camera.near=0.5;sunLight.shadow.camera.far=200;sunLight.shadow.camera.left=-60;sunLight.shadow.camera.right=60;sunLight.shadow.camera.top=60;sunLight.shadow.camera.bottom=-60;scene.add(sunLight);
        const hemiLight=new THREE.HemisphereLight(0x88aacc,0x445522,0.3);scene.add(hemiLight);

        let isNight=false;
        window.toggleDayNight=function(){isNight=!isNight;if(isNight){scene.background.set(0x0a0a1a);scene.fog.color.set(0x0a0a1a);scene.fog.density=0.01;ambientLight.intensity=0.15;sunLight.intensity=0.1;sunLight.color.set(0x4466aa);hemiLight.intensity=0.05;}else{scene.background.set(0x87CEEB);scene.fog.color.set(0x87CEEB);scene.fog.density=0.006;ambientLight.intensity=0.5;sunLight.intensity=0.9;sunLight.color.set(0xffeedd);hemiLight.intensity=0.3;}if(typeof lampposts!=='undefined')lampposts.forEach(lp=>{lp.light.visible=isNight;lp.glow.material.opacity=isNight?0.9:0.3;});};

        // ============================================================
        // TERRAIN (deterministic, same as server seed=42)
        // ============================================================
        const grid=[],heightMap=[];
        function seededRandom(seed){let s=seed;return function(){s=(s*16807+0)%2147483647;return(s-1)/2147483646;};}
        const rng=seededRandom(42);
        function simpleNoise(x,z){return Math.sin(x*0.3)*Math.cos(z*0.4)*0.3+Math.sin(x*0.7+1)*Math.cos(z*0.5+2)*0.15;}

        function getZoneIdAt(x,z){const zone=getZoneAt(x,z);return zone?zone.id:'wilderness';}

        // Water: river between forest and city (~z=19-21), lake in deep network, pond in forest
        function isWater(x,z){
            // River separating forest from city (z ~48-52)
            const rz=49+Math.sin(x*0.06)*5;
            if(Math.abs(z-rz)<3&&x>10&&x<190)return true;
            // Lake in deep network
            if(Math.sqrt((x-87)**2+(z-165)**2)<11)return true;
            // Pond in forest
            if(Math.sqrt((x-50)**2+(z-25)**2)<7.5)return true;
            // Marsh in ruins
            if(Math.sqrt((x-170)**2+(z-112)**2)<7.5)return true;
            return false;
        }
        function isBridge(x,z){
            const rz=49+Math.sin(x*0.06)*5;
            // Bridges at x=75,100,125 crossing the river
            if(Math.abs(z-rz)<3&&(Math.abs(x-75)<4||Math.abs(x-100)<4||Math.abs(x-125)<4))return true;
            return false;
        }
        function isInBuildingZone(x,z){for(const b of BUILDINGS){const hw=b.w/2,hd=b.d/2;if(x>=b.x-hw-0.5&&x<=b.x+hw+0.5&&z>=b.z-hd-0.5&&z<=b.z+hd+0.5)return true;}return false;}

        const grassColors=[0x4a7c3f,0x528745,0x5d9248,0x3d6e35];
        const forestColors=[0x2d5a1e,0x1e4a12,0x3a6028,0x254d18];
        const ruinsColors=[0x8B7355,0x7a6548,0x6d5b40,0x9a8060];
        const deepColors=[0x2a1a3a,0x1e1230,0x331a44,0x251535];
        const dirtColors=[0x8B7355,0x7a6548,0x6d5b40];
        function getTerrainColor(x,z){
            const zid=getZoneIdAt(x,z);
            if(zid==='the_forest')return forestColors[Math.floor(rng()*forestColors.length)];
            if(zid==='the_ruins')return ruinsColors[Math.floor(rng()*ruinsColors.length)];
            if(zid==='the_deep_network')return deepColors[Math.floor(rng()*deepColors.length)];
            return grassColors[Math.floor(rng()*grassColors.length)];
        }

        for(let x=0;x<MAP_SIZE;x++){grid[x]=[];heightMap[x]=[];for(let z=0;z<MAP_SIZE;z++){const w=isWater(x,z),br=isBridge(x,z);if(br){grid[x][z]=3;heightMap[x][z]=0.05;}else if(w){grid[x][z]=0;heightMap[x][z]=WATER_LEVEL;}else{grid[x][z]=1;heightMap[x][z]=simpleNoise(x,z)*0.2;}}}

        // SUITE Castle walls: perimeter of (86,82)-(114,108), south gate at x=99-101
        const CASTLE={x1:86,z1:82,x2:114,z2:108};
        for(let x=CASTLE.x1;x<=CASTLE.x2;x++)for(let z=CASTLE.z1;z<=CASTLE.z2;z++){
            const onEdge=x===CASTLE.x1||x===CASTLE.x2||z===CASTLE.z1||z===CASTLE.z2;
            if(onEdge){
                if(z===CASTLE.z2&&x>=99&&x<=101){grid[x][z]=2;heightMap[x][z]=0;}// gate
                else{grid[x][z]=0;heightMap[x][z]=0;}// wall
            }else{
                grid[x][z]=1;heightMap[x][z]=0;// courtyard
            }
        }

        // Pre-compute terrain colors (data only, no meshes)
        const terrainColors=[];
        const colorRng=seededRandom(42);// separate RNG for colors so chunk load order doesn't matter
        for(let x=0;x<MAP_SIZE;x++){terrainColors[x]=[];for(let z=0;z<MAP_SIZE;z++){let color;if(grid[x][z]===3)color=0x8B6914;else if(isWater(x,z))color=0x2288aa;else{let nw=false;for(let dx=-1;dx<=1;dx++)for(let dz=-1;dz<=1;dz++){const nx=x+dx,nz=z+dz;if(nx>=0&&nx<MAP_SIZE&&nz>=0&&nz<MAP_SIZE&&isWater(nx,nz)&&!isBridge(nx,nz))nw=true;}if(nw)color=0xc2b280;else{const roadZ=95+Math.sin(x*0.05)*3.5;const roadX=100+Math.sin(z*0.05)*3.5;if((Math.abs(z-roadZ)<0.8&&x>55&&x<145)||(Math.abs(x-roadX)<0.8&&z>55&&z<132)){color=dirtColors[Math.floor(colorRng()*dirtColors.length)];grid[x][z]=2;}else color=getTerrainColor(x,z);}}terrainColors[x][z]=color;}}
        // Cobblestone paving for SUITE Castle courtyard
        const stoneColors=[0x8a8a8a,0x7a7a7a,0x6e6e6e,0x929292,0x848484,0x767676];
        for(let x=87;x<=113;x++)for(let z=83;z<=107;z++){if(grid[x][z]>0&&!isWater(x,z)){terrainColors[x][z]=stoneColors[(x*7+z*13)%6];}}

        // Pre-compute decoration positions per chunk
        const decorationsByChunk={};
        const treePositions=[];
        for(let i=0;i<375;i++){const x=Math.floor(rng()*MAP_SIZE),z=Math.floor(rng()*MAP_SIZE);if(grid[x][z]>0&&!isWater(x,z)&&!isInBuildingZone(x,z)&&grid[x][z]!==2&&grid[x][z]!==3&&!(Math.abs(x-100)<10&&Math.abs(z-95)<10)){treePositions.push({x,z,v:Math.floor(rng()*3)});grid[x][z]=0;}}
        const rockPositions=[];
        for(let i=0;i<125;i++){const x=Math.floor(rng()*MAP_SIZE),z=Math.floor(rng()*MAP_SIZE);if(grid[x][z]>0&&!isWater(x,z)&&!isInBuildingZone(x,z)){rockPositions.push({x,z,rc:getZoneIdAt(x,z)==='the_ruins'?0x666666:0x888888,size:0.15+rng()*0.15,ox:rng()*0.3,oz:rng()*0.3,rx:rng(),ry:rng(),rzr:rng()});}}
        const flowerPositions=[];
        for(let i=0;i<200;i++){const x=Math.floor(rng()*MAP_SIZE),z=Math.floor(rng()*MAP_SIZE);if(grid[x][z]>0&&!isWater(x,z)&&!isInBuildingZone(x,z)){const fc=getZoneIdAt(x,z)==='the_deep_network'?[0x8844aa,0x6633cc,0x9955dd]:[0xff6b9d,0xffd93d,0xff8a5c,0xc084fc,0xfb7185];flowerPositions.push({x,z,color:fc[Math.floor(rng()*fc.length)],ox:rng()*0.6-0.3,oz:rng()*0.6-0.3});}}
        // Bucket decorations into chunks
        function chunkKey(cx,cz){return cx+','+cz;}
        treePositions.forEach(t=>{const k=chunkKey(Math.floor(t.x/CHUNK_SIZE),Math.floor(t.z/CHUNK_SIZE));if(!decorationsByChunk[k])decorationsByChunk[k]={trees:[],rocks:[],flowers:[]};decorationsByChunk[k].trees.push(t);});
        rockPositions.forEach(r=>{const k=chunkKey(Math.floor(r.x/CHUNK_SIZE),Math.floor(r.z/CHUNK_SIZE));if(!decorationsByChunk[k])decorationsByChunk[k]={trees:[],rocks:[],flowers:[]};decorationsByChunk[k].rocks.push(r);});
        flowerPositions.forEach(f=>{const k=chunkKey(Math.floor(f.x/CHUNK_SIZE),Math.floor(f.z/CHUNK_SIZE));if(!decorationsByChunk[k])decorationsByChunk[k]={trees:[],rocks:[],flowers:[]};decorationsByChunk[k].flowers.push(f);});

        // Shared geometries (created once, reused by all chunks)
        const sharedTileGeo=new THREE.BoxGeometry(TILE_SIZE,0.3,TILE_SIZE);
        const sharedBridgeGeo=new THREE.BoxGeometry(TILE_SIZE,0.15,TILE_SIZE);
        const sharedTileMat=new THREE.MeshLambertMaterial({vertexColors:false});
        const sharedBridgeMat=new THREE.MeshLambertMaterial({vertexColors:false});
        // Shared decoration geometries
        const sharedTrunkGeo=new THREE.CylinderGeometry(0.08,0.12,0.8,5);
        const sharedCone0=new THREE.ConeGeometry(0.5,0.5,5);
        const sharedCone1=new THREE.ConeGeometry(0.4,0.5,5);
        const sharedCone2=new THREE.ConeGeometry(0.28,0.5,5);
        const sharedLeafBall=new THREE.DodecahedronGeometry(0.45,0);
        const sharedLeafIco=new THREE.IcosahedronGeometry(0.35,0);
        const sharedRockGeo=new THREE.DodecahedronGeometry(0.2,0);
        const sharedFlowerGeo=new THREE.SphereGeometry(0.06,4,4);
        const sharedRailGeo=new THREE.BoxGeometry(0.08,0.4,0.08);
        const sharedRailMat=new THREE.MeshLambertMaterial({color:0x5a3a1a});

        // Raycast target tracking (avoids scene.traverse every frame)
        const rayTargets=[];
        function addRayTarget(obj){rayTargets.push(obj);}
        function removeRayTargets(group){
            for(let i=rayTargets.length-1;i>=0;i--){
                let p=rayTargets[i];while(p){if(p===group){rayTargets.splice(i,1);break;}p=p.parent;}
            }
        }

        // Chunk system ‚Äî InstancedMesh terrain
        const loadedChunks={};
        const _dummy=new THREE.Object3D();
        const _col=new THREE.Color();

        function loadChunk(cx,cz){
            const k=chunkKey(cx,cz);if(loadedChunks[k])return;
            const group=new THREE.Group();group.userData.chunkKey=k;
            const x0=cx*CHUNK_SIZE,z0=cz*CHUNK_SIZE;

            // Collect tile data
            const tiles=[],bridges=[];
            for(let lx=0;lx<CHUNK_SIZE;lx++)for(let lz=0;lz<CHUNK_SIZE;lz++){
                const x=x0+lx,z=z0+lz;if(x>=MAP_SIZE||z>=MAP_SIZE)continue;
                if(grid[x][z]===4)continue;
                const entry={x,z,h:heightMap[x][z],color:terrainColors[x][z],walkable:grid[x][z]>0};
                if(grid[x][z]===3)bridges.push(entry);else tiles.push(entry);
            }

            // Regular tiles ‚Äî one InstancedMesh
            if(tiles.length>0){
                const im=new THREE.InstancedMesh(sharedTileGeo,sharedTileMat,tiles.length);
                im.receiveShadow=true;
                im.userData={type:'terrain',tileMap:tiles};
                for(let i=0;i<tiles.length;i++){
                    _dummy.position.set(tiles[i].x,tiles[i].h-0.15,tiles[i].z);
                    _dummy.updateMatrix();im.setMatrixAt(i,_dummy.matrix);
                    _col.set(tiles[i].color);im.setColorAt(i,_col);
                }
                im.instanceMatrix.needsUpdate=true;
                if(im.instanceColor)im.instanceColor.needsUpdate=true;
                group.add(im);addRayTarget(im);
            }

            // Bridge tiles ‚Äî separate InstancedMesh (thinner)
            if(bridges.length>0){
                const bm=new THREE.InstancedMesh(sharedBridgeGeo,sharedBridgeMat,bridges.length);
                bm.receiveShadow=true;
                bm.userData={type:'terrain',tileMap:bridges};
                for(let i=0;i<bridges.length;i++){
                    _dummy.position.set(bridges[i].x,bridges[i].h-0.15,bridges[i].z);
                    _dummy.updateMatrix();bm.setMatrixAt(i,_dummy.matrix);
                    _col.set(bridges[i].color);bm.setColorAt(i,_col);
                }
                bm.instanceMatrix.needsUpdate=true;
                if(bm.instanceColor)bm.instanceColor.needsUpdate=true;
                group.add(bm);addRayTarget(bm);
            }

            // Bridge rails (few per chunk, keep as individual)
            [75,100,125].forEach(bx=>{for(let x=bx-3;x<=bx+3;x++){if(x<x0||x>=x0+CHUNK_SIZE)return;for(const s of[-1,1]){const rz2=49+Math.sin(x*0.06)*5,rr=Math.round(rz2+s*3);if(rr>=z0&&rr<z0+CHUNK_SIZE&&rr>=0&&rr<MAP_SIZE){const r=new THREE.Mesh(sharedRailGeo,sharedRailMat);r.position.set(x,0.25,rr);r.castShadow=true;group.add(r);}}}});

            // Decorations ‚Äî InstancedMesh batches
            const decs=decorationsByChunk[k];
            if(decs){
                // Trees: batch trunks + canopies by variant
                if(decs.trees.length>0){
                    // Trunk batch
                    const trunkIM=new THREE.InstancedMesh(sharedTrunkGeo,new THREE.MeshLambertMaterial({color:0x6B4226}),decs.trees.length);
                    trunkIM.castShadow=true;
                    decs.trees.forEach((t,i)=>{
                        const h2=heightMap[t.x][t.z];
                        _dummy.position.set(t.x,h2+0.4,t.z);_dummy.scale.set(1,1,1);
                        _dummy.updateMatrix();trunkIM.setMatrixAt(i,_dummy.matrix);
                    });
                    trunkIM.instanceMatrix.needsUpdate=true;group.add(trunkIM);

                    // Canopies by variant type
                    const v0=decs.trees.filter(t=>t.v===0),v1=decs.trees.filter(t=>t.v===1),v2=decs.trees.filter(t=>t.v===2);
                    // Variant 0: 3-layer cones
                    if(v0.length>0){
                        [[sharedCone0,0x2d5a1e,0.55],[sharedCone1,0x3a6e28,0.9],[sharedCone2,0x468032,1.25]].forEach(([geo,col,yOff])=>{
                            const cm=new THREE.InstancedMesh(geo,new THREE.MeshLambertMaterial({color:col}),v0.length);
                            cm.castShadow=true;
                            v0.forEach((t,i)=>{_dummy.position.set(t.x,heightMap[t.x][t.z]+yOff,t.z);_dummy.scale.set(1,1,1);_dummy.updateMatrix();cm.setMatrixAt(i,_dummy.matrix);});
                            cm.instanceMatrix.needsUpdate=true;group.add(cm);
                        });
                    }
                    // Variant 1: round canopy
                    if(v1.length>0){
                        const lm=new THREE.InstancedMesh(sharedLeafBall,new THREE.MeshLambertMaterial({color:0x3a8030}),v1.length);
                        lm.castShadow=true;
                        v1.forEach((t,i)=>{_dummy.position.set(t.x,heightMap[t.x][t.z]+0.75,t.z);_dummy.scale.set(1,1,1);_dummy.updateMatrix();lm.setMatrixAt(i,_dummy.matrix);});
                        lm.instanceMatrix.needsUpdate=true;group.add(lm);
                    }
                    // Variant 2: icosphere canopy
                    if(v2.length>0){
                        const im2=new THREE.InstancedMesh(sharedLeafIco,new THREE.MeshLambertMaterial({color:0x2a6a20}),v2.length);
                        im2.castShadow=true;
                        v2.forEach((t,i)=>{_dummy.position.set(t.x,heightMap[t.x][t.z]+0.6,t.z);_dummy.scale.set(1,1,1);_dummy.updateMatrix();im2.setMatrixAt(i,_dummy.matrix);});
                        im2.instanceMatrix.needsUpdate=true;group.add(im2);
                    }
                }
                // Rocks ‚Äî batch by color
                if(decs.rocks.length>0){
                    const byColor={};
                    decs.rocks.forEach(r=>{const c=r.rc;if(!byColor[c])byColor[c]=[];byColor[c].push(r);});
                    Object.entries(byColor).forEach(([col,rocks])=>{
                        const rm=new THREE.InstancedMesh(sharedRockGeo,new THREE.MeshLambertMaterial({color:parseInt(col)}),rocks.length);
                        rm.castShadow=true;
                        rocks.forEach((r,i)=>{
                            _dummy.position.set(r.x+r.ox,heightMap[r.x][r.z]+0.1,r.z+r.oz);
                            _dummy.rotation.set(r.rx,r.ry,r.rzr);_dummy.scale.set(r.size/0.2,r.size/0.2,r.size/0.2);
                            _dummy.updateMatrix();rm.setMatrixAt(i,_dummy.matrix);
                            _dummy.rotation.set(0,0,0);_dummy.scale.set(1,1,1);
                        });
                        rm.instanceMatrix.needsUpdate=true;group.add(rm);
                    });
                }
                // Flowers ‚Äî batch by color
                if(decs.flowers.length>0){
                    const byColor={};
                    decs.flowers.forEach(f=>{const c=f.color;if(!byColor[c])byColor[c]=[];byColor[c].push(f);});
                    Object.entries(byColor).forEach(([col,flowers])=>{
                        const fm=new THREE.InstancedMesh(sharedFlowerGeo,new THREE.MeshLambertMaterial({color:parseInt(col)}),flowers.length);
                        flowers.forEach((f,i)=>{
                            _dummy.position.set(f.x+f.ox,heightMap[f.x][f.z]+0.15,f.z+f.oz);_dummy.updateMatrix();
                            fm.setMatrixAt(i,_dummy.matrix);
                        });
                        fm.instanceMatrix.needsUpdate=true;group.add(fm);
                    });
                }
            }
            scene.add(group);loadedChunks[k]=group;
        }
        function unloadChunk(cx,cz){
            const k=chunkKey(cx,cz);const group=loadedChunks[k];if(!group)return;
            removeRayTargets(group);
            group.traverse(c=>{if(c.isMesh||c.isInstancedMesh){if(c.geometry&&c.geometry!==sharedTileGeo&&c.geometry!==sharedBridgeGeo&&c.geometry!==sharedTrunkGeo&&c.geometry!==sharedCone0&&c.geometry!==sharedCone1&&c.geometry!==sharedCone2&&c.geometry!==sharedLeafBall&&c.geometry!==sharedLeafIco&&c.geometry!==sharedRockGeo&&c.geometry!==sharedFlowerGeo&&c.geometry!==sharedRailGeo)c.geometry.dispose();if(c.material&&c.material!==sharedTileMat&&c.material!==sharedBridgeMat&&c.material!==sharedRailMat)c.material.dispose();}});
            scene.remove(group);delete loadedChunks[k];
        }
        let lastChunkX=-999,lastChunkZ=-999;
        function updateChunks(px,pz){
            const cx=Math.floor(px/CHUNK_SIZE),cz=Math.floor(pz/CHUNK_SIZE);
            if(cx===lastChunkX&&cz===lastChunkZ)return;
            lastChunkX=cx;lastChunkZ=cz;
            const maxCX=Math.ceil(MAP_SIZE/CHUNK_SIZE);
            const needed=new Set();
            for(let dx=-RENDER_DISTANCE;dx<=RENDER_DISTANCE;dx++)for(let dz=-RENDER_DISTANCE;dz<=RENDER_DISTANCE;dz++){
                const ncx=cx+dx,ncz=cz+dz;
                if(ncx>=0&&ncx<maxCX&&ncz>=0&&ncz<maxCX){needed.add(chunkKey(ncx,ncz));loadChunk(ncx,ncz);}
            }
            for(const k of Object.keys(loadedChunks)){if(!needed.has(k)){const [a,b]=k.split(',').map(Number);unloadChunk(a,b);}}
        }
        // Load initial chunks around spawn
        updateChunks(mapCenter,mapCenter);

        // Water plane
        const waterGeo=new THREE.PlaneGeometry(MAP_SIZE,MAP_SIZE,20,20);const waterMat=new THREE.MeshLambertMaterial({color:0x2288aa,transparent:true,opacity:0.6});const waterMesh=new THREE.Mesh(waterGeo,waterMat);waterMesh.rotation.x=-Math.PI/2;waterMesh.position.set(mapCenter,WATER_LEVEL+0.05,mapCenter);scene.add(waterMesh);

        // Buildings
        const buildingDoors={};
        const buildingRoofs=new Map(); // id ‚Üí {roof, walls, bounds:{minX,maxX,minZ,maxZ}}

        // Floor colors per building
        const FLOOR_COLORS={
            town_hall:0x6B4226, arena:0xC2B280, bank:0xCCCCCC, health_clinic:0x8B7355,
            gym:0x7a6548, academy:0x8B6914, library:0x6B4226, exchange:0x8a8a8a,
            general_store:0x8B7355, workshop:0x777777, forge:0x555555, studio:0xBB9966,
            gallery:0xDDDDDD, broadcast_tower:0x666666, ad_agency:0x8B7355,
            farm:0x8B7355, tavern:0x5a3a1a, forest_outpost:0x6B8E23,
            ruins_gate:0x6e6e6e, deep_entrance:0x2a1a3a
        };

        // Open-air buildings (no roof)
        const OPEN_AIR=['arena','farm'];

        // Furniture definitions per building
        const BUILDING_FURNITURE={
            town_hall:[
                {type:'box',w:1.8,h:0.4,d:0.6,y:0.2,x:0,z:-0.3,color:0x5a3a1a},// long table
                {type:'box',w:0.25,h:0.5,d:0.25,y:0.25,x:-0.5,z:0.5,color:0x5a3a1a},// chair
                {type:'box',w:0.25,h:0.5,d:0.25,y:0.25,x:0.5,z:0.5,color:0x5a3a1a},// chair
                {type:'box',w:0.06,h:0.8,d:0.02,y:0.4,x:-0.8,z:-1.0,color:0x8b5cf6},// banner L
                {type:'box',w:0.06,h:0.8,d:0.02,y:0.4,x:0.8,z:-1.0,color:0x8b5cf6} // banner R
            ],
            arena:[
                {type:'box',w:0.3,h:0.8,d:0.15,y:0.4,x:-1.2,z:-1.2,color:0x5a3a1a},// weapon rack
                {type:'cyl',r:0.12,h:0.9,y:0.45,x:0.8,z:-0.8,color:0xBB9966},// dummy 1
                {type:'box',w:0.4,h:0.04,d:0.4,y:0.02,x:0.8,z:-0.8,color:0x888888},// dummy base
                {type:'cyl',r:0.12,h:0.9,y:0.45,x:-0.8,z:0.8,color:0xBB9966},// dummy 2
                {type:'box',w:0.4,h:0.04,d:0.4,y:0.02,x:-0.8,z:0.8,color:0x888888} // dummy base 2
            ],
            bank:[
                {type:'box',w:1.5,h:0.5,d:0.3,y:0.25,x:0,z:0,color:0xD4AF37},// counter
                {type:'box',w:0.35,h:0.3,d:0.3,y:0.15,x:-0.4,z:-0.5,color:0xDAA520},// gold chest L
                {type:'box',w:0.35,h:0.3,d:0.3,y:0.15,x:0.4,z:-0.5,color:0xDAA520} // gold chest R
            ],
            health_clinic:[
                {type:'box',w:0.6,h:0.25,d:0.35,y:0.12,x:-0.5,z:-0.3,color:0xEEEEEE},// bed 1
                {type:'box',w:0.6,h:0.25,d:0.35,y:0.12,x:0.5,z:-0.3,color:0xEEEEEE},// bed 2
                {type:'box',w:0.3,h:0.6,d:0.15,y:0.3,x:0,z:-0.7,color:0x5a3a1a} // potion shelf
            ],
            gym:[
                {type:'cyl',r:0.12,h:0.9,y:0.45,x:0,z:-0.3,color:0xBB9966},// dummy
                {type:'cyl',r:0.06,h:0.15,y:0.08,x:-0.5,z:0.3,color:0x444444},// weight L
                {type:'cyl',r:0.06,h:0.15,y:0.08,x:0.5,z:0.3,color:0x444444} // weight R
            ],
            academy:[
                {type:'box',w:0.5,h:0.35,d:0.35,y:0.17,x:-0.5,z:0.2,color:0x5a3a1a},// desk 1
                {type:'box',w:0.5,h:0.35,d:0.35,y:0.17,x:0.5,z:0.2,color:0x5a3a1a},// desk 2
                {type:'box',w:1.2,h:0.7,d:0.06,y:0.5,x:0,z:-0.9,color:0x222222} // blackboard
            ],
            library:[
                {type:'box',w:0.3,h:0.8,d:0.2,y:0.4,x:-0.5,z:-0.4,color:0x5a3a1a},// bookshelf L
                {type:'box',w:0.25,h:0.12,d:0.18,y:0.55,x:-0.5,z:-0.4,color:0xcc3333},// books red
                {type:'box',w:0.3,h:0.8,d:0.2,y:0.4,x:0.5,z:-0.4,color:0x5a3a1a},// bookshelf R
                {type:'box',w:0.25,h:0.12,d:0.18,y:0.55,x:0.5,z:-0.4,color:0x3366cc},// books blue
                {type:'box',w:0.6,h:0.3,d:0.4,y:0.15,x:0,z:0.3,color:0x6B4226} // reading table
            ],
            exchange:[
                {type:'box',w:1.5,h:0.5,d:0.3,y:0.25,x:0,z:0,color:0x8B7355},// trading counter
                {type:'box',w:0.25,h:0.05,d:0.15,y:0.53,x:0.3,z:0,color:0xBB9966} // ledger
            ],
            general_store:[
                {type:'box',w:0.35,h:0.35,d:0.35,y:0.17,x:-0.4,z:-0.3,color:0x8B6914},// crate 1
                {type:'box',w:0.3,h:0.3,d:0.3,y:0.5,x:-0.4,z:-0.3,color:0x7a5c12},// crate 2 stacked
                {type:'cyl',r:0.18,h:0.4,y:0.2,x:0.4,z:0.2,color:0x5a3a1a} // barrel
            ],
            workshop:[
                {type:'box',w:1.0,h:0.45,d:0.5,y:0.22,x:0,z:-0.3,color:0x6B4226},// workbench
                {type:'box',w:0.2,h:0.7,d:0.1,y:0.35,x:0.8,z:-0.7,color:0x5a3a1a} // tool rack
            ],
            forge:[
                {type:'cyl',r:0.15,h:0.25,y:0.12,x:-0.3,z:-0.2,color:0x444444},// anvil base
                {type:'box',w:0.3,h:0.08,d:0.2,y:0.28,x:-0.3,z:-0.2,color:0x555555},// anvil top
                {type:'box',w:0.5,h:0.5,d:0.4,y:0.25,x:0.4,z:-0.3,color:0x8B4513,emissive:0xff4400,emissiveI:0.3} // furnace
            ],
            studio:[
                {type:'box',w:0.4,h:0.5,d:0.03,y:0.5,x:-0.3,z:-0.5,color:0xEEEEDD,rotX:-0.2},// easel canvas
                {type:'box',w:0.05,h:0.7,d:0.05,y:0.35,x:-0.3,z:-0.45,color:0x5a3a1a},// easel leg
                {type:'cyl',r:0.04,h:0.1,y:0.05,x:0.3,z:0.3,color:0xcc3333},// paint pot red
                {type:'cyl',r:0.04,h:0.1,y:0.05,x:0.45,z:0.3,color:0x3366cc},// paint pot blue
                {type:'cyl',r:0.04,h:0.1,y:0.05,x:0.6,z:0.3,color:0x33aa55} // paint pot green
            ],
            gallery:[
                {type:'cyl',r:0.12,h:0.5,y:0.25,x:-0.4,z:0,color:0xCCCCCC},// pedestal L
                {type:'cyl',r:0.12,h:0.5,y:0.25,x:0.4,z:0,color:0xCCCCCC},// pedestal R
                {type:'box',w:0.5,h:0.35,d:0.03,y:0.6,x:0,z:-0.6,color:0xcc6633} // painting
            ],
            broadcast_tower:[
                {type:'box',w:0.7,h:0.4,d:0.4,y:0.2,x:0,z:0.2,color:0x444444},// console desk
                {type:'cyl',r:0.06,h:0.5,y:0.25,x:0,z:-0.4,color:0x888888} // antenna base
            ],
            ad_agency:[
                {type:'box',w:0.6,h:0.35,d:0.4,y:0.17,x:0,z:0.2,color:0x5a3a1a},// desk
                {type:'box',w:0.5,h:0.4,d:0.04,y:0.5,x:0,z:-0.6,color:0xcc8833} // pinboard
            ],
            farm:[
                {type:'box',w:0.5,h:0.4,d:0.4,y:0.2,x:-0.6,z:-0.6,color:0xDAA520},// hay bale
                {type:'box',w:0.6,h:0.2,d:0.3,y:0.1,x:0.6,z:0,color:0x5a3a1a},// trough
                {type:'box',w:0.08,h:0.6,d:0.08,y:0.3,x:-0.6,z:0.6,color:0x5a3a1a} // tool
            ],
            tavern:[
                {type:'box',w:1.2,h:0.5,d:0.3,y:0.25,x:0,z:-0.3,color:0x5a3a1a},// bar counter
                {type:'cyl',r:0.1,h:0.45,y:0.22,x:-0.4,z:0.3,color:0x5a3a1a},// stool L
                {type:'cyl',r:0.1,h:0.45,y:0.22,x:0.4,z:0.3,color:0x5a3a1a},// stool R
                {type:'cyl',r:0.15,h:0.35,y:0.17,x:0.6,z:-0.5,color:0x5a3a1a} // barrel
            ],
            forest_outpost:[
                {type:'box',w:0.3,h:0.6,d:0.12,y:0.3,x:-0.3,z:-0.3,color:0x5a3a1a},// weapon rack
                {type:'sphere',r:0.1,y:0.1,x:0.3,z:0.3,color:0xff6600,emissive:0xff4400,emissiveI:0.5},// campfire
                {type:'box',w:0.3,h:0.25,d:0.25,y:0.12,x:0.3,z:-0.3,color:0x6B4226} // supply crate
            ],
            ruins_gate:[
                {type:'cyl',r:0.12,h:0.5,y:0.25,x:-0.3,z:-0.2,color:0x888888},// broken pillar
                {type:'box',w:0.3,h:0.2,d:0.25,y:0.1,x:0.3,z:0.2,color:0x6e5a3a} // ancient chest
            ],
            deep_entrance:[
                {type:'cyl',r:0.06,h:0.4,y:0.2,x:-0.2,z:-0.2,color:0x8844aa},// crystal 1
                {type:'cyl',r:0.05,h:0.3,y:0.15,x:0.2,z:0.1,color:0x6633cc},// crystal 2
                {type:'cyl',r:0.04,h:0.25,y:0.12,x:0,z:0.3,color:0x9955dd},// crystal 3
                {type:'sphere',r:0.15,y:0.3,x:0,z:0,color:0x8844aa,emissive:0x8844aa,emissiveI:0.6} // portal glow
            ]
        };

        function addBuildingFurniture(id,group,bData){
            const items=BUILDING_FURNITURE[id];
            if(!items)return;
            items.forEach(item=>{
                let geo,mat;
                const matOpts={color:item.color};
                if(item.emissive){matOpts.emissive=item.emissive;matOpts.emissiveIntensity=item.emissiveI||0.3;}
                mat=new THREE.MeshLambertMaterial(matOpts);
                if(item.type==='box'){
                    geo=new THREE.BoxGeometry(item.w,item.h,item.d);
                }else if(item.type==='cyl'){
                    geo=new THREE.CylinderGeometry(item.r,item.r,item.h,8);
                }else if(item.type==='sphere'){
                    geo=new THREE.SphereGeometry(item.r,8,8);
                }
                if(!geo)return;
                const mesh=new THREE.Mesh(geo,mat);
                mesh.position.set(item.x||0,item.y||0,item.z||0);
                if(item.rotX)mesh.rotation.x=item.rotX;
                mesh.castShadow=true;
                mesh.userData.type='furniture';
                group.add(mesh);
            });
        }

        function createNamedBuilding(bData){
            const group=new THREE.Group();
            const baseH=heightMap[Math.min(Math.floor(bData.x),MAP_SIZE-1)][Math.min(Math.floor(bData.z),MAP_SIZE-1)]||0;

            if(bData.type==='pedestal'){
                // Pedestal buildings unchanged
                const base=new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.5,0.6,6),new THREE.MeshLambertMaterial({color:bData.wallColor}));
                base.position.y=0.3;base.castShadow=true;group.add(base);
                const board=new THREE.Mesh(new THREE.BoxGeometry(0.7,0.5,0.08),new THREE.MeshLambertMaterial({color:0x5a3a1a}));
                board.position.y=0.85;board.castShadow=true;group.add(board);
                [0xff4444,0x44ff44,0x4444ff,0xffff44].forEach((c,i)=>{
                    const p=new THREE.Mesh(new THREE.SphereGeometry(0.04,4,4),new THREE.MeshBasicMaterial({color:c}));
                    p.position.set(-0.2+(i%2)*0.4,0.75+Math.floor(i/2)*0.2,0.05);group.add(p);
                });
                const cx=Math.floor(bData.x),cz=Math.floor(bData.z);
                if(cx>=0&&cx<MAP_SIZE&&cz>=0&&cz<MAP_SIZE)grid[cx][cz]=0;
                buildingDoors[bData.id]={x:cx,z:cz+1};
            }else{
                const w=bData.w,h=bData.h,d=bData.d;
                const hw=Math.ceil(w/2),hd=Math.ceil(d/2);
                const cx=Math.floor(bData.x),cz=Math.floor(bData.z);
                const wallThick=0.08;
                const wallMat=new THREE.MeshLambertMaterial({color:bData.wallColor});
                const doorGap=0.6;
                const isOpenAir=OPEN_AIR.includes(bData.id);

                // --- 4 thin walls with doorway gap ---
                const sides=['north','south','east','west'];
                sides.forEach(side=>{
                    const isDoorSide=(bData.doorSide===side);
                    if(side==='north'||side==='south'){
                        const zPos=(side==='south')?d/2:-d/2;
                        if(!isDoorSide){
                            // Full wall
                            const wm=new THREE.Mesh(new THREE.BoxGeometry(w,h,wallThick),wallMat);
                            wm.position.set(0,h/2,zPos);wm.castShadow=true;wm.receiveShadow=true;group.add(wm);
                        }else{
                            // Split wall with door gap
                            const halfW=(w-doorGap)/2;
                            if(halfW>0.05){
                                const wL=new THREE.Mesh(new THREE.BoxGeometry(halfW,h,wallThick),wallMat);
                                wL.position.set(-(doorGap/2+halfW/2),h/2,zPos);wL.castShadow=true;group.add(wL);
                                const wR=new THREE.Mesh(new THREE.BoxGeometry(halfW,h,wallThick),wallMat);
                                wR.position.set(doorGap/2+halfW/2,h/2,zPos);wR.castShadow=true;group.add(wR);
                            }
                            // Door frame
                            const frame=new THREE.Mesh(new THREE.BoxGeometry(doorGap+0.1,h,0.06),new THREE.MeshLambertMaterial({color:0x3a2a1a}));
                            frame.position.set(0,h/2,zPos);frame.castShadow=true;group.add(frame);
                            // Door opening (slightly recessed)
                            const opening=new THREE.Mesh(new THREE.BoxGeometry(doorGap-0.04,h-0.1,0.08),new THREE.MeshLambertMaterial({color:0x111111}));
                            opening.position.set(0,h/2-0.05,zPos);group.add(opening);
                        }
                    }else{
                        const xPos=(side==='east')?w/2:-w/2;
                        if(!isDoorSide){
                            const wm=new THREE.Mesh(new THREE.BoxGeometry(wallThick,h,d),wallMat);
                            wm.position.set(xPos,h/2,0);wm.castShadow=true;wm.receiveShadow=true;group.add(wm);
                        }else{
                            const halfD=(d-doorGap)/2;
                            if(halfD>0.05){
                                const wL=new THREE.Mesh(new THREE.BoxGeometry(wallThick,h,halfD),wallMat);
                                wL.position.set(xPos,h/2,-(doorGap/2+halfD/2));wL.castShadow=true;group.add(wL);
                                const wR=new THREE.Mesh(new THREE.BoxGeometry(wallThick,h,halfD),wallMat);
                                wR.position.set(xPos,h/2,doorGap/2+halfD/2);wR.castShadow=true;group.add(wR);
                            }
                            const frame=new THREE.Mesh(new THREE.BoxGeometry(0.06,h,doorGap+0.1),new THREE.MeshLambertMaterial({color:0x3a2a1a}));
                            frame.position.set(xPos,h/2,0);frame.castShadow=true;group.add(frame);
                            const opening=new THREE.Mesh(new THREE.BoxGeometry(0.08,h-0.1,doorGap-0.04),new THREE.MeshLambertMaterial({color:0x111111}));
                            opening.position.set(xPos,h/2-0.05,0);group.add(opening);
                        }
                    }
                });

                // --- Interior floor tiles ---
                const floorColor=FLOOR_COLORS[bData.id]||0x8B7355;
                const floorMat=new THREE.MeshLambertMaterial({color:floorColor});
                for(let bx=cx-(hw-1);bx<=cx+(hw-1);bx++){
                    for(let bz=cz-(hd-1);bz<=cz+(hd-1);bz++){
                        if(bx>=0&&bx<MAP_SIZE&&bz>=0&&bz<MAP_SIZE){
                            const ft=new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE,0.04,TILE_SIZE),floorMat);
                            ft.position.set(bx-bData.x,0.02,bz-bData.z);
                            ft.receiveShadow=true;
                            ft.userData={tileX:bx,tileZ:bz,walkable:true,type:'tile'};
                            group.add(ft);
                            terrainColors[bx][bz]=floorColor;
                        }
                    }
                }

                // --- Roof (cone) ---
                const roof=new THREE.Mesh(
                    new THREE.ConeGeometry(Math.max(w,d)*0.75,h*0.5,4),
                    new THREE.MeshLambertMaterial({color:bData.roofColor})
                );
                roof.position.y=h+h*0.2;roof.rotation.y=Math.PI/4;roof.castShadow=true;
                if(isOpenAir)roof.visible=false;
                group.add(roof);

                // --- Grid: footprint‚Üí0, interior‚Üí4, doorway wall‚Üí4, door tile‚Üí1 ---
                for(let bx=cx-hw;bx<=cx+hw;bx++)
                    for(let bz=cz-hd;bz<=cz+hd;bz++)
                        if(bx>=0&&bx<MAP_SIZE&&bz>=0&&bz<MAP_SIZE)grid[bx][bz]=0;
                for(let bx=cx-(hw-1);bx<=cx+(hw-1);bx++)
                    for(let bz=cz-(hd-1);bz<=cz+(hd-1);bz++)
                        if(bx>=0&&bx<MAP_SIZE&&bz>=0&&bz<MAP_SIZE)grid[bx][bz]=4;
                // Doorway wall tile
                switch(bData.doorSide){
                    case'south':if(cz+hd<MAP_SIZE)grid[cx][cz+hd]=4;break;
                    case'north':if(cz-hd>=0)grid[cx][cz-hd]=4;break;
                    case'west':if(cx-hw>=0)grid[cx-hw][cz]=4;break;
                    case'east':if(cx+hw<MAP_SIZE)grid[cx+hw][cz]=4;break;
                }
                // External door tile
                let dt;
                switch(bData.doorSide){
                    case'south':dt={x:cx,z:cz+hd+1};break;
                    case'north':dt={x:cx,z:cz-hd-1};break;
                    case'west':dt={x:cx-hw-1,z:cz};break;
                    case'east':dt={x:cx+hw+1,z:cz};break;
                }
                if(dt&&dt.x>=0&&dt.x<MAP_SIZE&&dt.z>=0&&dt.z<MAP_SIZE){
                    grid[dt.x][dt.z]=1;
                    buildingDoors[bData.id]=dt;
                }

                // --- Furniture ---
                addBuildingFurniture(bData.id,group,bData);

                // --- Store roof ref for visibility toggling ---
                buildingRoofs.set(bData.id,{
                    roof:roof,
                    isOpenAir:isOpenAir,
                    bounds:{minX:cx-hw,maxX:cx+hw,minZ:cz-hd,maxZ:cz+hd}
                });
            }

            group.position.set(bData.x,baseH,bData.z);
            group.traverse(c=>{if(c.isMesh){c.userData.buildingId=bData.id;if(!c.userData.type)c.userData.type='building';}});
            scene.add(group);addRayTarget(group);
        }
        BUILDINGS.forEach(b=>createNamedBuilding(b));

        // ============================================================
        // SUITE CASTLE WALLS
        // ============================================================
        (function buildCastleWalls(){
            const wallColor=0xE8D4A8, wallDark=0xC4B08A, towerColor=0xD4C098, battlementColor=0xCCBC8C;
            const wallH=2.2, wallThick=0.5, battleH=0.6;
            const cx1=CASTLE.x1,cz1=CASTLE.z1,cx2=CASTLE.x2,cz2=CASTLE.z2;
            const wallMat=new THREE.MeshLambertMaterial({color:wallColor});
            const wallDarkMat=new THREE.MeshLambertMaterial({color:wallDark});
            const towerMat=new THREE.MeshLambertMaterial({color:towerColor});
            const battleMat=new THREE.MeshLambertMaterial({color:battlementColor});
            const castleGroup=new THREE.Group();

            // North wall (full width)
            const nLen=cx2-cx1+1;
            const nWall=new THREE.Mesh(new THREE.BoxGeometry(nLen,wallH,wallThick),wallMat);
            nWall.position.set((cx1+cx2)/2,wallH/2,cz1);nWall.castShadow=true;castleGroup.add(nWall);
            // North battlements
            for(let bx=cx1;bx<=cx2;bx+=2){const b=new THREE.Mesh(new THREE.BoxGeometry(0.6,battleH,wallThick+0.1),battleMat);b.position.set(bx,wallH+battleH/2,cz1);b.castShadow=true;castleGroup.add(b);}

            // South wall (split for gate at x=99-101)
            const sLeftLen=99-cx1;
            const sRightLen=cx2-101;
            if(sLeftLen>0){const sw=new THREE.Mesh(new THREE.BoxGeometry(sLeftLen,wallH,wallThick),wallMat);sw.position.set(cx1+sLeftLen/2,wallH/2,cz2);sw.castShadow=true;castleGroup.add(sw);
            for(let bx=cx1;bx<99;bx+=2){const b=new THREE.Mesh(new THREE.BoxGeometry(0.6,battleH,wallThick+0.1),battleMat);b.position.set(bx,wallH+battleH/2,cz2);b.castShadow=true;castleGroup.add(b);}}
            if(sRightLen>0){const sw=new THREE.Mesh(new THREE.BoxGeometry(sRightLen,wallH,wallThick),wallMat);sw.position.set(101+sRightLen/2,wallH/2,cz2);sw.castShadow=true;castleGroup.add(sw);
            for(let bx=102;bx<=cx2;bx+=2){const b=new THREE.Mesh(new THREE.BoxGeometry(0.6,battleH,wallThick+0.1),battleMat);b.position.set(bx,wallH+battleH/2,cz2);b.castShadow=true;castleGroup.add(b);}}
            // Gate arch
            const gateArch=new THREE.Mesh(new THREE.BoxGeometry(3.2,0.4,wallThick+0.15),wallDarkMat);gateArch.position.set(100,wallH-0.2,cz2);gateArch.castShadow=true;castleGroup.add(gateArch);
            // Gate pillars
            const gpGeo=new THREE.BoxGeometry(0.5,wallH+0.5,wallThick+0.15);
            const gp1=new THREE.Mesh(gpGeo,wallDarkMat);gp1.position.set(98.7,(wallH+0.5)/2,cz2);gp1.castShadow=true;castleGroup.add(gp1);
            const gp2=new THREE.Mesh(gpGeo,wallDarkMat);gp2.position.set(101.3,(wallH+0.5)/2,cz2);gp2.castShadow=true;castleGroup.add(gp2);

            // West wall
            const wLen=cz2-cz1+1;
            const wWall=new THREE.Mesh(new THREE.BoxGeometry(wallThick,wallH,wLen),wallMat);
            wWall.position.set(cx1,wallH/2,(cz1+cz2)/2);wWall.castShadow=true;castleGroup.add(wWall);
            for(let bz=cz1;bz<=cz2;bz+=2){const b=new THREE.Mesh(new THREE.BoxGeometry(wallThick+0.1,battleH,0.6),battleMat);b.position.set(cx1,wallH+battleH/2,bz);b.castShadow=true;castleGroup.add(b);}

            // East wall
            const eWall=new THREE.Mesh(new THREE.BoxGeometry(wallThick,wallH,wLen),wallMat);
            eWall.position.set(cx2,wallH/2,(cz1+cz2)/2);eWall.castShadow=true;castleGroup.add(eWall);
            for(let bz=cz1;bz<=cz2;bz+=2){const b=new THREE.Mesh(new THREE.BoxGeometry(wallThick+0.1,battleH,0.6),battleMat);b.position.set(cx2,wallH+battleH/2,bz);b.castShadow=true;castleGroup.add(b);}

            // Corner towers (4 cylindrical towers)
            const towerR=0.8,towerH=3.2;
            const tGeo=new THREE.CylinderGeometry(towerR,towerR+0.1,towerH,8);
            const capGeo=new THREE.ConeGeometry(towerR+0.2,1.2,8);
            [[cx1,cz1],[cx2,cz1],[cx1,cz2],[cx2,cz2]].forEach(([tx,tz])=>{
                const t=new THREE.Mesh(tGeo,towerMat);t.position.set(tx,towerH/2,tz);t.castShadow=true;castleGroup.add(t);
                const cap=new THREE.Mesh(capGeo,new THREE.MeshLambertMaterial({color:0x8b5cf6}));cap.position.set(tx,towerH+0.6,tz);cap.castShadow=true;castleGroup.add(cap);
            });

            // SUITE banner above gate
            const bannerPole=new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,1.5,4),new THREE.MeshLambertMaterial({color:0x5a3a1a}));
            bannerPole.position.set(100,wallH+1,cz2);castleGroup.add(bannerPole);
            const banner=new THREE.Mesh(new THREE.BoxGeometry(1.2,0.8,0.03),new THREE.MeshLambertMaterial({color:0x8b5cf6}));
            banner.position.set(100,wallH+1.2,cz2+0.3);castleGroup.add(banner);

            scene.add(castleGroup);
        })();

        // ============================================================
        // CASTLE COURTYARD PROPS
        // ============================================================
        // Central Fountain at (100, 91)
        const fountainGroup=new THREE.Group();
        const fountainBase=new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.4,0.4,16),new THREE.MeshLambertMaterial({color:0x888888}));
        fountainBase.position.y=0.2;fountainBase.castShadow=true;fountainGroup.add(fountainBase);
        const fountainRim=new THREE.Mesh(new THREE.TorusGeometry(1.2,0.12,8,16),new THREE.MeshLambertMaterial({color:0x777777}));
        fountainRim.rotation.x=-Math.PI/2;fountainRim.position.y=0.4;fountainGroup.add(fountainRim);
        const fountainWater=new THREE.Mesh(new THREE.CylinderGeometry(1.1,1.1,0.08,16),new THREE.MeshLambertMaterial({color:0x4488cc,transparent:true,opacity:0.6}));
        fountainWater.position.y=0.3;fountainGroup.add(fountainWater);
        const fountainPillar=new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.2,1.4,8),new THREE.MeshLambertMaterial({color:0x999999}));
        fountainPillar.position.y=0.9;fountainPillar.castShadow=true;fountainGroup.add(fountainPillar);
        const fountainSpray=[];
        for(let i=0;i<12;i++){
            const drop=new THREE.Mesh(new THREE.SphereGeometry(0.04,4,4),new THREE.MeshBasicMaterial({color:0x88ccff,transparent:true,opacity:0.7}));
            drop.position.y=1.6;fountainGroup.add(drop);fountainSpray.push({mesh:drop,angle:i*(Math.PI*2/12),speed:0.8+Math.random()*0.4});
        }
        fountainGroup.position.set(100,0,91);scene.add(fountainGroup);
        // Block 3x3 around fountain (centered at 100,91)
        for(let fx=99;fx<=101;fx++)for(let fz=90;fz<=92;fz++)if(fx>=0&&fx<MAP_SIZE&&fz>=0&&fz<MAP_SIZE)grid[fx][fz]=0;

        // Lampposts (12 total)
        const lampposts=[];
        const lampPositions=[
            // 4 inside castle courtyard
            {x:88,z:95},{x:112,z:95},{x:96,z:99},{x:104,z:99},
            // 4 along south road from gate
            {x:100,z:112},{x:100,z:118},{x:100,z:124},{x:100,z:130},
            // 4 along roads outside castle
            {x:80,z:95},{x:120,z:95},{x:100,z:76},{x:100,z:70}
        ];
        lampPositions.forEach(lp=>{
            const g=new THREE.Group();
            const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.05,1.6,6),new THREE.MeshLambertMaterial({color:0x444444}));
            pole.position.y=0.8;pole.castShadow=true;g.add(pole);
            const glow=new THREE.Mesh(new THREE.SphereGeometry(0.12,8,8),new THREE.MeshBasicMaterial({color:0xffdd88,transparent:true,opacity:0.3}));
            glow.position.y=1.65;g.add(glow);
            const light=new THREE.PointLight(0xffdd88,0.8,6);
            light.position.y=1.65;light.visible=false;g.add(light);
            const h=heightMap[Math.min(lp.x,MAP_SIZE-1)]?heightMap[Math.min(lp.x,MAP_SIZE-1)][Math.min(lp.z,MAP_SIZE-1)]||0:0;
            g.position.set(lp.x,h,lp.z);scene.add(g);
            lampposts.push({group:g,glow:glow,light:light});
        });

        // Market Stalls (inside castle courtyard)
        const stallColors=[0xcc3333,0x3366cc,0xccaa33,0x33aa55];
        [{x:97,z:91},{x:100,z:91},{x:103,z:91},{x:97,z:93}].forEach((sp,i)=>{
            const g=new THREE.Group();
            const counter=new THREE.Mesh(new THREE.BoxGeometry(1.2,0.6,0.6),new THREE.MeshLambertMaterial({color:0x8B6914}));
            counter.position.y=0.3;counter.castShadow=true;g.add(counter);
            const canopy=new THREE.Mesh(new THREE.BoxGeometry(1.4,0.05,0.8),new THREE.MeshLambertMaterial({color:stallColors[i]}));
            canopy.position.set(0,1.3,0);canopy.rotation.x=-0.15;canopy.castShadow=true;g.add(canopy);
            const poleGeo=new THREE.CylinderGeometry(0.03,0.03,1.3,4);const poleMat=new THREE.MeshLambertMaterial({color:0x5a3a1a});
            [{x:-0.55,z:-0.3},{x:0.55,z:-0.3},{x:-0.55,z:0.3},{x:0.55,z:0.3}].forEach(pp=>{
                const p=new THREE.Mesh(poleGeo,poleMat);p.position.set(pp.x,0.65,pp.z);g.add(p);
            });
            g.position.set(sp.x,0,sp.z);scene.add(g);
        });

        // Crates & Barrels (decorative, around castle exterior)
        const crateBarrelPositions=[
            {x:100,z:110,type:'crate'},{x:101,z:111,type:'barrel'},{x:99,z:110,type:'barrel'},
            {x:115,z:95,type:'crate'},{x:116,z:97,type:'barrel'},
            {x:85,z:95,type:'crate'},{x:84,z:93,type:'barrel'},
            {x:66,z:91,type:'crate'},{x:67,z:89,type:'barrel'},
            {x:131,z:99,type:'crate'},{x:132,z:101,type:'barrel'},{x:130,z:102,type:'crate'}
        ];
        crateBarrelPositions.forEach(cb=>{
            const h=heightMap[Math.min(cb.x,MAP_SIZE-1)]?heightMap[Math.min(cb.x,MAP_SIZE-1)][Math.min(cb.z,MAP_SIZE-1)]||0:0;
            if(cb.type==='crate'){
                const m=new THREE.Mesh(new THREE.BoxGeometry(0.28,0.28,0.28),new THREE.MeshLambertMaterial({color:0x8B6914}));
                m.position.set(cb.x,h+0.14,cb.z);m.rotation.y=cb.x*1.3;m.castShadow=true;scene.add(m);
            }else{
                const m=new THREE.Mesh(new THREE.CylinderGeometry(0.14,0.14,0.3,8),new THREE.MeshLambertMaterial({color:0x6B4226}));
                m.position.set(cb.x,h+0.15,cb.z);m.castShadow=true;scene.add(m);
            }
        });

        // Signposts (3 at road intersections)
        [{x:100,z:82,boards:[{color:0x22c55e,ry:0},{color:0x3b82f6,ry:Math.PI/3},{color:0xeab308,ry:-Math.PI/4}]},
         {x:87,z:95,boards:[{color:0x8b5cf6,ry:Math.PI/6},{color:0xec4899,ry:-Math.PI/3}]},
         {x:120,z:95,boards:[{color:0xf97316,ry:-Math.PI/6},{color:0x14b8a6,ry:Math.PI/4},{color:0xef4444,ry:Math.PI/2}]}
        ].forEach(sp=>{
            const g=new THREE.Group();
            const post=new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.05,1.5,6),new THREE.MeshLambertMaterial({color:0x5a3a1a}));
            post.position.y=0.75;post.castShadow=true;g.add(post);
            sp.boards.forEach((b,i)=>{
                const board=new THREE.Mesh(new THREE.BoxGeometry(0.5,0.12,0.04),new THREE.MeshLambertMaterial({color:b.color}));
                board.position.set(0.15,1.2-i*0.18,0);board.rotation.y=b.ry;board.castShadow=true;g.add(board);
            });
            const h=heightMap[Math.min(sp.x,MAP_SIZE-1)]?heightMap[Math.min(sp.x,MAP_SIZE-1)][Math.min(sp.z,MAP_SIZE-1)]||0:0;
            g.position.set(sp.x,h,sp.z);scene.add(g);
        });

        // Fireflies
        const particles=[];
        for(let i=0;i<250;i++){const p=new THREE.Mesh(new THREE.SphereGeometry(0.03,4,4),new THREE.MeshBasicMaterial({color:0xffff88}));p.position.set(rng()*MAP_SIZE,0.5+rng()*1.5,rng()*MAP_SIZE);p.userData.speed=0.2+rng()*0.5;p.userData.offset=rng()*Math.PI*2;p.visible=false;scene.add(p);particles.push(p);}

        // Tile highlight
        const highlightMat=new THREE.MeshBasicMaterial({color:0xffff00,transparent:true,opacity:0.3});
        const highlight=new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE,0.02,TILE_SIZE),highlightMat);highlight.visible=false;scene.add(highlight);
        // ============================================================
        // PLAYER CHARACTER (local visual)
        // ============================================================
        function createCharacterMesh(bodyCol, hairCol){
            const g=new THREE.Group();
            const body=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.5,0.2),new THREE.MeshLambertMaterial({color:bodyCol}));body.position.y=0.5;body.castShadow=true;g.add(body);
            const head=new THREE.Mesh(new THREE.BoxGeometry(0.25,0.25,0.25),new THREE.MeshLambertMaterial({color:0xffcc99}));head.position.y=0.9;head.castShadow=true;g.add(head);
            if(hairCol){const hair=new THREE.Mesh(new THREE.BoxGeometry(0.27,0.08,0.27),new THREE.MeshLambertMaterial({color:hairCol}));hair.position.y=1.04;g.add(hair);}
            const lGeo=new THREE.BoxGeometry(0.1,0.3,0.15),lMat=new THREE.MeshLambertMaterial({color:0x554433});
            // Leg pivots at hip joints
            const llPivot=new THREE.Group();llPivot.position.set(-0.08,0.30,0);
            const llMesh=new THREE.Mesh(lGeo,lMat);llMesh.position.set(0,-0.15,0);llMesh.castShadow=true;llPivot.add(llMesh);g.add(llPivot);
            const rlPivot=new THREE.Group();rlPivot.position.set(0.08,0.30,0);
            const rlMesh=new THREE.Mesh(lGeo,lMat);rlMesh.position.set(0,-0.15,0);rlMesh.castShadow=true;rlPivot.add(rlMesh);g.add(rlPivot);
            // Arm pivots at shoulder joints
            const aGeo=new THREE.BoxGeometry(0.08,0.35,0.1),aMat=new THREE.MeshLambertMaterial({color:bodyCol});
            const laPivot=new THREE.Group();laPivot.position.set(-0.22,0.72,0);
            const laMesh=new THREE.Mesh(aGeo,aMat);laMesh.position.set(0,-0.175,0);laMesh.castShadow=true;laPivot.add(laMesh);g.add(laPivot);
            const raPivot=new THREE.Group();raPivot.position.set(0.22,0.72,0);
            const raMesh=new THREE.Mesh(aGeo,aMat);raMesh.position.set(0,-0.175,0);raMesh.castShadow=true;raPivot.add(raMesh);g.add(raPivot);
            const sh=new THREE.Mesh(new THREE.CircleGeometry(0.2,8),new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0.2}));sh.rotation.x=-Math.PI/2;sh.position.y=0.02;g.add(sh);
            return{group:g,body,head,leftLeg:llPivot,rightLeg:rlPivot,leftArm:laPivot,rightArm:raPivot,walkPhase:0,walkBlend:0,equipMeshes:{}};
        }

        // ============================================================
        // CUSTOM CHARACTER MODEL (from Forge)
        // ============================================================
        async function createCharacterFromModel(modelUrl) {
            const proxyUrl = '/api/proxy-model?url=' + encodeURIComponent(modelUrl);
            const gltf = await new Promise((resolve, reject) => {
                new THREE.GLTFLoader().load(proxyUrl, resolve, undefined, reject);
            });
            const model = gltf.scene;
            model.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = false; } });

            // Normalize to character height (~1.1 units)
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const maxH = size.y || 1;
            const s = 1.1 / maxH;
            model.scale.set(s, s, s);
            model.position.set(-center.x * s, -box.min.y * s, -center.z * s);

            const g = new THREE.Group();
            g.add(model);

            // Shadow disc
            const sh = new THREE.Mesh(new THREE.CircleGeometry(0.25, 8), new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.2}));
            sh.rotation.x = -Math.PI / 2; sh.position.y = 0.02; g.add(sh);

            // Virtual pivot groups for equipment attachment (estimated from bounding box)
            const charH = 1.1;
            const headPivot = new THREE.Group(); headPivot.position.set(0, charH * 0.82, 0); g.add(headPivot);
            const raPivot = new THREE.Group(); raPivot.position.set(size.x * s * 0.45, charH * 0.55, 0); g.add(raPivot);
            const laPivot = new THREE.Group(); laPivot.position.set(-size.x * s * 0.45, charH * 0.55, 0); g.add(laPivot);

            // Body reference for animation (the model root)
            const bodyRef = model;

            return {
                group: g, body: bodyRef, head: headPivot,
                leftLeg: laPivot, rightLeg: raPivot,  // reuse arm pivots as fallbacks
                leftArm: laPivot, rightArm: raPivot,
                walkPhase: 0, walkBlend: 0, equipMeshes: {},
                isCustomModel: true, modelRoot: model
            };
        }

        // ============================================================
        // EQUIPMENT 3D MODEL SYSTEM
        // ============================================================
        const gltfLoader = new THREE.GLTFLoader();
        const modelCache = {}; // itemId -> THREE.Group (cloneable)
        let forgeDB = null;

        // Open the forge's IndexedDB to read model URLs
        function openForgeDB() {
            return new Promise((resolve) => {
                try {
                    const req = indexedDB.open('agentscape-forge', 2);
                    req.onsuccess = (e) => { forgeDB = e.target.result; resolve(true); };
                    req.onerror = () => resolve(false);
                    req.onupgradeneeded = (e) => {
                        // Don't create stores ‚Äî just reading. Close and skip.
                        e.target.transaction.abort();
                        resolve(false);
                    };
                } catch(e) { resolve(false); }
            });
        }

        function getForgeAsset(itemId) {
            if (!forgeDB) return Promise.resolve(null);
            return new Promise((resolve) => {
                try {
                    const tx = forgeDB.transaction('assets', 'readonly');
                    const req = tx.objectStore('assets').get(itemId);
                    req.onsuccess = () => resolve(req.result || null);
                    req.onerror = () => resolve(null);
                } catch(e) { resolve(null); }
            });
        }

        function loadEquipModel(url) {
            return new Promise((resolve, reject) => {
                const proxyUrl = '/api/proxy-model?url=' + encodeURIComponent(url);
                gltfLoader.load(proxyUrl, (gltf) => {
                    const model = gltf.scene;
                    model.traverse((child) => {
                        if (child.isMesh) { child.castShadow = true; child.receiveShadow = false; }
                    });
                    resolve(model);
                }, undefined, reject);
            });
        }

        // Slot configs: where to attach, how to scale/position
        const EQUIP_SLOTS = {
            weapon: { pivot: 'rightArm', offsetY: -0.28, offsetX: 0, offsetZ: 0.1, scale: 0.5, rotX: 0, rotY: Math.PI, rotZ: -0.3 },
            helm:   { pivot: 'head', offsetY: 0.15, offsetX: 0, offsetZ: 0, scale: 0.22, rotX: 0, rotY: 0, rotZ: 0 },
            shield: { pivot: 'leftArm', offsetY: -0.18, offsetX: 0, offsetZ: 0.1, scale: 0.25, rotX: 0, rotY: 0, rotZ: 0.3 }
        };

        async function attachEquipModel(charMesh, slot, itemId) {
            // Remove existing model for this slot
            if (charMesh.equipMeshes[slot]) {
                const old = charMesh.equipMeshes[slot];
                old.parent.remove(old);
                delete charMesh.equipMeshes[slot];
            }
            if (!itemId) return;

            // Check cache first
            if (!modelCache[itemId]) {
                const asset = await getForgeAsset(itemId);
                if (!asset || !asset.modelUrl) return;
                try {
                    modelCache[itemId] = await loadEquipModel(asset.modelUrl);
                } catch(e) { console.warn('Failed to load model for', itemId, e); return; }
            }

            const cfg = EQUIP_SLOTS[slot];
            if (!cfg) return;

            const model = modelCache[itemId].clone();
            // Normalize: compute bounding box, center and scale
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const s = cfg.scale / (maxDim || 1);

            // Wrap in a container for clean positioning
            const container = new THREE.Group();
            model.scale.set(s, s, s);
            // Center the model at origin
            const center = box.getCenter(new THREE.Vector3());
            model.position.set(-center.x * s, -center.y * s, -center.z * s);
            container.add(model);
            // Apply rotations (order: X, Y, Z)
            container.rotation.set(cfg.rotX || 0, cfg.rotY || 0, cfg.rotZ || 0);
            // Apply offset position
            container.position.set(cfg.offsetX || 0, cfg.offsetY || 0, cfg.offsetZ || 0);

            // Attach to the pivot
            const pivotRef = charMesh[cfg.pivot];
            if (cfg.pivot === 'head' && !charMesh.isCustomModel) {
                const wrapper = new THREE.Group();
                wrapper.position.set(0, 0.9, 0);
                wrapper.add(container);
                charMesh.group.add(wrapper);
                charMesh.equipMeshes[slot] = wrapper;
            } else if (pivotRef) {
                pivotRef.add(container);
                charMesh.equipMeshes[slot] = container;
            }
        }

        // Optimistic unequip ‚Äî remove 3D model immediately on click, don't wait for server roundtrip
        function handleUnequip(slotType) {
            sendAction('unequip_item', {slot: slotType});
            if (myChar) removeEquipModel(myChar, slotType);
        }

        function removeEquipModel(charMesh, slot) {
            if (charMesh.equipMeshes && charMesh.equipMeshes[slot]) {
                const old = charMesh.equipMeshes[slot];
                old.parent.remove(old);
                delete charMesh.equipMeshes[slot];
            }
        }

        async function updateAllEquipment(charMesh, player) {
            const weapon = player.equippedWeapon && player.equippedWeapon.id ? player.equippedWeapon.id : null;
            const helm = player.equippedHelm && player.equippedHelm.id ? player.equippedHelm.id : null;
            const shield = player.equippedShield && player.equippedShield.id ? player.equippedShield.id : null;
            await Promise.all([
                attachEquipModel(charMesh, 'weapon', weapon),
                attachEquipModel(charMesh, 'helm', helm),
                attachEquipModel(charMesh, 'shield', shield)
            ]);
        }

        // Init forge DB connection + preload 2D image cache
        const forgeImageCache = {}; // itemId -> base64 data URL
        openForgeDB().then(async (ok) => {
            if (!ok) return;
            console.log('[Forge] Connected to asset database');
            // Preload all forge images for inventory/equip UI
            try {
                const tx = forgeDB.transaction('assets', 'readonly');
                const req = tx.objectStore('assets').getAll();
                req.onsuccess = () => {
                    const all = req.result || [];
                    all.forEach(a => { if (a.imageData) forgeImageCache[a.id] = a.imageData; });
                    console.log('[Forge] Loaded', Object.keys(forgeImageCache).length, '2D images');
                };
            } catch(e) {}
        });

        let myChar=createCharacterMesh(new THREE.Color(playerColor),new THREE.Color(playerHairColor));
        myChar.group.position.set(mapCenter,heightMap[mapCenter]?heightMap[mapCenter][mapCenter]||0:0,mapCenter);
        scene.add(myChar.group);
        let myWorldX=100,myWorldZ=95;

        // Async-load custom character model from Forge if selected
        if (charInfo.characterModelId) {
            (async () => {
                try {
                    await openForgeDB();
                    const asset = await getForgeAsset(charInfo.characterModelId);
                    if (!asset || !asset.modelUrl) return;
                    const customChar = await createCharacterFromModel(asset.modelUrl);
                    // Preserve position from current character
                    customChar.group.position.copy(myChar.group.position);
                    customChar.group.rotation.copy(myChar.group.rotation);
                    scene.remove(myChar.group);
                    scene.add(customChar.group);
                    // Transfer equipment meshes
                    Object.keys(myChar.equipMeshes).forEach(slot => {
                        const mesh = myChar.equipMeshes[slot];
                        if (mesh && mesh.parent) mesh.parent.remove(mesh);
                    });
                    myChar = customChar;
                    // Re-attach any equipped items
                    if (room && mySessionId) {
                        const p = room.state.players.get(mySessionId);
                        if (p) {
                            if (p.equippedWeapon) attachEquipModel(myChar, 'weapon', p.equippedWeapon);
                            if (p.equippedHelm) attachEquipModel(myChar, 'helm', p.equippedHelm);
                            if (p.equippedShield) attachEquipModel(myChar, 'shield', p.equippedShield);
                        }
                    }
                    console.log('[CharModel] Custom character model loaded');
                } catch(e) { console.warn('[CharModel] Failed to load custom model, keeping box mesh:', e); }
            })();
        }
        let lastZoneId='suite_city';
        function showZoneBanner(zone){
            const banner=document.getElementById('zone-banner');
            const name=zone?zone.name:'The Wilderness';
            const color=zone?zone.color:'#9ca3af';
            banner.textContent='Entering: '+name;
            banner.style.borderBottom='2px solid '+color;
            banner.classList.remove('show');
            void banner.offsetWidth;
            banner.classList.add('show');
            setTimeout(()=>banner.classList.remove('show'),3100);
        }

        // Entity tracking
        const otherPlayerMeshes=new Map();
        const npcMeshes=new Map();
        const monsterMeshes=new Map();
        const lootPileMeshes=new Map();
        let myTargetX=100,myTargetZ=95,myTargetH=0,myTargetRot=0,myIsMoving=false,myIsResting=false;
        const LERP_SPEED=5;

        function createNPCMesh(npcState){
            const role=npcState.role||'app_builder';
            const roleInfo=ROLE_COLORS[role]||ROLE_COLORS.app_builder;
            const g=new THREE.Group();g.scale.set(0.85,0.85,0.85);
            const body=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.5,0.2),new THREE.MeshLambertMaterial({color:roleInfo.int}));body.position.y=0.5;body.castShadow=true;g.add(body);
            const head=new THREE.Mesh(new THREE.BoxGeometry(0.25,0.25,0.25),new THREE.MeshLambertMaterial({color:0xffcc99}));head.position.y=0.9;head.castShadow=true;g.add(head);
            const lGeo=new THREE.BoxGeometry(0.1,0.3,0.15),lMat=new THREE.MeshLambertMaterial({color:0x444444});
            // Leg pivots at hip joints
            const llPivot=new THREE.Group();llPivot.position.set(-0.08,0.30,0);
            const llMesh=new THREE.Mesh(lGeo,lMat);llMesh.position.set(0,-0.15,0);llMesh.castShadow=true;llPivot.add(llMesh);g.add(llPivot);
            const rlPivot=new THREE.Group();rlPivot.position.set(0.08,0.30,0);
            const rlMesh=new THREE.Mesh(lGeo,lMat);rlMesh.position.set(0,-0.15,0);rlMesh.castShadow=true;rlPivot.add(rlMesh);g.add(rlPivot);
            // Arm pivots at shoulder joints
            const aGeo=new THREE.BoxGeometry(0.08,0.35,0.1),aMat=new THREE.MeshLambertMaterial({color:roleInfo.int});
            const laPivot=new THREE.Group();laPivot.position.set(-0.22,0.72,0);
            const laMesh=new THREE.Mesh(aGeo,aMat);laMesh.position.set(0,-0.175,0);laMesh.castShadow=true;laPivot.add(laMesh);g.add(laPivot);
            const raPivot=new THREE.Group();raPivot.position.set(0.22,0.72,0);
            const raMesh=new THREE.Mesh(aGeo,aMat);raMesh.position.set(0,-0.175,0);raMesh.castShadow=true;raPivot.add(raMesh);g.add(raPivot);
            const sh=new THREE.Mesh(new THREE.CircleGeometry(0.18,8),new THREE.MeshBasicMaterial({color:0,transparent:true,opacity:0.15}));sh.rotation.x=-Math.PI/2;sh.position.y=0.02;g.add(sh);
            g.traverse(c=>{if(c.isMesh){c.userData.npcId=npcState.id;c.userData.type='npc';}});
            g.position.set(npcState.x,0,npcState.z);g.rotation.y=npcState.rotation||0;scene.add(g);
            const label=document.createElement('div');label.className='npc-label';label.textContent=npcState.name;label.style.borderBottom='2px solid '+roleInfo.hex;document.getElementById('npc-labels').appendChild(label);
            return{group:g,body,leftLeg:llPivot,rightLeg:rlPivot,leftArm:laPivot,rightArm:raPivot,label,walkPhase:0,walkBlend:0};
        }

        function createMonsterMesh(monsterState){
            // Humanoid monsters (Man, Woman) ‚Äî render as character mesh
            if(monsterState.isHumanoid){
                const skinCol=new THREE.Color(monsterState.skinColor||'#d4a574');
                const hairCol=new THREE.Color(monsterState.hairColor||'#4a3728');
                const shirtColors=[0x4466aa,0x44aa66,0xaa6644,0x886644,0x666699,0x998866];
                const shirtCol=new THREE.Color(shirtColors[Math.abs(monsterState.id.charCodeAt(monsterState.id.length-1))%shirtColors.length]);
                const ch=createCharacterMesh(shirtCol,hairCol);
                // Override skin color on head
                ch.group.children.forEach(c=>{if(c.isMesh&&c.position.y>0.8&&c.position.y<0.95)c.material.color.copy(skinCol);});
                ch.group.traverse(c=>{if(c.isMesh){c.userData.monsterId=monsterState.id;c.userData.type='monster';}});
                ch.group.position.set(monsterState.x,0,monsterState.z);scene.add(ch.group);
                const label=document.createElement('div');label.className='monster-label';label.style.color='#ffff00';label.textContent=monsterState.name+' (Lv.'+monsterState.level+')';document.getElementById('npc-labels').appendChild(label);
                return{group:ch.group,body:ch.body,label,leftLeg:ch.leftLeg,rightLeg:ch.rightLeg,leftArm:ch.leftArm,rightArm:ch.rightArm,walkPhase:ch.walkPhase,walkBlend:ch.walkBlend,isHumanoid:true};
            }
            const isBoss=monsterState.isBoss;
            const scale=isBoss?1.3:0.9;
            const g=new THREE.Group();g.scale.set(scale,scale,scale);
            const bodyColor=parseInt((monsterState.color||'#666666').replace('#',''),16);
            const zone=monsterState.zone||'';
            const mBody=new THREE.Mesh(new THREE.BoxGeometry(0.35,0.55,0.25),new THREE.MeshLambertMaterial({color:bodyColor}));mBody.position.y=0.5;mBody.castShadow=true;g.add(mBody);
            let mHead;
            if(zone.includes('forest')){mHead=new THREE.Mesh(new THREE.SphereGeometry(0.18,6,6),new THREE.MeshLambertMaterial({color:bodyColor}));}
            else if(zone.includes('ruins')){mHead=new THREE.Mesh(new THREE.BoxGeometry(0.28,0.22,0.22),new THREE.MeshLambertMaterial({color:bodyColor}));}
            else{mHead=new THREE.Mesh(new THREE.OctahedronGeometry(0.18,0),new THREE.MeshLambertMaterial({color:bodyColor}));}
            mHead.position.y=0.95;mHead.castShadow=true;g.add(mHead);
            const eyeMat=new THREE.MeshBasicMaterial({color:monsterState.aggressive?0xff0000:0xffaa00});
            const eye1=new THREE.Mesh(new THREE.SphereGeometry(0.04,4,4),eyeMat);eye1.position.set(-0.06,0.95,0.15);g.add(eye1);
            const eye2=new THREE.Mesh(new THREE.SphereGeometry(0.04,4,4),eyeMat);eye2.position.set(0.06,0.95,0.15);g.add(eye2);
            if(isBoss){const glow=new THREE.Mesh(new THREE.SphereGeometry(0.6,8,8),new THREE.MeshBasicMaterial({color:bodyColor,transparent:true,opacity:0.12}));glow.position.y=0.6;g.add(glow);}
            const mShadow=new THREE.Mesh(new THREE.CircleGeometry(0.2,8),new THREE.MeshBasicMaterial({color:0,transparent:true,opacity:0.15}));mShadow.rotation.x=-Math.PI/2;mShadow.position.y=0.02;g.add(mShadow);
            g.traverse(c=>{if(c.isMesh){c.userData.monsterId=monsterState.id;c.userData.type='monster';}});
            g.position.set(monsterState.x,0,monsterState.z);scene.add(g);
            const label=document.createElement('div');label.className='monster-label';label.textContent=monsterState.name+' (Lv.'+monsterState.level+')';document.getElementById('npc-labels').appendChild(label);
            return{group:g,body:mBody,label};
        }

        // ============================================================
        // COLYSEUS CONNECTION
        // ============================================================
        const connStatus=document.getElementById('conn-status');
        async function connect(){
            try{
                connStatus.textContent='Connecting...';connStatus.className='connecting';
                const client=new Colyseus.Client(WS_URL);
                const joinOptions={name:playerName,color:playerColor};
                if(authToken)joinOptions.supabaseToken=authToken;
                if(authTgId)joinOptions.tgId=authTgId;
                if(authEntityType)joinOptions.entityType=authEntityType;
                if(authApiKey)joinOptions.apiKey=authApiKey;
                room=await client.joinOrCreate('agentscape',joinOptions);
                mySessionId=room.sessionId;
                setupRoomListeners();
                connStatus.textContent='Connected';connStatus.className='connected';
                addChat('system','Connected to AgentScape multiplayer!');
            }catch(e){
                connStatus.textContent='Disconnected';connStatus.className='disconnected';
                addChat('system','Could not connect to server. Retrying in 5s...');
                console.error('Connection failed:',e);
                setTimeout(connect,5000);
            }
        }

        function sendAction(type,payload){if(room)room.send('action',{type,payload:payload||{}});}

        // ============================================================
        // RESOURCE NODES ‚Äî 3D meshes + state
        // ============================================================
        const resourceNodes = new Map(); // nodeId -> {mesh, label, defId, x, z, depleted}
        const resourceDefs = new Map();  // defId -> {name, icon, skill, levelReq}
        let bankContents = [];           // current bank items from server

        function createNodeMesh(node) {
            const def = resourceDefs.get(node.defId);
            const skill = def ? def.skill : 'woodcutting';
            const group = new THREE.Group();
            const h = heightMap ? (heightMap[node.x] ? heightMap[node.x][node.z] || 0 : 0) : 0;

            if (skill === 'woodcutting') {
                // Tree: trunk + foliage
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.12, 0.8, 6), new THREE.MeshLambertMaterial({color: 0x8B6914}));
                trunk.position.y = 0.4;
                const foliage = new THREE.Mesh(new THREE.SphereGeometry(0.4, 6, 5), new THREE.MeshLambertMaterial({color: 0x228B22}));
                foliage.position.y = 0.9;
                group.add(trunk, foliage);
            } else if (skill === 'mining') {
                // Rock: angular box
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(0.35, 0), new THREE.MeshLambertMaterial({color: 0x808080}));
                rock.position.y = 0.25;
                const ore = new THREE.Mesh(new THREE.SphereGeometry(0.1, 4, 3), new THREE.MeshLambertMaterial({color: 0xCD853F}));
                ore.position.set(0.15, 0.35, 0.1);
                group.add(rock, ore);
            } else if (skill === 'fishing') {
                // Fishing spot: flat circle with ripple
                const water = new THREE.Mesh(new THREE.CircleGeometry(0.4, 8), new THREE.MeshLambertMaterial({color: 0x2288CC, transparent: true, opacity: 0.7}));
                water.rotation.x = -Math.PI / 2;
                water.position.y = 0.05;
                const bobber = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 4), new THREE.MeshLambertMaterial({color: 0xFF4444}));
                bobber.position.y = 0.12;
                group.add(water, bobber);
            }

            group.position.set(node.x, h, node.z);
            group.userData = {type: 'resource_node', nodeId: node.id};
            scene.add(group);

            // Label
            const label = document.createElement('div');
            label.className = 'node-label';
            label.textContent = def ? def.name : node.defId;
            document.getElementById('npc-labels').appendChild(label);

            const entry = {mesh: group, label, defId: node.defId, x: node.x, z: node.z, depleted: node.depleted};
            if (node.depleted) setNodeDepleted(entry, true);
            resourceNodes.set(node.id, entry);
            return entry;
        }

        function setNodeDepleted(entry, depleted) {
            entry.depleted = depleted;
            entry.mesh.visible = !depleted;
            entry.label.classList.toggle('depleted', depleted);
            if (depleted) entry.label.style.display = 'none';
            else entry.label.style.display = '';
        }

        // ============================================================
        // BANK UI
        // ============================================================
        function openBank() {
            sendAction('bank_open');
        }

        function renderBankUI() {
            const p = getMyPlayer();
            const el = document.getElementById('bank-body-content');
            let html = '<div style="font-size:10px;color:#6b7280;padding:4px;">Bank (' + bankContents.length + '/100 slots)</div>';
            html += '<div class="bank-grid">';
            for (let i = 0; i < 100; i++) {
                const item = bankContents[i];
                if (item && item.id) {
                    const def = ITEMS[item.id];
                    const icon = def ? def.icon : '\u2753';
                    html += '<div class="bank-slot" onclick="withdrawBank(' + i + ')" title="' + item.name + '">' + icon;
                    if (item.quantity > 1) html += '<span class="bank-slot-qty">' + item.quantity + '</span>';
                    html += '</div>';
                } else if (i < 20) {
                    html += '<div class="bank-slot"></div>'; // show first 20 empty slots
                }
            }
            html += '</div>';
            // Deposit buttons
            html += '<div class="bank-actions">';
            html += '<button class="bank-btn" onclick="sendAction(\'bank_deposit_all\')">Deposit All</button>';
            html += '<button class="bank-btn" onclick="sendAction(\'bank_stock_all\')" style="background:#6366f1;">Stock All Items</button>';
            html += '</div>';
            // Inventory strip for depositing
            if (p) {
                html += '<div style="font-size:10px;color:#6b7280;padding:4px;">Click item to deposit:</div>';
                html += '<div class="bank-inv-row">';
                for (let i = 0; i < 28; i++) {
                    const item = p.inventory[i];
                    if (item && item.id) {
                        const def = ITEMS[item.id];
                        html += '<div class="bank-inv-slot" onclick="depositBank(' + i + ')" title="' + item.name + '">' + (def ? def.icon : item.icon) + '</div>';
                    }
                }
                html += '</div>';
            }
            el.innerHTML = html;
            document.getElementById('bank-overlay').classList.add('open');
        }

        window.withdrawBank = function(slot) {
            sendAction('bank_withdraw', {bankSlot: slot, quantity: 1});
        };
        window.depositBank = function(slot) {
            sendAction('bank_deposit', {inventorySlot: slot, quantity: 1});
        };

        // ============================================================
        // COOKING UI
        // ============================================================
        let cookingRecipes = [
            {id:'cook_raw_fish', name:'Cooked Fish', icon:'\u{1F420}', input:'raw_fish', inputName:'Raw Fish', inputIcon:'\u{1F41F}', levelReq:1},
            {id:'cook_bread', name:'Bread', icon:'\u{1F35E}', input:'logs', inputName:'Logs', inputIcon:'\u{1FAB5}', levelReq:1},
            {id:'cook_meat', name:'Cooked Meat', icon:'\u{1F356}', input:'bones', inputName:'Bones', inputIcon:'\u{1F9B4}', levelReq:5},
            {id:'cook_lobster', name:'Lobster', icon:'\u{1F99E}', input:'raw_fish', inputName:'Raw Fish x3', inputIcon:'\u{1F41F}', levelReq:15},
            {id:'cook_shark', name:'Shark', icon:'\u{1F988}', input:'raw_fish', inputName:'Raw Fish x5', inputIcon:'\u{1F41F}', levelReq:30},
            {id:'brew_attack_potion', name:'Attack Potion', icon:'\u2697\uFE0F', input:'herbs', inputName:'Code Fragment + Corrupted Byte', inputIcon:'\u{1F48E}', levelReq:10},
            {id:'brew_strength_potion', name:'Strength Potion', icon:'\u2697\uFE0F', input:'herbs', inputName:'Code Fragment + Broken Link', inputIcon:'\u{1F48E}', levelReq:15},
            {id:'brew_defence_potion', name:'Defence Potion', icon:'\u2697\uFE0F', input:'herbs', inputName:'Code Fragment + Memory Shard', inputIcon:'\u{1F48E}', levelReq:20},
        ];

        function openCooking() {
            const el = document.getElementById('cook-content');
            el.innerHTML = cookingRecipes.map(r => {
                return '<div class="shop-item" onclick="sendAction(\'cook_item\',{recipeId:\'' + r.id + '\'})">' +
                    '<span class="shop-item-icon">' + r.icon + '</span>' +
                    '<span class="shop-item-name">' + r.name + '</span>' +
                    '<span style="font-size:9px;color:#9ca3af;">Lv.' + r.levelReq + ' \u2022 ' + r.inputName + '</span>' +
                    '</div>';
            }).join('');
            document.getElementById('cook-overlay').classList.add('open');
        }

        // Run orb click handlers
        document.getElementById('run-orb').addEventListener('click',e=>{
            e.preventDefault();e.stopPropagation();
            sendAction('toggle_run');
        });
        document.getElementById('run-orb').addEventListener('contextmenu',e=>{
            e.preventDefault();e.stopPropagation();
            sendAction('toggle_rest');
        });

        function setupRoomListeners(){
            // === PLAYERS ===
            room.state.players.onAdd((player,sessionId)=>{
                if(sessionId===mySessionId){
                    document.querySelector('.stat-player-name').textContent=player.name;
                    updateOrbs(player);
                    renderInventoryFromState(player);
                    renderStatsFromState(player);
                    let lastWeaponId = player.equippedWeapon?.id || null;
                    let lastHelmId = player.equippedHelm?.id || null;
                    let lastShieldId = player.equippedShield?.id || null;
                    let lastCoins = player.coins || 0;
                    player.onChange(()=>{
                        updateOrbs(player);renderStatsFromState(player);
                        // Detect equipment or coin changes ‚Üí re-render inventory
                        const curW = player.equippedWeapon?.id || null;
                        const curH = player.equippedHelm?.id || null;
                        const curS = player.equippedShield?.id || null;
                        const curCoins = player.coins || 0;
                        const equipChanged = curW !== lastWeaponId || curH !== lastHelmId || curS !== lastShieldId;
                        const coinsChanged = curCoins !== lastCoins;
                        if (equipChanged || coinsChanged) {
                            lastWeaponId = curW; lastHelmId = curH; lastShieldId = curS; lastCoins = curCoins;
                            renderInventoryFromState(player);
                            if (equipChanged) updateAllEquipment(myChar, player);
                        }
                        myWorldX=player.x;myWorldZ=player.z;
                        const tx=player.tileX,tz=player.tileZ;
                        const h=heightMap[tx]?heightMap[tx][tz]||0:0;
                        const oldX=myTargetX,oldZ=myTargetZ;
                        myTargetX=player.x;myTargetZ=player.z;myTargetH=h;myTargetRot=player.rotation;
                        myIsMoving=(player.state==='walking');
                        myIsResting=player.isResting;
                        if(player.isDead){playCharAnim(myChar,'death');document.getElementById('death-screen').style.display='flex';}
                        else{document.getElementById('death-screen').style.display='none';}
                        // Update zone indicator
                        const zone=getZoneAt(player.tileX,player.tileZ);
                        const zi=document.getElementById('zone-indicator');
                        if(zone){zi.textContent=zone.name;zi.style.borderBottom='2px solid '+zone.color;}
                        else{zi.textContent='The Wilderness';zi.style.borderBottom='2px solid #9ca3af';}
                        const curZoneId=zone?zone.id:'wilderness';
                        if(curZoneId!==lastZoneId){lastZoneId=curZoneId;showZoneBanner(zone);}
                    });
                    player.inventory.onAdd(()=>{renderInventoryFromState(player);});
                    player.inventory.onChange(()=>{renderInventoryFromState(player);});
                    if(player.equippedWeapon)player.equippedWeapon.onChange(()=>{renderInventoryFromState(player);updateAllEquipment(myChar,player);});
                    if(player.equippedHelm)player.equippedHelm.onChange(()=>{renderInventoryFromState(player);updateAllEquipment(myChar,player);});
                    if(player.equippedShield)player.equippedShield.onChange(()=>{renderInventoryFromState(player);updateAllEquipment(myChar,player);});
                    // Load initial equipment models
                    updateAllEquipment(myChar, player);
                }else{
                    const mesh=createCharacterMesh(parseInt(player.color.replace('#',''),16)||0x3355aa);
                    mesh.group.position.set(player.x,0,player.z);scene.add(mesh.group);
                    const label=document.createElement('div');label.className='npc-label';label.textContent=player.name;label.style.borderBottom='2px solid '+player.color;document.getElementById('npc-labels').appendChild(label);
                    otherPlayerMeshes.set(sessionId,{...mesh,label,state:player,targetX:player.x,targetZ:player.z,targetH:0,targetRot:player.rotation,isMoving:false,isResting:false});
                    updateAllEquipment(mesh, player);
                    player.onChange(()=>{
                        const m=otherPlayerMeshes.get(sessionId);if(!m)return;
                        const tx=player.tileX,tz=player.tileZ;const h=heightMap[tx]?heightMap[tx][tz]||0:0;
                        m.isMoving=(player.state==='walking');
                        m.targetX=player.x;m.targetZ=player.z;m.targetH=h;m.targetRot=player.rotation;m.group.visible=!player.isDead;m.isResting=player.isResting;
                        updateAllEquipment(m, player);
                    });
                }
            });
            room.state.players.onRemove((player,sessionId)=>{
                const m=otherPlayerMeshes.get(sessionId);if(m){scene.remove(m.group);m.label.remove();otherPlayerMeshes.delete(sessionId);}
            });

            // === NPCs ===
            room.state.npcs.onAdd((npc,id)=>{
                const mesh=createNPCMesh(npc);
                npcMeshes.set(id,{...mesh,state:npc,targetX:npc.x,targetZ:npc.z,targetH:0,targetRot:npc.rotation,isMoving:false});
                npc.onChange(()=>{
                    const m=npcMeshes.get(id);if(!m)return;
                    const tx=npc.tileX,tz=npc.tileZ;const h=heightMap[tx]?heightMap[tx][tz]||0:0;
                    m.isMoving=(npc.state==='WALKING');
                    m.targetX=npc.x;m.targetZ=npc.z;m.targetH=h;m.targetRot=npc.rotation;
                    m.group.visible=!npc.isDead;m.label.style.display=npc.isDead?'none':'block';
                });
            });
            room.state.npcs.onRemove((npc,id)=>{const m=npcMeshes.get(id);if(m){scene.remove(m.group);m.label.remove();npcMeshes.delete(id);}});

            // === MONSTERS ===
            if(room.state.monsters){
            room.state.monsters.onAdd((monster,id)=>{
                const mesh=createMonsterMesh(monster);
                monsterMeshes.set(id,{...mesh,state:monster,targetX:monster.x,targetZ:monster.z,targetH:0,targetRot:monster.rotation,isMoving:false});
                monster.onChange(()=>{
                    const m=monsterMeshes.get(id);if(!m)return;
                    const tx=monster.tileX,tz=monster.tileZ;const h=heightMap[tx]?heightMap[tx][tz]||0:0;
                    m.isMoving=(monster.state==='PATROL'||monster.state==='CHASING'||monster.state==='LEASHING');
                    m.targetX=monster.x;m.targetZ=monster.z;m.targetH=h;m.targetRot=monster.rotation;
                    m.group.visible=!monster.isDead;m.label.style.display=monster.isDead?'none':'block';
                });
            });
            room.state.monsters.onRemove((monster,id)=>{const m=monsterMeshes.get(id);if(m){scene.remove(m.group);m.label.remove();monsterMeshes.delete(id);}});
            }

            // === LOOT PILES ===
            if(room.state.lootPiles){
            room.state.lootPiles.onAdd((loot,id)=>{
                const dot=document.createElement('div');dot.className='loot-pile-dot';dot.dataset.worldX=loot.x;dot.dataset.worldZ=loot.z;
                dot.onclick=()=>{sendAction('pickup_loot',{lootId:id});playCharAnim(myChar,'pickup_loot');};
                document.getElementById('npc-labels').appendChild(dot);
                lootPileMeshes.set(id,{dot,state:loot});
            });
            room.state.lootPiles.onRemove((loot,id)=>{const m=lootPileMeshes.get(id);if(m){m.dot.remove();lootPileMeshes.delete(id);}});
            }

            // === SERVER MESSAGES ===
            room.onMessage('hitsplat',(data)=>{showHitsplat(data.x,data.z,data.damage,data.isMiss,data.isSpec);});
            room.onMessage('player_chat',(data)=>{addChat('public',data.message,data.sender,data.color);showChatBubble(data.x,data.z,data.message,data.color);});
            room.onMessage('npc_chat',(data)=>{addChat('agent',data.message,data.npcName,data.roleColor);showChatBubble(data.x,data.z,data.message,'#22c55e');});
            room.onMessage('system_message',(data)=>{addChat('system',data.message);});
            room.onMessage('error',(data)=>{addChat('system',data.message);});
            room.onMessage('death',(data)=>{if(data.entityType==='npc')addChat('combat','An agent has been defeated!');if(data.entityType==='monster')addChat('combat',data.monsterName+' has been slain!');if(data.entityType==='player'&&data.entityId===mySessionId)addChat('combat','Oh dear, you are dead!');});
            room.onMessage('level_up',(data)=>{addChat('system','Level up! '+data.skill+' is now level '+data.level+'!');playCharAnim(myChar,'level_up');const el=document.getElementById('skill-'+data.skill);if(el){el.classList.add('skill-levelup');setTimeout(()=>el.classList.remove('skill-levelup'),1500);}});
            room.onMessage('quest_event',(data)=>{if(data.type==='completed')addChat('system','Quest complete: '+data.questName+'!');if(data.type==='accepted')addChat('system','Quest accepted: '+data.questName);});
            room.onMessage('building_arrived',(data)=>{
                const bid=data.buildingId;
                document.getElementById('skill-action-area').innerHTML='';
                if(bid==='quest_board'){renderQuestBoard();document.getElementById('quest-overlay').classList.add('open');}
                else if(bid==='general_store'||bid==='exchange'){openShop();}
                else if(bid==='workshop'||bid==='forge'){openCrafting();}
                else if(bid==='bank'){openBank();addChat('system','You arrive at the SUITE Bank.');}
                else if(bid==='tavern'){openCooking();addChat('system','You arrive at the Tavern.');}
                else if(bid==='farm'){document.getElementById('skill-action-area').innerHTML='<button class="action-btn" onclick="sendAction(\'start_harvest\')">Harvest</button>';addChat('system','You arrive at the Farm.');}
                else if(bid==='arena'){document.getElementById('skill-action-area').innerHTML='<button class="action-btn" onclick="sendAction(\'start_training\')">Train</button>';addChat('system','You enter the Arena.');}
                else{const bd=BUILDINGS.find(b=>b.id===bid);addChat('system','You arrive at the '+(bd?bd.name:'building')+'.');}
            });
            room.onMessage('pickpocket_result',(data)=>{playCharAnim(myChar,'pickpocket');});
            room.onMessage('play_anim',(data)=>{
                let mesh=null;
                if(data.entityType==='player'){if(data.entityId===mySessionId)mesh=myChar;else mesh=otherPlayerMeshes.get(data.entityId);}
                else if(data.entityType==='npc')mesh=npcMeshes.get(data.entityId);
                else if(data.entityType==='monster')mesh=monsterMeshes.get(data.entityId);
                if(mesh)playCharAnim(mesh,data.animId);
            });
            room.onMessage('skilling_event',(data)=>{
                addChat('system',data.message);
                if(data.message&&(data.message.includes('You start')||data.message.includes('You swing')||data.message.includes('You cast')))playCharAnim(myChar,'gather');
            });
            room.onMessage('monster_ability',(data)=>{addChat('combat',data.monsterName+' uses '+data.abilityName+'!');});
            room.onMessage('player_respawn',(data)=>{if(data.playerId===mySessionId)addChat('system','You have respawned.');});
            room.onMessage('welcome',(data)=>{addChat('system','Welcome to AgentScape! Right-click to interact.');});

            // === RESOURCE NODES ===
            room.onMessage('resource_nodes',(nodes)=>{
                nodes.forEach(n=>createNodeMesh(n));
            });
            room.onMessage('resource_defs',(defs)=>{
                defs.forEach(d=>resourceDefs.set(d.id,d));
            });
            room.onMessage('node_update',(data)=>{
                const node=resourceNodes.get(data.nodeId);
                if(node)setNodeDepleted(node,data.depleted);
            });

            // === BANK ===
            room.onMessage('bank_contents',(data)=>{
                bankContents=data;
                renderBankUI();
            });
            room.onMessage('bank_update',(data)=>{
                bankContents=data;
                if(document.getElementById('bank-overlay').classList.contains('open'))renderBankUI();
            });

            // === SELL PRICE ===
            room.onMessage('sell_price',(data)=>{
                const item=ITEMS[data.itemId];
                addChat('system',(item?item.name:data.itemId)+' sells for '+data.price+' coins.');
            });
            room.onLeave(()=>{connStatus.textContent='Disconnected';connStatus.className='disconnected';addChat('system','Disconnected from server.');});
        }
        // ============================================================
        // UI RENDERING (from Colyseus state)
        // ============================================================
        function updateOrbs(p){
            if(!p)return;
            const hpPct=Math.max(0,(p.hp/p.maxHp)*100);
            document.getElementById('orbHp').style.setProperty('--hp-pct',hpPct+'%');
            document.getElementById('orbHpText').textContent=Math.max(0,p.hp);
            document.getElementById('orbCombatText').textContent=p.combatLevel;
            document.getElementById('orbEnergy').style.setProperty('--energy-pct',p.energy+'%');
            document.getElementById('orbEnergyText').textContent=p.energy;
            // Run energy orb
            const runOrb=document.getElementById('run-orb');
            if(p.runEnergy!==undefined){
                runOrb.style.setProperty('--run-pct',p.runEnergy+'%');
                runOrb.classList.toggle('active',p.isRunning);
                runOrb.classList.toggle('resting',p.isResting);
                document.getElementById('run-orb-icon').textContent=p.isResting?'üí§':p.isRunning?'üèÉ':'üö∂';
            }
        }

        function renderInventoryFromState(p){
            if(!p)return;
            const grid2=document.getElementById('inv-grid');grid2.innerHTML='';
            for(let i=0;i<28;i++){
                const slot=document.createElement('div');
                slot.className='inv-slot';
                slot.dataset.slot=i;
                const item=p.inventory[i];
                if(item&&item.id){
                    const forgeImg = forgeImageCache[item.id];
                    if (forgeImg) {
                        const img = document.createElement('img');
                        img.src = forgeImg;
                        img.style.cssText = 'width:100%;height:100%;object-fit:contain;image-rendering:pixelated;';
                        slot.appendChild(img);
                    } else {
                        slot.textContent=item.icon||'?';
                    }
                    if(item.quantity>1){const qty=document.createElement('span');qty.className='inv-slot-qty';qty.textContent=item.quantity;slot.appendChild(qty);}
                }
                slot.addEventListener('contextmenu',(e)=>{e.preventDefault();e.stopPropagation();showInventoryMenu(e,i,p);});
                slot.addEventListener('click',()=>{if(!item||!item.id)return;if(item.type==='food'){sendAction('eat_food',{inventorySlot:i});playCharAnim(myChar,'eat');}else if(item.type==='weapon'||item.type==='helm'||item.type==='shield'||item.type==='axe')sendAction('equip_item',{inventorySlot:i});});
                grid2.appendChild(slot);
            }
            renderEquipFromState(p);
        }

        function renderEquipFromState(p){
            if(!p)return;
            const panel=document.getElementById('equip-panel');if(!panel)return;
            const weapon=p.equippedWeapon&&p.equippedWeapon.id?p.equippedWeapon:null;
            const helm=p.equippedHelm&&p.equippedHelm.id?p.equippedHelm:null;
            const shield=p.equippedShield&&p.equippedShield.id?p.equippedShield:null;
            let atkBonus=0,strBonus=0,defBonus=0;
            [weapon,helm,shield].forEach(item=>{if(item&&item.id){atkBonus+=item.attackStat||0;strBonus+=item.strengthStat||0;defBonus+=item.defenceStat||0;}});
            function slotHTML(label,item,slotType,top,left){
                const hasItem=item&&item.id;
                const forgeImg = hasItem ? forgeImageCache[item.id] : null;
                const iconContent = forgeImg
                    ? '<img src="'+forgeImg+'" style="width:100%;height:100%;object-fit:contain;image-rendering:pixelated;">'
                    : (hasItem?(item.icon||'?'):'');
                const name=hasItem?item.name:'Empty';
                const cls='equip-slot'+(hasItem?' has-item':'');
                const click=hasItem?'onclick="handleUnequip(\''+slotType+'\')"':'';
                return '<div style="position:absolute;top:'+top+'px;left:'+left+'px;text-align:center;">'+
                    '<div class="equip-slot-label" style="top:-12px;left:0;width:42px;text-align:center;">'+label+'</div>'+
                    '<div class="'+cls+'" '+click+'>'+iconContent+'</div>'+
                    '<div class="equip-slot-name">'+name+'</div></div>';
            }
            panel.innerHTML=
                '<div class="equip-title">Equipment</div>'+
                '<div class="equip-grid">'+
                    '<div class="equip-silhouette"></div>'+
                    slotHTML('Helm',helm,'helm',0,69)+
                    slotHTML('Weapon',weapon,'weapon',75,10)+
                    slotHTML('Shield',shield,'shield',75,128)+
                    '<div style="position:absolute;top:80px;left:69px;width:42px;height:52px;border:1px solid #2a2a2e;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:24px;color:#2a2a2e;">&#x1F464;</div>'+
                '</div>'+
                '<div class="equip-stats">'+
                    '<div class="equip-stat-row"><span>Attack bonus</span><b class="'+(atkBonus>0?'positive':'')+'">+'+(atkBonus)+'</b></div>'+
                    '<div class="equip-stat-row"><span>Strength bonus</span><b class="'+(strBonus>0?'positive':'')+'">+'+(strBonus)+'</b></div>'+
                    '<div class="equip-stat-row"><span>Defence bonus</span><b class="'+(defBonus>0?'positive':'')+'">+'+(defBonus)+'</b></div>'+
                '</div>';
            // Sync 3D equipment models ‚Äî direct synchronous removal for unequipped slots
            const equipState = {
                weapon: weapon ? weapon.id : null,
                helm: helm ? helm.id : null,
                shield: shield ? shield.id : null
            };
            ['weapon', 'helm', 'shield'].forEach(slot => {
                if (!equipState[slot] && myChar.equipMeshes[slot]) {
                    // UNEQUIPPED: immediately remove 3D model from scene
                    const old = myChar.equipMeshes[slot];
                    if (old.parent) old.parent.remove(old);
                    else myChar.group.remove(old); // fallback
                    delete myChar.equipMeshes[slot];
                } else if (equipState[slot] && !myChar.equipMeshes[slot]) {
                    // EQUIPPED: load 3D model (async is fine for adding)
                    attachEquipModel(myChar, slot, equipState[slot]);
                }
            });
        }

        // Skill guide milestones ‚Äî what unlocks at each level
        const SKILL_GUIDE={
            attack:[{lvl:1,name:'Bronze weapons',icon:'\u{1F5E1}\uFE0F'},{lvl:5,name:'Iron weapons',icon:'\u2694\uFE0F'},{lvl:10,name:'Steel weapons',icon:'\u2694\uFE0F'},{lvl:20,name:'Mithril weapons',icon:'\u{1F5E1}\uFE0F'},{lvl:30,name:'Adamant weapons',icon:'\u2694\uFE0F'},{lvl:40,name:'Rune weapons',icon:'\u2694\uFE0F'},{lvl:60,name:'Dragon weapons',icon:'\u2694\uFE0F'}],
            strength:[{lvl:1,name:'Basic damage bonus',icon:'\u{1F4AA}'},{lvl:10,name:'Improved max hit',icon:'\u{1F4AA}'},{lvl:20,name:'Strong blows',icon:'\u{1F4A5}'},{lvl:40,name:'Powerful strikes',icon:'\u{1F4A5}'},{lvl:60,name:'Devastating hits',icon:'\u{1F525}'},{lvl:99,name:'Max strength',icon:'\u{1F31F}'}],
            defence:[{lvl:1,name:'Bronze armour',icon:'\u{1F6E1}\uFE0F'},{lvl:5,name:'Iron armour',icon:'\u{1F6E1}\uFE0F'},{lvl:10,name:'Steel armour',icon:'\u26D1\uFE0F'},{lvl:20,name:'Mithril armour',icon:'\u{1FA96}'},{lvl:30,name:'Adamant armour',icon:'\u{1F6E1}\uFE0F'},{lvl:40,name:'Rune armour',icon:'\u26D1\uFE0F'},{lvl:60,name:'Dragon armour',icon:'\u26D1\uFE0F'}],
            hitpoints:[{lvl:10,name:'Start with 100 HP',icon:'\u2764\uFE0F'},{lvl:20,name:'200 HP',icon:'\u2764\uFE0F'},{lvl:40,name:'400 HP',icon:'\u2764\uFE0F'},{lvl:60,name:'600 HP',icon:'\u2764\uFE0F'},{lvl:80,name:'800 HP',icon:'\u2764\uFE0F'},{lvl:99,name:'Max HP',icon:'\u{1F31F}'}],
            prayer:[{lvl:1,name:'Bury bones (+4 XP)',icon:'\u{1F9B4}'},{lvl:10,name:'Improved prayers',icon:'\u2728'},{lvl:30,name:'Protection prayers',icon:'\u{1F6E1}\uFE0F'},{lvl:45,name:'Combat prayers',icon:'\u2694\uFE0F'},{lvl:70,name:'Piety',icon:'\u{1F31F}'},{lvl:99,name:'Max prayer',icon:'\u{1F31F}'}],
            thieving:[{lvl:1,name:'Pickpocket men & women',icon:'\u{1F90F}'},{lvl:10,name:'Improved success rate',icon:'\u{1F44D}'},{lvl:20,name:'Pickpocket warriors',icon:'\u{1F90F}'},{lvl:40,name:'Pickpocket guards',icon:'\u{1F90F}'},{lvl:50,name:'Steal from stalls',icon:'\u{1F6D2}'},{lvl:70,name:'Pickpocket heroes',icon:'\u{1F90F}'},{lvl:99,name:'Master thief',icon:'\u{1F31F}'}],
            woodcutting:[{lvl:1,name:'Cut normal trees',icon:'\u{1FA93}'},{lvl:15,name:'Cut oak trees',icon:'\u{1F333}'},{lvl:30,name:'Cut willow trees',icon:'\u{1F333}'},{lvl:45,name:'Cut maple trees',icon:'\u{1F341}'},{lvl:60,name:'Cut yew trees',icon:'\u{1F332}'},{lvl:75,name:'Cut magic trees',icon:'\u{1F31F}'}],
            mining:[{lvl:1,name:'Mine copper & tin',icon:'\u26CF\uFE0F'},{lvl:15,name:'Mine iron',icon:'\u26CF\uFE0F'},{lvl:30,name:'Mine coal',icon:'\u26CF\uFE0F'},{lvl:40,name:'Mine gold',icon:'\u{1FA99}'},{lvl:55,name:'Mine mithril',icon:'\u26CF\uFE0F'},{lvl:70,name:'Mine adamantite',icon:'\u26CF\uFE0F'},{lvl:85,name:'Mine runite',icon:'\u{1F31F}'}],
            fishing:[{lvl:1,name:'Catch shrimp',icon:'\u{1F990}'},{lvl:15,name:'Catch trout',icon:'\u{1F41F}'},{lvl:30,name:'Catch lobster',icon:'\u{1F99E}'},{lvl:40,name:'Catch swordfish',icon:'\u{1F41F}'},{lvl:62,name:'Catch monkfish',icon:'\u{1F420}'},{lvl:76,name:'Catch shark',icon:'\u{1F988}'},{lvl:81,name:'Catch manta ray',icon:'\u{1F420}'}],
            cooking:[{lvl:1,name:'Cook shrimp',icon:'\u{1F373}'},{lvl:15,name:'Cook trout',icon:'\u{1F373}'},{lvl:30,name:'Cook lobster',icon:'\u{1F373}'},{lvl:45,name:'Cook swordfish',icon:'\u{1F373}'},{lvl:62,name:'Cook monkfish',icon:'\u{1F373}'},{lvl:80,name:'Cook shark',icon:'\u{1F373}'}],
            smithing:[{lvl:1,name:'Smelt bronze',icon:'\u{1F528}'},{lvl:15,name:'Smelt iron',icon:'\u{1F528}'},{lvl:30,name:'Smelt steel',icon:'\u{1F528}'},{lvl:50,name:'Smelt mithril',icon:'\u{1F528}'},{lvl:70,name:'Smelt adamant',icon:'\u{1F528}'},{lvl:85,name:'Smelt rune',icon:'\u{1F31F}'}],
            crafting:[{lvl:1,name:'Leather goods',icon:'\u2702\uFE0F'},{lvl:20,name:'Gold jewellery',icon:'\u{1F48D}'},{lvl:40,name:'Silver items',icon:'\u2702\uFE0F'},{lvl:55,name:'Dragonhide bodies',icon:'\u2702\uFE0F'},{lvl:99,name:'Master crafter',icon:'\u{1F31F}'}],
            agility:[{lvl:1,name:'Run energy regen',icon:'\u{1F3C3}'},{lvl:10,name:'Gnome course',icon:'\u{1F3C3}'},{lvl:20,name:'Barbarian course',icon:'\u{1F3C3}'},{lvl:40,name:'Canifis course',icon:'\u{1F3C3}'},{lvl:60,name:'Seers course',icon:'\u{1F3C3}'},{lvl:80,name:'Rellekka course',icon:'\u{1F3C3}'}],
            firemaking:[{lvl:1,name:'Burn normal logs',icon:'\u{1F525}'},{lvl:15,name:'Burn oak logs',icon:'\u{1F525}'},{lvl:30,name:'Burn willow logs',icon:'\u{1F525}'},{lvl:45,name:'Burn maple logs',icon:'\u{1F525}'},{lvl:60,name:'Burn yew logs',icon:'\u{1F525}'},{lvl:75,name:'Burn magic logs',icon:'\u{1F525}'}],
            fletching:[{lvl:1,name:'Arrow shafts',icon:'\u{1FAB6}'},{lvl:10,name:'Oak bows',icon:'\u{1F3F9}'},{lvl:25,name:'Willow bows',icon:'\u{1F3F9}'},{lvl:40,name:'Maple bows',icon:'\u{1F3F9}'},{lvl:55,name:'Yew bows',icon:'\u{1F3F9}'},{lvl:70,name:'Magic bows',icon:'\u{1F3F9}'}],
            herblore:[{lvl:3,name:'Attack potion',icon:'\u{1F9EA}'},{lvl:12,name:'Strength potion',icon:'\u{1F9EA}'},{lvl:22,name:'Energy potion',icon:'\u{1F9EA}'},{lvl:38,name:'Prayer potion',icon:'\u{1F9EA}'},{lvl:55,name:'Super attack',icon:'\u{1F9EA}'},{lvl:72,name:'Ranging potion',icon:'\u{1F9EA}'}],
            ranged:[{lvl:1,name:'Bronze arrows',icon:'\u{1F3F9}'},{lvl:10,name:'Iron arrows',icon:'\u{1F3F9}'},{lvl:20,name:'Steel arrows',icon:'\u{1F3F9}'},{lvl:40,name:'Rune arrows',icon:'\u{1F3F9}'},{lvl:61,name:'Dragon arrows',icon:'\u{1F3F9}'}],
            magic:[{lvl:1,name:'Wind Strike',icon:'\u{1F52E}'},{lvl:9,name:'Earth Strike',icon:'\u{1F52E}'},{lvl:17,name:'Fire Strike',icon:'\u{1F525}'},{lvl:35,name:'Fire Bolt',icon:'\u{1F525}'},{lvl:59,name:'Fire Blast',icon:'\u{1F525}'},{lvl:75,name:'Fire Wave',icon:'\u{1F525}'}],
            slayer:[{lvl:1,name:'Basic assignments',icon:'\u{1F480}'},{lvl:15,name:'Banshees',icon:'\u{1F480}'},{lvl:45,name:'Gargoyles',icon:'\u{1F480}'},{lvl:65,name:'Dust devils',icon:'\u{1F480}'},{lvl:85,name:'Abyssal demons',icon:'\u{1F480}'}],
            farming:[{lvl:1,name:'Plant potatoes',icon:'\u{1F331}'},{lvl:14,name:'Plant tomatoes',icon:'\u{1F345}'},{lvl:31,name:'Plant strawberries',icon:'\u{1F353}'},{lvl:47,name:'Plant watermelons',icon:'\u{1F349}'},{lvl:62,name:'Plant herbs',icon:'\u{1F33F}'}],
            hunter:[{lvl:1,name:'Set traps',icon:'\u{1FAA4}'},{lvl:15,name:'Deadfall traps',icon:'\u{1FAA4}'},{lvl:29,name:'Swamp lizards',icon:'\u{1F98E}'},{lvl:53,name:'Chinchompas',icon:'\u{1F439}'},{lvl:73,name:'Black chins',icon:'\u{1F439}'}],
            construction:[{lvl:1,name:'Crude chair',icon:'\u{1FA91}'},{lvl:20,name:'Oak furniture',icon:'\u{1F6CB}\uFE0F'},{lvl:40,name:'Teak furniture',icon:'\u{1F6CB}\uFE0F'},{lvl:60,name:'Mahogany furniture',icon:'\u{1F6CB}\uFE0F'},{lvl:80,name:'Gilded items',icon:'\u{1F31F}'}],
            runecraft:[{lvl:1,name:'Air runes',icon:'\u{1F537}'},{lvl:14,name:'Fire runes',icon:'\u{1F525}'},{lvl:27,name:'Cosmic runes',icon:'\u2728'},{lvl:44,name:'Nature runes',icon:'\u{1F33F}'},{lvl:65,name:'Death runes',icon:'\u{1F480}'},{lvl:77,name:'Blood runes',icon:'\u{1FA78}'}],
            archaeology:[{lvl:1,name:'Basic excavation',icon:'\u{1F3FA}'},{lvl:20,name:'Ancient relics',icon:'\u{1F3FA}'},{lvl:40,name:'Artefact restoration',icon:'\u{1F3FA}'},{lvl:60,name:'Rare finds',icon:'\u{1F3FA}'},{lvl:80,name:'Master archaeologist',icon:'\u{1F31F}'}],
            dungeoneering:[{lvl:1,name:'Floor 1-10',icon:'\u{1F6AA}'},{lvl:20,name:'Floor 11-20',icon:'\u{1F6AA}'},{lvl:40,name:'Floor 21-30',icon:'\u{1F6AA}'},{lvl:60,name:'Floor 31-40',icon:'\u{1F6AA}'},{lvl:80,name:'Floor 41-50',icon:'\u{1F6AA}'}],
            coding:[{lvl:1,name:'Hello World',icon:'\u{1F4BB}'},{lvl:10,name:'Variables & loops',icon:'\u{1F4BB}'},{lvl:25,name:'Functions',icon:'\u{1F4BB}'},{lvl:40,name:'APIs',icon:'\u{1F310}'},{lvl:60,name:'Full-stack apps',icon:'\u{1F4BB}'},{lvl:80,name:'System architecture',icon:'\u{1F3D7}\uFE0F'}],
            hacking:[{lvl:1,name:'Port scanning',icon:'\u{1F513}'},{lvl:15,name:'SQL injection',icon:'\u{1F513}'},{lvl:30,name:'XSS attacks',icon:'\u{1F513}'},{lvl:50,name:'Buffer overflow',icon:'\u{1F513}'},{lvl:70,name:'Zero-day exploits',icon:'\u{1F513}'}],
            networking:[{lvl:1,name:'Ping & traceroute',icon:'\u{1F310}'},{lvl:15,name:'DNS setup',icon:'\u{1F310}'},{lvl:30,name:'Firewall config',icon:'\u{1F6E1}\uFE0F'},{lvl:50,name:'Load balancing',icon:'\u{1F310}'},{lvl:70,name:'CDN architecture',icon:'\u{1F310}'}],
        };

        let selectedSkill=null;
        // Skill hover tooltip
        const skillTooltip=document.createElement('div');skillTooltip.className='skill-tooltip';skillTooltip.style.display='none';document.body.appendChild(skillTooltip);
        function renderStatsFromState(p){
            if(!p)return;
            const serverSkills=['attack','strength','defence','hitpoints','prayer','thieving'];
            const el=document.getElementById('stats-content');
            let html='<div class="skill-grid">';
            SKILLS.forEach(s=>{
                const isServer=serverSkills.includes(s.id);
                const lvl=isServer?p[s.id]:1;
                const xp=isServer?(p[s.id+'XP']||0):0;
                const curXp=xpForLevel(lvl);const nextXp=xpForLevel(lvl+1);
                const pct=nextXp>curXp?Math.min(100,((xp-curXp)/(nextXp-curXp))*100):0;
                const isSel=selectedSkill===s.id;
                html+='<div class="skill-cell'+(isSel?' skill-selected':'')+'" id="skill-'+s.id+'" onclick="selectSkill(\''+s.id+'\')" onmouseenter="showSkillTip(event,\''+s.name+'\','+lvl+')" onmouseleave="hideSkillTip()">';
                html+='<span class="skill-icon">'+s.icon+'</span>';
                html+='<span class="skill-lvl">'+lvl+'</span>';
                html+='<div class="skill-xp-bar"><div class="skill-xp-fill" style="width:'+pct+'%"></div></div>';
                html+='</div>';
            });
            html+='</div>';
            const totalLevel=serverSkills.reduce((sum,sk)=>sum+(p[sk]||1),0)+(SKILLS.length-serverSkills.length);
            html+='<div class="skill-total">Total Level: '+totalLevel+'</div>';
            if(selectedSkill){
                const s=SKILLS.find(sk=>sk.id===selectedSkill);
                if(s){
                    const isServer=serverSkills.includes(s.id);
                    const lvl=isServer?p[s.id]:1;const xp=isServer?(p[s.id+'XP']||0):0;
                    const nextXp=xpForLevel(lvl+1);
                    const guide=SKILL_GUIDE[s.id]||[];
                    html+='<div class="skill-guide">';
                    html+='<div class="skill-guide-header"><span class="skill-guide-title">'+s.icon+' '+s.name+'</span><span class="skill-guide-back" onclick="selectSkill(null)">Close</span></div>';
                    html+='<div class="skill-detail-row">Level: <b>'+lvl+'</b> &nbsp; XP: <b>'+xp.toLocaleString()+'</b> &nbsp; Next: <b>'+Math.max(0,nextXp-xp).toLocaleString()+'</b></div>';
                    guide.forEach(g=>{
                        const unlocked=lvl>=g.lvl;
                        const isCur=lvl>=g.lvl&&(guide.indexOf(g)===guide.length-1||lvl<guide[guide.indexOf(g)+1].lvl);
                        html+='<div class="skill-guide-row '+(isCur?'current':unlocked?'unlocked':'locked')+'">';
                        html+='<span class="skill-guide-lvl">'+g.lvl+'</span>';
                        html+='<span class="skill-guide-icon">'+g.icon+'</span>';
                        html+='<span class="skill-guide-name">'+g.name+'</span>';
                        if(unlocked)html+='<span style="color:#22c55e;font-size:9px;">\u2713</span>';
                        html+='</div>';
                    });
                    html+='</div>';
                }
            }
            el.innerHTML=html;
            document.getElementById('statCombatLvl').textContent=p.combatLevel;
        }
        window.showSkillTip=function(e,name,lvl){skillTooltip.textContent=name+' (Level '+lvl+')';skillTooltip.style.display='block';skillTooltip.style.left=(e.clientX+10)+'px';skillTooltip.style.top=(e.clientY-24)+'px';};
        window.hideSkillTip=function(){skillTooltip.style.display='none';};
        window.selectSkill=function(id){selectedSkill=(selectedSkill===id||id===null)?null:id;const p=getMyPlayer();if(p)renderStatsFromState(p);};

        // Shop
        function getMyPlayer(){return room?.state?.players?.get(mySessionId);}
        function countCoins(p){let t=0;for(let i=0;i<28;i++){if(p.inventory[i]&&p.inventory[i].id==='coins')t+=p.inventory[i].quantity;}return t;}
        function openShop(){
            const p=getMyPlayer();const coins=p?countCoins(p):0;
            document.getElementById('shop-coins-display').textContent='\u{1FA99} '+coins+' Coins';
            const body=document.getElementById('shop-body-content');
            body.innerHTML='<div class="shop-panel"><h3>Shop</h3>'+SHOP_ITEMS.map(si=>{const item=ITEMS[si.id];return'<div class="shop-item" onclick="sendAction(\'buy_item\',{itemId:\''+si.id+'\',quantity:1})"><span class="shop-item-icon">'+item.icon+'</span><span class="shop-item-name">'+item.name+'</span><span class="shop-item-price">\u{1FA99} '+si.price+'</span></div>';}).join('')+'</div><div class="shop-panel"><h3>Your Items</h3>'+(p?getPlayerSellItems(p):'<div style="padding:8px;font-size:11px;color:#6b7280;">Nothing to sell.</div>')+'</div>';
            document.getElementById('shop-overlay').classList.add('open');
        }
        function getPlayerSellItems(p){
            let html='';
            for(let i=0;i<28;i++){const item=p.inventory[i];if(!item||!item.id||item.type==='coin')continue;const si=SHOP_ITEMS.find(s=>s.id===item.id);const sell=si?Math.floor(si.price/2):1;html+='<div class="shop-item" onclick="sendAction(\'sell_item\',{inventorySlot:'+i+'})"><span class="shop-item-icon">'+item.icon+'</span><span class="shop-item-name">'+item.name+'</span><span class="shop-item-price" style="color:#22c55e;">+\u{1FA99} '+sell+'</span></div>';}
            return html||'<div style="padding:8px;font-size:11px;color:#6b7280;">Nothing to sell.</div>';
        }

        // Crafting
        function openCrafting(){
            const el=document.getElementById('craft-content');
            el.innerHTML=RECIPES.map((r,i)=>{const result=ITEMS[r.result];const ingText=r.ingredients.map(ing=>ITEMS[ing.id].icon+' '+ing.qty+'x '+ITEMS[ing.id].name).join(', ');return'<div class="shop-item" onclick="sendAction(\'craft_item\',{recipeIndex:'+i+'})"><span class="shop-item-icon">'+result.icon+'</span><span class="shop-item-name">'+result.name+'</span><span style="font-size:9px;color:#9ca3af;">'+ingText+' + \u{1FA99} '+r.coinCost+'</span></div>';}).join('');
            document.getElementById('craft-overlay').classList.add('open');
        }

        // Quests
        function renderQuestBoard(){
            const el=document.getElementById('quest-board-content');
            el.innerHTML='<div style="font-size:10px;color:#6b7280;padding:4px;text-transform:uppercase;letter-spacing:1px;">Available Quests</div>'+Object.values(QUESTS).map(q=>'<div class="quest-item" onclick="showQuestDetail(\''+q.id+'\')"><span class="quest-difficulty '+q.difficulty+'">'+q.difficulty+'</span><span class="quest-name">'+q.name+'</span><span class="quest-status-icon">\u{1F4DC}</span></div>').join('');
        }
        window.showQuestDetail=function(qid){
            const q=QUESTS[qid];if(!q)return;
            const el=document.getElementById('quest-board-content');
            const rewardText=[];
            if(q.rewards.coins)rewardText.push('\u{1FA99} '+q.rewards.coins+' coins');
            if(q.rewards.xp)Object.entries(q.rewards.xp).forEach(([s,a])=>rewardText.push(a+' '+s+' XP'));
            if(q.rewards.items)q.rewards.items.forEach(i=>rewardText.push(ITEMS[i.id].icon+' '+i.qty+'x '+ITEMS[i.id].name));
            el.innerHTML='<div class="quest-detail"><div style="cursor:pointer;color:#6366f1;font-size:11px;margin-bottom:8px;" onclick="renderQuestBoard()">\u2190 Back</div><div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;"><span class="quest-difficulty '+q.difficulty+'">'+q.difficulty+'</span><span style="font-size:14px;color:#fff;font-weight:bold;">'+q.name+'</span></div><div class="quest-detail-desc">'+q.description+'</div><div class="quest-detail-rewards">Rewards: '+rewardText.join(' \u00B7 ')+'</div><button class="quest-accept-btn" onclick="sendAction(\'accept_quest\',{questId:\''+qid+'\'})">Accept Quest</button></div>';
        };
        window.renderQuestBoard=renderQuestBoard;

        // Hitsplat + Chat bubble
        function showHitsplat(wx,wz,dmg,miss,isSpec){const el=document.createElement('div');el.className='hitsplat'+(miss?' miss':'')+(isSpec?' spec':'');el.textContent=miss?'0':dmg;el.dataset.worldX=wx;el.dataset.worldZ=wz;document.getElementById('chat-bubbles').appendChild(el);setTimeout(()=>el.remove(),1000);}
        function showChatBubble(wx,wz,text,color){const b=document.createElement('div');b.className='chat-bubble';b.textContent=text.substring(0,40);if(color)b.style.color=color;b.dataset.worldX=wx;b.dataset.worldZ=wz;document.getElementById('chat-bubbles').appendChild(b);setTimeout(()=>b.remove(),5000);}

        // Inventory context menu
        function showInventoryMenu(e,slot,p){
            const item=p.inventory[slot];if(!item||!item.id)return;
            const opts=[];
            if(item.type==='food')opts.push({label:'Eat',action:"sendAction('eat_food',{inventorySlot:"+slot+"});playCharAnim(myChar,'eat')"});
            if(item.type==='bones')opts.push({label:'Bury',action:"sendAction('bury_bones',{inventorySlot:"+slot+"});playCharAnim(myChar,'bury_bones')"});
            if(item.type==='weapon'||item.type==='axe')opts.push({label:'Wield',action:"sendAction('equip_item',{inventorySlot:"+slot+"})"});
            if(item.type==='helm')opts.push({label:'Wear',action:"sendAction('equip_item',{inventorySlot:"+slot+"})"});
            if(item.type==='shield')opts.push({label:'Wear',action:"sendAction('equip_item',{inventorySlot:"+slot+"})"});
            opts.push({label:'Drop',action:"sendAction('drop_item',{inventorySlot:"+slot+"})"});
            opts.push({label:'Cancel',action:'hideCtxMenu()'});
            showContextMenu(e,opts,item.icon+' '+item.name);
        }

        // ============================================================
        // CONTEXT MENU
        // ============================================================
        const ctxMenu=document.getElementById('context-menu');
        function hideCtxMenu(){ctxMenu.style.display='none';}
        window.hideCtxMenu=hideCtxMenu;
        document.addEventListener('click',e=>{if(!ctxMenu.contains(e.target))hideCtxMenu();});
        function showContextMenu(e,options,header){
            hideCtxMenu();
            ctxMenu.innerHTML=(header?'<div class="ctx-header">'+header+'</div>':'')+options.map(o=>'<div class="ctx-option" onclick="hideCtxMenu();'+o.action+'">'+o.label+'</div>').join('');
            ctxMenu.style.display='block';
            ctxMenu.style.left=Math.min(e.clientX,window.innerWidth-160)+'px';
            ctxMenu.style.top=Math.min(e.clientY,window.innerHeight-(options.length*30+30))+'px';
        }

        // ============================================================
        // CLIENT A* PATHFINDING + PATH VISUALIZATION
        // ============================================================
        function clientFindPath(sx,sz,ex,ez){
            if(ex<0||ex>=MAP_SIZE||ez<0||ez>=MAP_SIZE||grid[ex][ez]===0)return[];
            const open=[],closed=new Set(),cameFrom={};
            function key(x,z){return x+','+z;}
            function h(x,z){return Math.abs(x-ex)+Math.abs(z-ez);}
            open.push({x:sx,z:sz,g:0,f:h(sx,sz)});
            while(open.length>0){
                open.sort((a,b)=>a.f-b.f);
                const cur=open.shift(),ck=key(cur.x,cur.z);
                if(cur.x===ex&&cur.z===ez){
                    const path=[];let kk=ck;
                    while(kk){const[px,pz]=kk.split(',').map(Number);path.unshift({x:px,z:pz});kk=cameFrom[kk];}
                    return path;
                }
                closed.add(ck);
                const nb=[{x:cur.x+1,z:cur.z},{x:cur.x-1,z:cur.z},{x:cur.x,z:cur.z+1},{x:cur.x,z:cur.z-1}];
                for(const n of nb){
                    if(n.x<0||n.x>=MAP_SIZE||n.z<0||n.z>=MAP_SIZE||grid[n.x][n.z]===0)continue;
                    const nk=key(n.x,n.z);if(closed.has(nk))continue;
                    const g=cur.g+1,existing=open.find(o=>key(o.x,o.z)===nk);
                    if(existing&&g>=existing.g)continue;
                    cameFrom[nk]=ck;
                    if(existing){existing.g=g;existing.f=g+h(n.x,n.z);}
                    else open.push({x:n.x,z:n.z,g,f:g+h(n.x,n.z)});
                }
            }
            return[];
        }

        // Path visualization state
        const pathGroup=new THREE.Group();scene.add(pathGroup);
        let destMarker=null;
        const pathDotGeo=new THREE.CircleGeometry(0.15,8);
        const pathDotMat=new THREE.MeshBasicMaterial({color:0xffff00,transparent:true,opacity:0.25});

        function clearWalkPath(){
            while(pathGroup.children.length>0){pathGroup.remove(pathGroup.children[0]);}
            if(destMarker){scene.remove(destMarker);destMarker=null;}
        }
        function renderWalkPath(path,targetX,targetZ){
            clearWalkPath();
            // Path dots (skip first node = current position)
            for(let i=1;i<path.length;i++){
                const dot=new THREE.Mesh(pathDotGeo,pathDotMat);
                dot.rotation.x=-Math.PI/2;
                const px=path[i].x,pz=path[i].z;
                const h=heightMap[px]?heightMap[px][pz]||0:0;
                dot.position.set(px,h+0.05,pz);
                dot.userData.pathIdx=i;dot.userData.px=px;dot.userData.pz=pz;
                pathGroup.add(dot);
            }
            // Destination pulsing ring
            const ringGeo=new THREE.TorusGeometry(0.3,0.04,8,24);
            const ringMat=new THREE.MeshBasicMaterial({color:0xffff00,transparent:true,opacity:0.4});
            destMarker=new THREE.Mesh(ringGeo,ringMat);
            destMarker.rotation.x=-Math.PI/2;
            const dh=heightMap[targetX]?heightMap[targetX][targetZ]||0:0;
            destMarker.position.set(targetX,dh+0.06,targetZ);
            destMarker.userData.baseScale=1;
            scene.add(destMarker);
        }

        // Walk-to helper (usable from context menu eval)
        window.walkToTile=function(tx,tz){
            const curTX=Math.round(myWorldX),curTZ=Math.round(myWorldZ);
            const p=clientFindPath(curTX,curTZ,tx,tz);
            if(p.length>1)renderWalkPath(p,tx,tz);
            sendAction('move_to',{tileX:tx,tileZ:tz});
        };

        // ============================================================
        // RAYCASTING & INPUT
        // ============================================================
        const raycasterMain=new THREE.Raycaster();
        function getViewportMouse(e){const rect=viewport.getBoundingClientRect();return new THREE.Vector2(((e.clientX-rect.left)/rect.width)*2-1,-((e.clientY-rect.top)/rect.height)*2+1);}

        // Build combined raycast target list: terrain InstancedMeshes + entity groups
        function getRayObjects(){
            const objs=[...rayTargets];
            npcMeshes.forEach(n=>objs.push(n.group));
            monsterMeshes.forEach(m=>objs.push(m.group));
            resourceNodes.forEach(n=>{if(!n.depleted)objs.push(n.mesh);});
            return objs;
        }

        // Resolve hit data ‚Äî handles InstancedMesh terrain lookups and regular mesh userData
        function resolveHit(h){
            // InstancedMesh terrain: look up tileMap by instanceId
            if(h.object.isInstancedMesh&&h.object.userData.type==='terrain'){
                const tm=h.object.userData.tileMap;
                if(tm&&h.instanceId!=null&&h.instanceId<tm.length){
                    const t=tm[h.instanceId];
                    return{type:'tile',tileX:t.x,tileZ:t.z,walkable:t.walkable};
                }
                return null;
            }
            // Regular mesh with userData ‚Äî also walk up parents for resource nodes
            let obj=h.object;
            while(obj){
                const ud=obj.userData;
                if(ud.type==='npc')return{type:'npc',npcId:ud.npcId};
                if(ud.type==='monster')return{type:'monster',monsterId:ud.monsterId};
                if(ud.type==='resource_node')return{type:'resource_node',nodeId:ud.nodeId};
                if(ud.type==='building')return{type:'building',buildingId:ud.buildingId};
                if(ud.type==='tile')return{type:'tile',tileX:ud.tileX,tileZ:ud.tileZ,walkable:ud.walkable};
                if(ud.tileX!==undefined)return{type:'tile',tileX:ud.tileX,tileZ:ud.tileZ,walkable:ud.walkable};
                obj=obj.parent;
            }
            return null;
        }

        renderer.domElement.addEventListener('click',e=>{
            if(e.target!==renderer.domElement)return;
            const m=getViewportMouse(e);raycasterMain.setFromCamera(m,camera);
            const hits=raycasterMain.intersectObjects(getRayObjects(),true);
            let hitNPC=null,hitMonster=null,hitBld=null,hitTile=null,hitNode=null;
            for(const h of hits){
                const r=resolveHit(h);if(!r)continue;
                if(r.type==='npc'&&!hitNPC)hitNPC=r.npcId;
                if(r.type==='monster'&&!hitMonster)hitMonster=r.monsterId;
                if(r.type==='resource_node'&&!hitNode)hitNode=r.nodeId;
                if(r.type==='building'&&!hitBld)hitBld=r.buildingId;
                if(r.type==='tile'&&!hitTile)hitTile=r;
            }
            if(hitMonster){if(attackMode)sendAction('attack_monster',{monsterId:hitMonster});return;}
            if(hitNPC){if(attackMode)sendAction('attack_npc',{npcId:hitNPC});else{const npc=npcMeshes.get(hitNPC);if(npc)addChat('agent','Hello there!',npc.state.name,npc.state.roleColor);}return;}
            if(hitNode){
                // Click on resource node: walk to it and gather
                const node=resourceNodes.get(hitNode);
                if(node&&!node.depleted){
                    const curTX=Math.round(myWorldX),curTZ=Math.round(myWorldZ);
                    const p=clientFindPath(curTX,curTZ,node.x,node.z);
                    if(p.length>1)renderWalkPath(p,node.x,node.z);
                    sendAction('move_to',{tileX:node.x,tileZ:node.z});
                    // Send gather after a short delay to allow movement
                    setTimeout(()=>sendAction('gather_resource',{nodeId:hitNode}),300);
                }
                return;
            }
            if(hitBld){const door=buildingDoors[hitBld];if(door){const curTX=Math.round(myWorldX),curTZ=Math.round(myWorldZ);const p=clientFindPath(curTX,curTZ,door.x,door.z);if(p.length>1)renderWalkPath(p,door.x,door.z);sendAction('move_to',{tileX:door.x,tileZ:door.z});}return;}
            if(hitTile&&hitTile.walkable){const curTX=Math.round(myWorldX),curTZ=Math.round(myWorldZ);const p=clientFindPath(curTX,curTZ,hitTile.tileX,hitTile.tileZ);if(p.length>1)renderWalkPath(p,hitTile.tileX,hitTile.tileZ);sendAction('move_to',{tileX:hitTile.tileX,tileZ:hitTile.tileZ});}
        });

        renderer.domElement.addEventListener('contextmenu',e=>{
            e.preventDefault();
            const m2=getViewportMouse(e);raycasterMain.setFromCamera(m2,camera);
            const hits=raycasterMain.intersectObjects(getRayObjects(),true);
            let hitNPC=null,hitMonster=null,hitBld=null,hitTile=null,hitNode=null;
            for(const h of hits){
                const r=resolveHit(h);if(!r)continue;
                if(r.type==='npc'&&!hitNPC)hitNPC=r.npcId;
                if(r.type==='monster'&&!hitMonster)hitMonster=r.monsterId;
                if(r.type==='resource_node'&&!hitNode)hitNode=r.nodeId;
                if(r.type==='building'&&!hitBld)hitBld=r.buildingId;
                if(r.type==='tile'&&!hitTile)hitTile=r;
            }
            if(hitNode){
                const node=resourceNodes.get(hitNode);
                if(node&&!node.depleted){
                    const def=resourceDefs.get(node.defId);
                    const nodeName=def?def.name:node.defId;
                    const nodeIcon=def?def.icon:'\u{1F333}';
                    const skillName=def?def.skill:'gathering';
                    const lvlReq=def?def.levelReq:1;
                    showContextMenu(e,[
                        {label:skillName.charAt(0).toUpperCase()+skillName.slice(1)+' '+nodeName,action:"sendAction('move_to',{tileX:"+node.x+",tileZ:"+node.z+"});setTimeout(()=>sendAction('gather_resource',{nodeId:'"+hitNode+"'}),300)"},
                        {label:'Examine',action:"addChat('system','"+nodeName+" \u2014 Requires "+skillName+" level "+lvlReq+"')"},
                        {label:'Cancel',action:'hideCtxMenu()'}
                    ],nodeIcon+' '+nodeName);
                }
                return;
            }
            if(hitMonster){
                const mon=monsterMeshes.get(hitMonster);
                if(mon&&!mon.state.isDead){const monOpts=[];if(mon.state.isHumanoid)monOpts.push({label:'Pickpocket '+mon.state.name,action:"sendAction('pickpocket',{monsterId:'"+hitMonster+"'})"});monOpts.push({label:'Attack '+mon.state.name,action:"sendAction('attack_monster',{monsterId:'"+hitMonster+"'})"});monOpts.push({label:'Examine',action:"addChat('system','"+mon.state.name+" - Level "+mon.state.level+" (HP: "+mon.state.hp+"/"+mon.state.maxHp+")')"});monOpts.push({label:'Cancel',action:'hideCtxMenu()'});showContextMenu(e,monOpts,mon.state.name);}
                return;
            }
            if(hitNPC){
                const npc=npcMeshes.get(hitNPC);
                if(npc&&!npc.state.isDead){showContextMenu(e,[{label:'Talk to '+npc.state.name,action:"talkToNPC('"+hitNPC+"')"},{label:'Pickpocket '+npc.state.name,action:"sendAction('pickpocket',{npcId:'"+hitNPC+"'})"},{label:'Attack '+npc.state.name,action:"sendAction('attack_npc',{npcId:'"+hitNPC+"'})"},{label:'Examine',action:"examineNPC('"+hitNPC+"')"},{label:'Cancel',action:'hideCtxMenu()'}],npc.state.name);}
                return;
            }
            if(hitBld){const bd=BUILDINGS.find(b=>b.id===hitBld);if(bd){showContextMenu(e,[{label:'Enter '+bd.name,action:"enterBuilding('"+hitBld+"')"},{label:'Cancel',action:'hideCtxMenu()'}],bd.icon+' '+bd.name);}return;}
            if(hitTile){showContextMenu(e,[{label:'Walk here',action:"walkToTile("+hitTile.tileX+","+hitTile.tileZ+")"},{label:'Cancel',action:'hideCtxMenu()'}]);}
        });

        renderer.domElement.addEventListener('mousemove',e=>{
            const m=getViewportMouse(e);raycasterMain.setFromCamera(m,camera);
            const hits=raycasterMain.intersectObjects(getRayObjects(),true);
            highlight.visible=false;let cursorSet=false;
            for(const h of hits){
                const r=resolveHit(h);if(!r)continue;
                if(r.type==='resource_node'){document.body.style.cursor='pointer';cursorSet=true;break;}
                if(r.type==='npc'||r.type==='monster'){document.body.style.cursor=attackMode?'crosshair':'help';cursorSet=true;break;}
                if(r.type==='building'){document.body.style.cursor='pointer';cursorSet=true;break;}
                if(r.type==='tile'){const tx=r.tileX,tz=r.tileZ;highlight.position.set(tx,heightMap[tx][tz]+0.05,tz);highlight.visible=true;highlightMat.color.set(r.walkable?0xffff00:0xff4444);highlightMat.opacity=r.walkable?0.3:0.2;document.body.style.cursor=r.walkable?'pointer':'not-allowed';cursorSet=true;break;}
            }
            if(!cursorSet)document.body.style.cursor='default';
        });

        window.talkToNPC=function(id){hideCtxMenu();const npc=npcMeshes.get(id);if(!npc)return;addChat('agent','Hello there!',npc.state.name,npc.state.roleColor);showChatBubble(npc.state.x,npc.state.z,'Hello there!','#22c55e');};
        window.examineNPC=function(id){hideCtxMenu();const npc=npcMeshes.get(id);if(!npc)return;const cs=NPC_COMBAT_STATS[npc.state.role]||{attack:3,strength:3,defence:3};addChat('system',npc.state.name+' \u2014 '+npc.state.role+' (HP: '+npc.state.hp+'/'+npc.state.maxHp+', Atk: '+cs.attack+', Str: '+cs.strength+', Def: '+cs.defence+')');};
        window.enterBuilding=function(bid){hideCtxMenu();const door=buildingDoors[bid];if(door)sendAction('move_to',{tileX:door.x,tileZ:door.z});};
        window.sendAction=sendAction;
        window.handleUnequip=handleUnequip;
        window.sendSpec=function(){sendAction('use_special_attack');};
        window.toggleAttackMode=function(){attackMode=!attackMode;document.getElementById('btnAttackMode').classList.toggle('active',attackMode);};

        // Keyboard
        const keys={};
        window.addEventListener('keydown',e=>{if(!chatInputFocused){keys[e.key.toLowerCase()]=true;if(e.key.toLowerCase()==='f')sendAction('use_special_attack');}});
        window.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);
        renderer.domElement.addEventListener('wheel',e=>{camDist+=e.deltaY*0.01;camDist=Math.max(6,Math.min(30,camDist));});

        // ============================================================
        // MINIMAP
        // ============================================================
        const minimapCanvas=document.getElementById('minimap');const mctx=minimapCanvas.getContext('2d');
        // Pre-render minimap terrain to offscreen canvas (1px per tile)
        const minimapBG=document.createElement('canvas');minimapBG.width=MAP_SIZE;minimapBG.height=MAP_SIZE;
        const bgctx=minimapBG.getContext('2d');
        for(let x=0;x<MAP_SIZE;x++)for(let z=0;z<MAP_SIZE;z++){const inCastle=x>=CASTLE.x1&&x<=CASTLE.x2&&z>=CASTLE.z1&&z<=CASTLE.z2;const onCastleEdge=inCastle&&(x===CASTLE.x1||x===CASTLE.x2||z===CASTLE.z1||z===CASTLE.z2);if(grid[x][z]===4)bgctx.fillStyle='#8B6914';else if(onCastleEdge&&grid[x][z]===0)bgctx.fillStyle='#C4B08A';else if(inCastle&&grid[x][z]>0)bgctx.fillStyle='#808080';else if(grid[x][z]===3)bgctx.fillStyle='#8B6914';else if(isWater(x,z))bgctx.fillStyle='#2288aa';else if(grid[x][z]===0)bgctx.fillStyle='#2d4a1e';else if(grid[x][z]===2)bgctx.fillStyle='#8B7355';else bgctx.fillStyle='#4a7c3f';bgctx.fillRect(x,z,1,1);}
        function drawMinimap(){
            const s=200/MAP_SIZE;mctx.clearRect(0,0,200,200);
            mctx.drawImage(minimapBG,0,0,200,200);
            // Zone borders on minimap
            Object.values(ZONES).forEach(zone=>{mctx.strokeStyle=zone.color;mctx.lineWidth=1;mctx.globalAlpha=0.3;mctx.strokeRect(zone.bounds.x1*s,zone.bounds.z1*s,(zone.bounds.x2-zone.bounds.x1)*s,(zone.bounds.z2-zone.bounds.z1)*s);mctx.globalAlpha=1;});
            BUILDINGS.forEach(b=>{mctx.fillStyle=b.signColor;mctx.globalAlpha=0.6;mctx.fillRect((b.x-b.w/2)*s,(b.z-b.d/2)*s,b.w*s,b.d*s);mctx.globalAlpha=1;});
            npcMeshes.forEach(n=>{if(!n.state.isDead){const rc=ROLE_COLORS[n.state.role];mctx.fillStyle=rc?rc.hex:'#fff';mctx.beginPath();mctx.arc(n.state.x*s,n.state.z*s,1.5,0,Math.PI*2);mctx.fill();}});
            monsterMeshes.forEach(m=>{if(!m.state.isDead){mctx.fillStyle=m.state.isBoss?'#ff0000':'#cc4444';mctx.beginPath();mctx.arc(m.state.x*s,m.state.z*s,m.state.isBoss?3:1.5,0,Math.PI*2);mctx.fill();}});
            resourceNodes.forEach(n=>{if(!n.depleted){const def=resourceDefs.get(n.defId);mctx.fillStyle=def&&def.skill==='woodcutting'?'#22c55e':def&&def.skill==='mining'?'#9ca3af':'#2288cc';mctx.beginPath();mctx.arc(n.x*s,n.z*s,1.5,0,Math.PI*2);mctx.fill();}});
            otherPlayerMeshes.forEach(p=>{mctx.fillStyle=p.state.color||'#fff';mctx.beginPath();mctx.arc(p.state.x*s,p.state.z*s,2.5,0,Math.PI*2);mctx.fill();});
            mctx.fillStyle='#ffff00';mctx.beginPath();mctx.arc(myWorldX*s,myWorldZ*s,3,0,Math.PI*2);mctx.fill();
        }

        // ============================================================
        // OVERLAY PROJECTION
        // ============================================================
        function projectToScreen(wx,wz,yOffset){const pos=new THREE.Vector3(wx,yOffset,wz);pos.project(camera);const rect=viewport.getBoundingClientRect();return{x:(pos.x*0.5+0.5)*rect.width,y:(-pos.y*0.5+0.5)*rect.height,visible:pos.z>-1&&pos.z<1};}
        function updateOverlays(){
            npcMeshes.forEach(n=>{const p=projectToScreen(n.state.x,n.state.z,1.3);if(!p.visible||n.state.isDead){n.label.style.display='none';}else{n.label.style.display='block';n.label.style.left=p.x+'px';n.label.style.top=p.y+'px';}});
            monsterMeshes.forEach(m=>{const p=projectToScreen(m.state.x,m.state.z,1.3);if(!p.visible||m.state.isDead){m.label.style.display='none';}else{m.label.style.display='block';m.label.style.left=p.x+'px';m.label.style.top=p.y+'px';}});
            otherPlayerMeshes.forEach(m=>{const p=projectToScreen(m.state.x,m.state.z,1.3);if(!p.visible||m.state.isDead){m.label.style.display='none';}else{m.label.style.display='block';m.label.style.left=p.x+'px';m.label.style.top=p.y+'px';}});
            lootPileMeshes.forEach(m=>{const p=projectToScreen(m.state.x,m.state.z,0.3);if(p.visible){m.dot.style.display='block';m.dot.style.left=p.x+'px';m.dot.style.top=p.y+'px';}else{m.dot.style.display='none';}});
            resourceNodes.forEach(n=>{if(n.depleted){n.label.style.display='none';return;}const p=projectToScreen(n.x,n.z,1.2);if(p.visible){n.label.style.display='block';n.label.style.left=p.x+'px';n.label.style.top=p.y+'px';}else{n.label.style.display='none';}});
            document.querySelectorAll('.chat-bubble, .hitsplat').forEach(el=>{const wx=parseFloat(el.dataset.worldX),wz=parseFloat(el.dataset.worldZ);const p=projectToScreen(wx,wz,el.classList.contains('hitsplat')?1.5:1.6);if(p.visible){el.style.left=p.x+'px';el.style.top=p.y+'px';}else el.style.display='none';});
        }

        // ============================================================
        // KEYFRAME ANIMATION ENGINE
        // ============================================================
        const GAME_ANIMS = {
            attack_slash:{duration:0.6,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.3,la_rx:0.3,la_rz:0,ra_rx:-1.8,ra_rz:-0.5,ll_rx:0.2,rl_rx:-0.2,body_rx:0.2,body_y:0.5},{t:0.5,la_rx:0.1,la_rz:0,ra_rx:0.8,ra_rz:0.3,ll_rx:-0.1,rl_rx:0.1,body_rx:-0.1,body_y:0.5},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            attack_stab:{duration:0.5,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.4,la_rx:0,la_rz:0,ra_rx:-1.5,ra_rz:0,ll_rx:-0.3,rl_rx:0.3,body_rx:0.25,body_y:0.48},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            block:{duration:0.4,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.3,la_rx:-1.2,la_rz:0.4,ra_rx:-0.8,ra_rz:-0.3,ll_rx:0.1,rl_rx:-0.1,body_rx:-0.1,body_y:0.48},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            death:{duration:1.0,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.3,la_rx:0.5,la_rz:0.3,ra_rx:0.5,ra_rz:-0.3,ll_rx:-0.2,rl_rx:-0.2,body_rx:-0.3,body_y:0.45},{t:0.7,la_rx:1.2,la_rz:0.5,ra_rx:1.2,ra_rz:-0.5,ll_rx:-0.8,rl_rx:-0.8,body_rx:-1.2,body_y:0.25},{t:1,la_rx:1.4,la_rz:0.6,ra_rx:1.4,ra_rz:-0.6,ll_rx:-1.0,rl_rx:-1.0,body_rx:-1.5,body_y:0.15}]},
            flinch:{duration:0.35,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.3,la_rx:0.4,la_rz:0.2,ra_rx:0.4,ra_rz:-0.2,ll_rx:0.15,rl_rx:0.15,body_rx:-0.3,body_y:0.47},{t:0.6,la_rx:0.2,la_rz:0.1,ra_rx:0.2,ra_rz:-0.1,ll_rx:0.05,rl_rx:0.05,body_rx:-0.15,body_y:0.48},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            special_attack:{duration:0.8,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.15,la_rx:-0.5,la_rz:0.2,ra_rx:-2.2,ra_rz:-0.3,ll_rx:0.1,rl_rx:-0.1,body_rx:-0.2,body_y:0.52},{t:0.35,la_rx:-0.6,la_rz:0.3,ra_rx:-2.8,ra_rz:-0.4,ll_rx:0.15,rl_rx:-0.15,body_rx:-0.25,body_y:0.54},{t:0.5,la_rx:0.4,la_rz:0,ra_rx:1.0,ra_rz:0.3,ll_rx:-0.3,rl_rx:0.3,body_rx:0.35,body_y:0.44},{t:0.65,la_rx:0.2,la_rz:0,ra_rx:0.4,ra_rz:0.1,ll_rx:-0.1,rl_rx:0.1,body_rx:0.15,body_y:0.48},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            eat:{duration:0.7,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.2,la_rx:0,la_rz:0,ra_rx:-1.8,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.5,la_rx:0,la_rz:0,ra_rx:-2.2,ra_rz:0.1,ll_rx:0,rl_rx:0,body_rx:-0.05,body_y:0.51},{t:0.7,la_rx:0,la_rz:0,ra_rx:-1.8,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            pickup_loot:{duration:0.6,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.35,la_rx:0.6,la_rz:0,ra_rx:0.8,ra_rz:0,ll_rx:-0.4,rl_rx:-0.2,body_rx:0.7,body_y:0.35},{t:0.55,la_rx:0.3,la_rz:0,ra_rx:0.5,ra_rz:0,ll_rx:-0.2,rl_rx:-0.1,body_rx:0.4,body_y:0.42},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            level_up:{duration:1.2,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.15,la_rx:0.1,la_rz:0,ra_rx:0.1,ra_rz:0,ll_rx:-0.2,rl_rx:-0.2,body_rx:0,body_y:0.45},{t:0.35,la_rx:-2.8,la_rz:-0.4,ra_rx:-2.8,ra_rz:0.4,ll_rx:0,rl_rx:0,body_rx:-0.1,body_y:0.56},{t:0.55,la_rx:-2.6,la_rz:-0.5,ra_rx:-2.6,ra_rz:0.5,ll_rx:0,rl_rx:0,body_rx:-0.1,body_y:0.54},{t:0.75,la_rx:-2.8,la_rz:-0.4,ra_rx:-2.8,ra_rz:0.4,ll_rx:0,rl_rx:0,body_rx:-0.1,body_y:0.56},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            bury_bones:{duration:1.0,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.3,la_rx:-0.6,la_rz:0,ra_rx:-0.6,ra_rz:0,ll_rx:-0.8,rl_rx:-0.8,body_rx:0.2,body_y:0.32},{t:0.5,la_rx:-0.8,la_rz:0,ra_rx:-0.8,ra_rz:0,ll_rx:-1.0,rl_rx:-1.0,body_rx:0.3,body_y:0.28},{t:0.7,la_rx:-0.6,la_rz:0,ra_rx:-0.6,ra_rz:0,ll_rx:-0.8,rl_rx:-0.8,body_rx:0.2,body_y:0.32},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            gather:{duration:0.8,loop:true,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.25,la_rx:0.2,la_rz:0,ra_rx:-1.5,ra_rz:-0.3,ll_rx:0.1,rl_rx:-0.1,body_rx:0.15,body_y:0.48},{t:0.5,la_rx:0.1,la_rz:0,ra_rx:-0.5,ra_rz:0.1,ll_rx:-0.1,rl_rx:0.1,body_rx:0.05,body_y:0.5},{t:0.75,la_rx:0.2,la_rz:0,ra_rx:-1.5,ra_rz:-0.3,ll_rx:0.1,rl_rx:-0.1,body_rx:0.15,body_y:0.48},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            pickpocket:{duration:0.6,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.5,la_rx:0,la_rz:0,ra_rx:-1.4,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.15,body_y:0.5},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            wave:{duration:1.0,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.15,la_rx:0,la_rz:0,ra_rx:-2.5,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.35,la_rx:0,la_rz:0,ra_rx:-2.2,ra_rz:-0.5,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.55,la_rx:0,la_rz:0,ra_rx:-2.5,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.75,la_rx:0,la_rz:0,ra_rx:-2.2,ra_rz:-0.5,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            dance:{duration:1.5,loop:true,keyframes:[{t:0,la_rx:-0.5,la_rz:-0.5,ra_rx:-0.5,ra_rz:0.5,ll_rx:0.3,rl_rx:-0.3,body_rx:0,body_y:0.5},{t:0.25,la_rx:-1.5,la_rz:-0.3,ra_rx:-1.5,ra_rz:0.3,ll_rx:-0.3,rl_rx:0.3,body_rx:0,body_y:0.54},{t:0.5,la_rx:-0.5,la_rz:0.5,ra_rx:-0.5,ra_rz:-0.5,ll_rx:0.3,rl_rx:-0.3,body_rx:0,body_y:0.5},{t:0.75,la_rx:-1.5,la_rz:0.3,ra_rx:-1.5,ra_rz:-0.3,ll_rx:-0.3,rl_rx:0.3,body_rx:0,body_y:0.54},{t:1,la_rx:-0.5,la_rz:-0.5,ra_rx:-0.5,ra_rz:0.5,ll_rx:0.3,rl_rx:-0.3,body_rx:0,body_y:0.5}]},
            bow:{duration:0.8,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.4,la_rx:0.3,la_rz:0,ra_rx:0.3,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0.6,body_y:0.45},{t:0.6,la_rx:0.3,la_rz:0,ra_rx:0.3,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0.6,body_y:0.45},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            clap:{duration:1.0,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.1,la_rx:-1.2,la_rz:0.5,ra_rx:-1.2,ra_rz:-0.5,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.2,la_rx:-1.2,la_rz:0.1,ra_rx:-1.2,ra_rz:-0.1,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.35,la_rx:-1.2,la_rz:0.5,ra_rx:-1.2,ra_rz:-0.5,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.45,la_rx:-1.2,la_rz:0.1,ra_rx:-1.2,ra_rz:-0.1,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.6,la_rx:-1.2,la_rz:0.5,ra_rx:-1.2,ra_rz:-0.5,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.7,la_rx:-1.2,la_rz:0.1,ra_rx:-1.2,ra_rz:-0.1,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            think:{duration:2.0,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.2,la_rx:0.2,la_rz:0,ra_rx:-1.8,ra_rz:0.2,ll_rx:0,rl_rx:0,body_rx:-0.05,body_y:0.5},{t:0.4,la_rx:0.2,la_rz:0,ra_rx:-1.8,ra_rz:0.15,ll_rx:0,rl_rx:0,body_rx:-0.05,body_y:0.5},{t:0.6,la_rx:0.2,la_rz:0,ra_rx:-1.8,ra_rz:0.25,ll_rx:0,rl_rx:0,body_rx:-0.05,body_y:0.5},{t:0.8,la_rx:0.2,la_rz:0,ra_rx:-1.8,ra_rz:0.15,ll_rx:0,rl_rx:0,body_rx:-0.05,body_y:0.5},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            laugh:{duration:1.2,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.1,la_rx:-0.6,la_rz:0.3,ra_rx:-0.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.15,body_y:0.48},{t:0.2,la_rx:-0.6,la_rz:0.3,ra_rx:-0.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.25,body_y:0.46},{t:0.3,la_rx:-0.6,la_rz:0.3,ra_rx:-0.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.15,body_y:0.48},{t:0.4,la_rx:-0.6,la_rz:0.3,ra_rx:-0.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.25,body_y:0.46},{t:0.55,la_rx:-0.6,la_rz:0.3,ra_rx:-0.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.15,body_y:0.48},{t:0.7,la_rx:-0.6,la_rz:0.3,ra_rx:-0.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.2,body_y:0.47},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            angry:{duration:1.0,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.15,la_rx:-1.0,la_rz:-0.3,ra_rx:-1.0,ra_rz:0.3,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.52},{t:0.3,la_rx:-1.0,la_rz:-0.3,ra_rx:-1.0,ra_rz:0.3,ll_rx:0,rl_rx:0.5,body_rx:0.05,body_y:0.48},{t:0.45,la_rx:-1.0,la_rz:-0.3,ra_rx:-1.0,ra_rz:0.3,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.52},{t:0.6,la_rx:-1.0,la_rz:-0.3,ra_rx:-1.0,ra_rz:0.3,ll_rx:0.5,rl_rx:0,body_rx:0.05,body_y:0.48},{t:0.75,la_rx:-1.0,la_rz:-0.3,ra_rx:-1.0,ra_rz:0.3,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.52},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            point:{duration:1.0,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.25,la_rx:0.1,la_rz:0,ra_rx:-1.5,ra_rz:-0.1,ll_rx:0,rl_rx:0,body_rx:0.05,body_y:0.5},{t:0.7,la_rx:0.1,la_rz:0,ra_rx:-1.5,ra_rz:-0.1,ll_rx:0,rl_rx:0,body_rx:0.05,body_y:0.5},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            cry:{duration:2.0,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.15,la_rx:-1.6,la_rz:0.3,ra_rx:-1.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.1,body_y:0.48},{t:0.3,la_rx:-1.6,la_rz:0.3,ra_rx:-1.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.2,body_y:0.46},{t:0.45,la_rx:-1.6,la_rz:0.3,ra_rx:-1.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.1,body_y:0.48},{t:0.6,la_rx:-1.6,la_rz:0.3,ra_rx:-1.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.2,body_y:0.46},{t:0.75,la_rx:-1.6,la_rz:0.3,ra_rx:-1.6,ra_rz:-0.3,ll_rx:0,rl_rx:0,body_rx:0.1,body_y:0.48},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            cheer:{duration:1.0,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.15,la_rx:0.2,la_rz:0,ra_rx:0.2,ra_rz:0,ll_rx:-0.3,rl_rx:-0.3,body_rx:0,body_y:0.44},{t:0.3,la_rx:-2.6,la_rz:-0.5,ra_rx:-2.6,ra_rz:0.5,ll_rx:0.2,rl_rx:0.2,body_rx:0,body_y:0.58},{t:0.5,la_rx:-2.4,la_rz:-0.4,ra_rx:-2.4,ra_rz:0.4,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.52},{t:0.65,la_rx:-2.6,la_rz:-0.5,ra_rx:-2.6,ra_rz:0.5,ll_rx:0.2,rl_rx:0.2,body_rx:0,body_y:0.58},{t:0.8,la_rx:-2.4,la_rz:-0.4,ra_rx:-2.4,ra_rz:0.4,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.52},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            shrug:{duration:1.2,loop:false,keyframes:[{t:0,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5},{t:0.25,la_rx:-0.8,la_rz:-0.8,ra_rx:-0.8,ra_rz:0.8,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.52},{t:0.65,la_rx:-0.8,la_rz:-0.8,ra_rx:-0.8,ra_rz:0.8,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.52},{t:1,la_rx:0,la_rz:0,ra_rx:0,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0,body_y:0.5}]},
            headbang:{duration:1.0,loop:true,keyframes:[{t:0,la_rx:0.3,la_rz:0,ra_rx:0.3,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:-0.1,body_y:0.5},{t:0.2,la_rx:0.3,la_rz:0,ra_rx:0.3,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0.35,body_y:0.47},{t:0.4,la_rx:0.3,la_rz:0,ra_rx:0.3,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:-0.1,body_y:0.5},{t:0.6,la_rx:0.3,la_rz:0,ra_rx:0.3,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:0.35,body_y:0.47},{t:0.8,la_rx:0.3,la_rz:0,ra_rx:0.3,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:-0.1,body_y:0.5},{t:1,la_rx:0.3,la_rz:0,ra_rx:0.3,ra_rz:0,ll_rx:0,rl_rx:0,body_rx:-0.1,body_y:0.5}]},
        };

        function playCharAnim(c, animId) {
            const a = GAME_ANIMS[animId]; if (!a) return;
            c.charAnim = { id: animId, timer: a.duration, duration: a.duration, loop: a.loop, keyframes: a.keyframes };
        }
        function stopCharAnim(c) {
            c.charAnim = null;
            if (c.isCustomModel) {
                if (c.modelRoot) { c.modelRoot.rotation.x = 0; c.modelRoot.rotation.z = 0; }
            } else {
                if (c.leftArm) { c.leftArm.rotation.x = 0; c.leftArm.rotation.z = 0; }
                if (c.rightArm) { c.rightArm.rotation.x = 0; c.rightArm.rotation.z = 0; }
                if (c.leftLeg) c.leftLeg.rotation.x = 0;
                if (c.rightLeg) c.rightLeg.rotation.x = 0;
                if (c.body) { c.body.rotation.x = 0; c.body.position.y = 0.5; }
            }
        }
        function updateCharAnim(c, dt) {
            if (!c.charAnim) return false;
            const a = c.charAnim;
            a.timer -= dt;
            const progress = 1 - Math.max(0, a.timer) / a.duration;
            const kfs = a.keyframes;
            let prev = kfs[0], next = kfs[kfs.length - 1];
            for (let i = 0; i < kfs.length - 1; i++) {
                if (progress >= kfs[i].t && progress <= kfs[i + 1].t) { prev = kfs[i]; next = kfs[i + 1]; break; }
            }
            const range = next.t - prev.t;
            const t = range > 0 ? (progress - prev.t) / range : 0;
            const lerp = (a, b) => a + (b - a) * t;
            if (c.isCustomModel) {
                // Whole-body keyframe: map arm/body rotations to model root
                const avgRot = (lerp(prev.la_rx, next.la_rx) + lerp(prev.ra_rx, next.ra_rx)) * 0.3;
                if (c.modelRoot) { c.modelRoot.rotation.x = avgRot; }
            } else {
                c.leftArm.rotation.x = lerp(prev.la_rx, next.la_rx);
                c.leftArm.rotation.z = lerp(prev.la_rz, next.la_rz);
                c.rightArm.rotation.x = lerp(prev.ra_rx, next.ra_rx);
                c.rightArm.rotation.z = lerp(prev.ra_rz, next.ra_rz);
                c.leftLeg.rotation.x = lerp(prev.ll_rx, next.ll_rx);
                c.rightLeg.rotation.x = lerp(prev.rl_rx, next.rl_rx);
                c.body.rotation.x = lerp(prev.body_rx, next.body_rx);
                c.body.position.y = lerp(prev.body_y, next.body_y);
            }
            if (a.timer <= 0) {
                if (a.loop) { a.timer = a.duration; }
                else { stopCharAnim(c); }
            }
            return true;
        }

        // ============================================================
        // GAME LOOP (rendering only ‚Äî logic on server)
        // ============================================================

        // Blended walk/sit animation helper
        function animateWalk(c,moving,dt,resting){
            if(c.isCustomModel){
                // Custom model: whole-body bob/sway
                c.walkBlend=Math.max(0,Math.min(1,c.walkBlend+(moving?6:-6)*dt));
                if(moving)c.walkPhase+=dt*10;
                const b=c.walkBlend,p=c.walkPhase;
                if(c.modelRoot){
                    c.modelRoot.position.y=Math.abs(Math.sin(p*2))*0.06*b; // vertical bob
                    c.modelRoot.rotation.z=Math.sin(p)*0.08*b; // side sway
                    c.modelRoot.rotation.x=moving?0.1*b:0; // forward lean
                }
                if(resting && c.modelRoot){
                    c.modelRoot.position.y=-0.08; // crouch
                    c.modelRoot.rotation.x=-0.15;
                }
                return;
            }
            if(resting){
                // Sitting pose: legs forward, body lowered, arms on knees
                c.walkBlend=Math.max(0,c.walkBlend-4*dt);
                const sit=c.sitBlend=(c.sitBlend||0)+3*dt;
                const s=Math.min(1,sit);
                c.leftLeg.rotation.x=-1.2*s;
                c.rightLeg.rotation.x=-1.2*s;
                c.leftArm.rotation.x=-0.4*s;
                c.rightArm.rotation.x=-0.4*s;
                c.body.position.y=0.5-0.18*s;
            }else{
                c.sitBlend=Math.max(0,(c.sitBlend||0)-4*dt);
                const s=c.sitBlend;
                c.walkBlend=Math.max(0,Math.min(1,c.walkBlend+(moving?6:-6)*dt));
                if(moving)c.walkPhase+=dt*10;
                const b=c.walkBlend,p=c.walkPhase;
                c.leftLeg.rotation.x=Math.sin(p)*0.6*b + (-1.2*s);
                c.rightLeg.rotation.x=-Math.sin(p)*0.6*b + (-1.2*s);
                c.leftArm.rotation.x=-Math.sin(p)*0.5*b + (-0.4*s);
                c.rightArm.rotation.x=Math.sin(p)*0.5*b + (-0.4*s);
                c.body.position.y=0.5+Math.abs(Math.sin(p*2))*0.04*b - 0.18*s;
            }
        }
        const clock=new THREE.Clock();
        function animate(){
            requestAnimationFrame(animate);
            const dt=clock.getDelta();const time=clock.getElapsedTime();
            // Camera follows player (smooth)
            camTargetX=myChar.group.position.x;
            camTargetZ=myChar.group.position.z;
            camDt=dt;
            if(!chatInputFocused){
                if(keys['a'])camAngle-=1.5*dt;
                if(keys['d'])camAngle+=1.5*dt;
                if(keys['w']){camPitch=Math.min(1.2,camPitch+1.0*dt);}
                if(keys['s']){camPitch=Math.max(0.15,camPitch-1.0*dt);}
            }
            updateCamera();
            // Roof hiding ‚Äî hide roof when player is inside building
            const ptx=Math.round(myChar.group.position.x),ptz=Math.round(myChar.group.position.z);
            buildingRoofs.forEach((bg,id)=>{
                if(bg.isOpenAir)return; // always hidden
                const inside=ptx>=bg.bounds.minX&&ptx<=bg.bounds.maxX&&ptz>=bg.bounds.minZ&&ptz<=bg.bounds.maxZ;
                bg.roof.visible=!inside;
            });
            // Update chunks based on player position
            updateChunks(myChar.group.position.x,myChar.group.position.z);
            // Water animation
            const v=waterGeo.attributes.position;for(let i=0;i<v.count;i++){v.setY(i,Math.sin(v.getX(i)*2+time)*0.02+Math.cos(v.getZ(i)*2+time*1.3)*0.02);}v.needsUpdate=true;
            // Fireflies
            particles.forEach(p=>{p.visible=isNight;if(isNight){p.position.y+=Math.sin(time*p.userData.speed+p.userData.offset)*0.003;p.position.x+=Math.sin(time*0.3+p.userData.offset)*0.005;p.material.opacity=0.5+Math.sin(time*2+p.userData.offset)*0.5;}});
            // Fountain spray animation
            fountainSpray.forEach(s=>{s.angle+=s.speed*dt;const r=0.35;s.mesh.position.x=Math.cos(s.angle)*r;s.mesh.position.z=Math.sin(s.angle)*r;s.mesh.position.y=1.6+Math.sin(time*3+s.angle)*0.15;});
            // Smooth interpolation
            const lerpAmt=1-Math.exp(-LERP_SPEED*dt);
            // My character
            myChar.group.position.x+=(myTargetX-myChar.group.position.x)*lerpAmt;
            myChar.group.position.y+=(myTargetH-myChar.group.position.y)*lerpAmt;
            myChar.group.position.z+=(myTargetZ-myChar.group.position.z)*lerpAmt;
            myChar.group.rotation.y+=(myTargetRot-myChar.group.rotation.y)*lerpAmt;
            if(!updateCharAnim(myChar,dt)){animateWalk(myChar,myIsMoving,dt,myIsResting);}
            // Other players
            otherPlayerMeshes.forEach(m=>{
                m.group.position.x+=(m.targetX-m.group.position.x)*lerpAmt;m.group.position.y+=(m.targetH-m.group.position.y)*lerpAmt;m.group.position.z+=(m.targetZ-m.group.position.z)*lerpAmt;m.group.rotation.y+=(m.targetRot-m.group.rotation.y)*lerpAmt;
                if(m.leftLeg){if(!updateCharAnim(m,dt))animateWalk(m,m.isMoving,dt,m.isResting||false);}
            });
            // NPCs
            npcMeshes.forEach(m=>{m.group.position.x+=(m.targetX-m.group.position.x)*lerpAmt;m.group.position.y+=(m.targetH-m.group.position.y)*lerpAmt;m.group.position.z+=(m.targetZ-m.group.position.z)*lerpAmt;m.group.rotation.y+=(m.targetRot-m.group.rotation.y)*lerpAmt;
                if(m.leftLeg){if(!updateCharAnim(m,dt))animateWalk(m,m.isMoving,dt,false);}
            });
            // Monsters
            monsterMeshes.forEach(m=>{m.group.position.x+=(m.targetX-m.group.position.x)*lerpAmt;m.group.position.y+=(m.targetH-m.group.position.y)*lerpAmt;m.group.position.z+=(m.targetZ-m.group.position.z)*lerpAmt;m.group.rotation.y+=(m.targetRot-m.group.rotation.y)*lerpAmt;
                if(m.isHumanoid&&m.leftLeg){if(!updateCharAnim(m,dt))animateWalk(m,m.isMoving,dt,false);}
                if(m.state.isDead)m.group.visible=false; else m.group.visible=true;
            });
            // Path visualization cleanup + destination pulse
            if(pathGroup.children.length>0){
                const px=myChar.group.position.x,pz=myChar.group.position.z;
                for(let i=pathGroup.children.length-1;i>=0;i--){
                    const d=pathGroup.children[i];
                    if(Math.abs(d.userData.px-px)<0.6&&Math.abs(d.userData.pz-pz)<0.6)pathGroup.remove(d);
                }
                if(!myIsMoving){clearWalkPath();}
            }
            if(destMarker){
                const pulse=1+Math.sin(time*4)*0.15;
                destMarker.scale.set(pulse,pulse,pulse);
                destMarker.material.opacity=0.25+Math.sin(time*3)*0.15;
                if(!myIsMoving){clearWalkPath();}
            }
            updateOverlays();
            drawMinimap();
            renderer.render(scene,camera);
        }

        // ============================================================
        // INIT
        // ============================================================
        document.querySelector('.stat-player-name').textContent=playerName;
        addChat('system','Welcome to AgentScape! Connecting...');
        connect();

        // Welcome Tutorial
        (function(){
            if(localStorage.getItem('agentscape_tutorial_done'))return;
            const overlay=document.getElementById('tutorial-overlay');
            const iconEl=document.getElementById('tutorial-icon');
            const textEl=document.getElementById('tutorial-text');
            const btnEl=document.getElementById('tutorial-btn');
            const steps=[
                {icon:'\u{1F5B1}\uFE0F',text:'Click anywhere on the ground to move your character around the world.',btn:'Next'},
                {icon:'\u{1F4CB}',text:'Visit the Quest Board in the town square to start your adventure and earn rewards!',btn:'Next'},
                {icon:'\u{1F30D}',text:'Explore the districts of SUITE City and venture into the wilderness beyond!',btn:"Let's Go!"}
            ];
            let step=0;
            function showStep(){
                const s=steps[step];
                iconEl.textContent=s.icon;textEl.textContent=s.text;btnEl.textContent=s.btn;
                for(let i=0;i<3;i++)document.getElementById('tdot'+i).classList.toggle('active',i===step);
            }
            btnEl.onclick=function(){
                step++;
                if(step>=steps.length){localStorage.setItem('agentscape_tutorial_done','1');overlay.style.display='none';return;}
                showStep();
            };
            showStep();overlay.style.display='';
        })();

        animate();
        window.addEventListener('resize',()=>{camera.aspect=viewport.clientWidth/viewport.clientHeight;camera.updateProjectionMatrix();renderer.setSize(viewport.clientWidth,viewport.clientHeight);});

        } // end startGame
    })();
    </script>
</body>
</html>
